[{"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\App.tsx":"1","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\Canvas.tsx":"2","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\CanvasHook.ts":"3","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\index.tsx":"4","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\core\\foRenderer.tsx":"5","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foPage.model.ts":"6","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foGlyph2D.model.ts":"7","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foTools.ts":"8","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foLifecycle.ts":"9","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foObject.model.ts":"10","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foMatrix2D.ts":"11","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foGeometry2D.ts":"12","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foShape2D.model.ts":"13"},{"size":2068,"mtime":1607334276953,"results":"14","hashOfConfig":"15"},{"size":517,"mtime":1607314452068,"results":"16","hashOfConfig":"15"},{"size":1032,"mtime":1607331683811,"results":"17","hashOfConfig":"15"},{"size":200,"mtime":1607284035886,"results":"18","hashOfConfig":"15"},{"size":1640,"mtime":1607314452076,"results":"19","hashOfConfig":"15"},{"size":5303,"mtime":1607333778906,"results":"20","hashOfConfig":"15"},{"size":17599,"mtime":1607331264032,"results":"21","hashOfConfig":"15"},{"size":14070,"mtime":1607331082296,"results":"22","hashOfConfig":"15"},{"size":6154,"mtime":1607314452085,"results":"23","hashOfConfig":"15"},{"size":10904,"mtime":1607314452086,"results":"24","hashOfConfig":"15"},{"size":9180,"mtime":1607314555578,"results":"25","hashOfConfig":"15"},{"size":7560,"mtime":1607315554112,"results":"26","hashOfConfig":"15"},{"size":5455,"mtime":1607333086618,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"1x4sejr",{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41","usedDeprecatedRules":"30"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44","usedDeprecatedRules":"30"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"30"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"30"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"30"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59","usedDeprecatedRules":"30"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"62","usedDeprecatedRules":"30"},"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\App.tsx",[],["63","64"],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\Canvas.tsx",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\CanvasHook.ts",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\index.tsx",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\core\\foRenderer.tsx",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foPage.model.ts",["65","66","67","68","69","70"],"\r\nimport { cPoint2D, cFrame } from './foGeometry2D';\r\nimport { iPoint2D, Action } from './foInterface';\r\n\r\nimport { foGlyph2D } from './foGlyph2D.model';\r\n\r\nimport { WhereClause } from './foInterface';\r\n\r\nimport { Matrix2D } from './foMatrix2D';\r\nimport { foObject } from './foObject.model';\r\n\r\n\r\n//a Shape is a graphic designed to behave like a visio shape\r\n//and have all the same properties\r\nexport class foPage extends foGlyph2D {\r\n  gridSizeX: number = 50;\r\n  gridSizeY: number = 50;\r\n  showBoundry: boolean = true;\r\n\r\n\r\n  constructor(\r\n    properties?: any,\r\n    parent?: foObject\r\n  ) {\r\n    super(properties, parent);\r\n    this.override(properties);\r\n  }\r\n  \r\n\r\n  protected _marginX: number;\r\n  get marginX(): number {\r\n    return this._marginX || 0.0;\r\n  }\r\n  set marginX(value: number) {\r\n    this.smash();\r\n    this._marginX = value;\r\n  }\r\n\r\n  protected _marginY: number;\r\n  get marginY(): number {\r\n    return this._marginY || 0.0;\r\n  }\r\n  set marginY(value: number) {\r\n    this.smash();\r\n    this._marginY = value;\r\n  }\r\n\r\n  protected _scaleX: number;\r\n  get scaleX(): number {\r\n    return this._scaleX || 1.0;\r\n  }\r\n  set scaleX(value: number) {\r\n    this.smash();\r\n    this._scaleX = value;\r\n  }\r\n\r\n  protected _scaleY: number;\r\n  get scaleY(): number {\r\n    return this._scaleY || 1.0;\r\n  }\r\n  set scaleY(value: number) {\r\n    this.smash();\r\n    this._scaleY = value;\r\n  }\r\n\r\n\r\n  mouseLoc: any = {};\r\n\r\n \r\n\r\n\r\n  // getMatrix() {\r\n  //   if (this._matrix === undefined) {\r\n  //     this._matrix = new Matrix2D();\r\n  //     this._matrix.appendTransform(\r\n  //       this.marginX + this.x,\r\n  //       this.marginY + this.y,\r\n  //       this.scaleX,\r\n  //       this.scaleY,\r\n  //       this.rotationZ(),\r\n  //       0,\r\n  //       0,\r\n  //       this.pinX(),\r\n  //       this.pinY()\r\n  //     );\r\n  //   }\r\n  //   return this._matrix;\r\n  // }\r\n\r\n \r\n\r\n\r\n  zoomBy(zoom: number) {\r\n    this.scaleX *= zoom;\r\n    this.scaleY *= zoom;\r\n  }\r\n\r\n \r\n\r\n\r\n\r\n  drawGrid(ctx: CanvasRenderingContext2D) {\r\n    ctx.save();\r\n    ctx.beginPath();\r\n\r\n    ctx.setLineDash([5, 1]);\r\n    ctx.strokeStyle = 'gray';\r\n\r\n    const left = this.marginX - this.x;\r\n    const top = this.marginY - this.y;\r\n    const width = this.width / this.scaleX;\r\n    const height = this.height / this.scaleY;\r\n    const right = left + width;\r\n    const bottom = top + height;\r\n\r\n    //ctx.fillStyle = 'yellow';\r\n    //ctx.fillRect(left,top, width, height);\r\n\r\n    //draw vertical...\r\n    let x = this.gridSizeX; //left;\r\n    while (x < right) {\r\n      ctx.moveTo(x, top);\r\n      ctx.lineTo(x, bottom);\r\n      x += this.gridSizeX;\r\n    }\r\n    x = -this.gridSizeX; //left;\r\n    while (x > left) {\r\n      ctx.moveTo(x, top);\r\n      ctx.lineTo(x, bottom);\r\n      x -= this.gridSizeX;\r\n    }\r\n\r\n    //draw horizontal...\r\n    let y = this.gridSizeY; //top;\r\n    while (y < bottom) {\r\n      ctx.moveTo(left, y);\r\n      ctx.lineTo(right, y);\r\n      y += this.gridSizeY;\r\n    }\r\n\r\n    y = -this.gridSizeY; //top;\r\n    while (y > top) {\r\n      ctx.moveTo(left, y);\r\n      ctx.lineTo(right, y);\r\n      y -= this.gridSizeY;\r\n    }\r\n\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n\r\n  drawAxis(ctx: CanvasRenderingContext2D) {\r\n    ctx.save();\r\n    ctx.beginPath();\r\n\r\n    ctx.strokeStyle = 'black';\r\n    ctx.lineWidth = 3;\r\n\r\n    const left = this.marginX - this.x;\r\n    const top = this.marginY - this.y;\r\n    const width = this.width / this.scaleX;\r\n    const height = this.height / this.scaleY;\r\n    const right = left + width;\r\n    const bottom = top + height;\r\n\r\n    //draw vertical...\r\n    ctx.moveTo(0, top);\r\n    ctx.lineTo(0, bottom);\r\n\r\n    //draw horizontal...\r\n\r\n    ctx.moveTo(left, 0);\r\n    ctx.lineTo(right, 0);\r\n\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n\r\n  drawPage(ctx: CanvasRenderingContext2D) {\r\n    ctx.save();\r\n    ctx.beginPath();\r\n\r\n    ctx.strokeStyle = 'black';\r\n    ctx.lineWidth = 5;\r\n\r\n    //let left = this.marginX - this.x;\r\n    //let top = this.marginY - this.y;\r\n    //let width = this.width / this.scaleX;\r\n    //let height = this.height / this.scaleY;\r\n    //let right = left + width;\r\n    //let bottom = top + height;\r\n\r\n    //draw vertical...\r\n    ctx.rect(0, 0, this.width, this.height);\r\n\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n\r\n  drawName(ctx: CanvasRenderingContext2D) {\r\n    ctx.save();\r\n    ctx.font = '50pt Calibri';\r\n    ctx.lineWidth = 3;\r\n    ctx.strokeStyle = 'blue';\r\n    ctx.strokeText(this.myName, 10, 50);\r\n    ctx.restore();\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  public render(ctx: CanvasRenderingContext2D, deep: boolean = true) {\r\n    ctx.clearRect(0, 0, this.width, this.height);\r\n\r\n    ctx.save();\r\n   \r\n    this.drawName(ctx);\r\n\r\n    this.preDraw && this.preDraw(ctx);\r\n    this.draw(ctx);\r\n    //this.drawHover && this.drawHover(ctx);\r\n    this.postDraw && this.postDraw(ctx);\r\n\r\n    // deep &&\r\n    //   this._subcomponents.forEach(item => {\r\n    //     item.render(ctx, deep);\r\n    //   });\r\n    ctx.restore();\r\n\r\n    this.showBoundry && this.afterRender(ctx);\r\n  }\r\n\r\n  public preDraw = (ctx: CanvasRenderingContext2D): void => {\r\n    ctx.fillStyle = this.color;\r\n    ctx.fillRect(0, 0, this.width, this.height);\r\n  }\r\n\r\n  public draw = (ctx: CanvasRenderingContext2D): void => {\r\n    this.drawGrid(ctx);\r\n    this.drawAxis(ctx);\r\n    this.drawPage(ctx);\r\n    this.drawPin(ctx);\r\n  }\r\n}\r\n\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foGlyph2D.model.ts",["71","72"],"import { Tools } from './foTools';\r\nimport { cPoint2D, cFrame } from './foGeometry2D';\r\nimport { Matrix2D } from './foMatrix2D';\r\n\r\nimport { iShape, iPoint2D, iRect, iFrame } from './foInterface';\r\n\r\n\r\nimport { Lifecycle } from './foLifecycle';\r\n\r\n\r\nimport { foObject } from './foObject.model';\r\n\r\n\r\n// a Glyph is a graphic designed to draw on a canvas in absolute coordinates\r\nexport class foGlyph2D extends foObject {\r\n\r\n  protected opacity: number = 1.0;\r\n  protected isSelected: boolean = true;\r\n  protected color: any;\r\n\r\n  protected _x: number;\r\n  protected _y: number;\r\n  protected _width: number;\r\n  protected _height: number;\r\n\r\n  constructor(properties?: any, parent?: foObject) {\r\n    super(properties, parent);\r\n\r\n    this.override(properties);\r\n  }\r\n\r\n  get x(): number {\r\n    return this._x || 0.0;\r\n  }\r\n  set x(value: number) {\r\n    this.smash();\r\n    this._x = value;\r\n  }\r\n  get y(): number {\r\n    return this._y || 0.0;\r\n  }\r\n  set y(value: number) {\r\n    this.smash();\r\n    this._y = value;\r\n  }\r\n\r\n  get width(): number {\r\n    return this._width || 0.0;\r\n  }\r\n  set width(value: number) {\r\n    this._width = value;\r\n  }\r\n\r\n  get height(): number {\r\n    return this._height || 0.0;\r\n  }\r\n  set height(value: number) {\r\n    this._height = value;\r\n  }\r\n\r\n  public rotationZ = (): number => {\r\n    return 0;\r\n  };\r\n  \r\n  public doubleClick: (keys:any) => void;\r\n\r\n  public openEditor: () => void;\r\n  public closeEditor: () => void;\r\n  public drawHover: (ctx: CanvasRenderingContext2D) => void;\r\n  public setupHoverEnterDraw: () => void;\r\n  public setupHoverExitDraw: () => void;\r\n  public setupOverlapEnterDraw: () => void;\r\n  public setupOverlapExitDraw: () => void;\r\n\r\n  public sendKeys: (e: KeyboardEvent, keys: any) => void;\r\n  public preDraw: (ctx: CanvasRenderingContext2D) => void;\r\n  public postDraw: (ctx: CanvasRenderingContext2D) => void;\r\n\r\n  protected _matrix: Matrix2D;\r\n  protected _invMatrix: Matrix2D;\r\n  smash() {\r\n    //console.log('smash matrix')\r\n    this._matrix = undefined;\r\n    this._invMatrix = undefined;\r\n  }\r\n\r\n  computeBoundry(frame: cFrame): cFrame {\r\n    const mtx = this.getGlobalMatrix();\r\n    //this is a buffer so we create less garbage\r\n    const pt = frame.point;\r\n    frame.init(mtx.transformPoint(0, 0, pt));\r\n    frame.minmax(mtx.transformPoint(0, this.height, pt));\r\n    frame.minmax(mtx.transformPoint(this.width, 0, pt));\r\n    frame.minmax(mtx.transformPoint(this.width, this.height, pt));\r\n    return frame;\r\n  }\r\n\r\n  protected _boundry: cFrame = new cFrame(this);\r\n  get boundryFrame(): cFrame {\r\n    this.computeBoundry(this._boundry);\r\n\r\n\r\n    return this._boundry;\r\n  }\r\n\r\n  public drawBoundry(ctx: CanvasRenderingContext2D) {\r\n    ctx.beginPath();\r\n    ctx.setLineDash([5, 5]);\r\n    this.boundryFrame.draw(ctx, false);\r\n    ctx.stroke();\r\n  }\r\n\r\n\r\n\r\n  is2D() {\r\n    return true;\r\n  }\r\n\r\n  set(x: number, y: number, width: number, height: number): iRect {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = width;\r\n    this.height = height;\r\n    return this;\r\n  }\r\n\r\n  contains(x: number, y: number): boolean {\r\n    return (\r\n      this.x <= x &&\r\n      x <= this.x + this.width &&\r\n      this.y <= y &&\r\n      y <= this.y + this.height\r\n    );\r\n  }\r\n\r\n  localContains(x: number, y: number): boolean {\r\n    return 0 <= x && x <= this.width && 0 <= y && y <= this.height;\r\n  }\r\n\r\n  protected toJson(): any {\r\n    return Tools.mixin(super.toJson(), {\r\n      x: this.x,\r\n      y: this.y,\r\n      width: this.width,\r\n      height: this.height\r\n    });\r\n  }\r\n\r\n  public initialize(\r\n    x: number = Number.NaN,\r\n    y: number = Number.NaN,\r\n    ang: number = Number.NaN\r\n  ) {\r\n    return this;\r\n  }\r\n\r\n  public didLocationChange(\r\n    x: number = Number.NaN,\r\n    y: number = Number.NaN,\r\n    angle: number = Number.NaN\r\n  ): boolean {\r\n    let changed = false;\r\n    if (!Number.isNaN(x) && this.x !== x) {\r\n      changed = true;\r\n      this.x = x;\r\n    }\r\n\r\n    if (!Number.isNaN(y) && this.y !== y) {\r\n      changed = true;\r\n      this.y = y;\r\n    }\r\n\r\n    return changed;\r\n  }\r\n\r\n  public easeToNoLifecycle(x: number, y: number) {\r\n    this.initialize(x, y);\r\n    return this;\r\n  }\r\n\r\n  // public easeToNoLifecycle(\r\n  //   x: number,\r\n  //   y: number,\r\n  //   time: number = 0.5,\r\n  //   ease: any = Back.easeInOut\r\n  // ) {\r\n  //   TweenLite.to(this, time, {\r\n  //     x: x,\r\n  //     y: y,\r\n  //     ease: ease\r\n  //     // }).eventCallback(\"onUpdate\", () => {\r\n  //     //     this.drop();\r\n  //   }).eventCallback('onComplete', () => {\r\n  //     this.initialize(x, y);\r\n  //   });\r\n\r\n  //   return this;\r\n  // }\r\n\r\n  // public easeTo(x: number, y: number) {\r\n  //   this.initialize(x, y);\r\n  //   return this;\r\n  // }\r\n\r\n  // public easeTo(\r\n  //   x: number,\r\n  //   y: number,\r\n  //   time: number = 0.5,\r\n  //   ease: any = Back.easeInOut\r\n  // ) {\r\n  //   TweenLite.to(this, time, {\r\n  //     x: x,\r\n  //     y: y,\r\n  //     ease: ease\r\n  //   })\r\n  //     .eventCallback('onUpdate', () => {\r\n  //       this.move();\r\n  //     })\r\n  //     .eventCallback('onComplete', () => {\r\n  //       this.dropAt(x, y);\r\n  //       Lifecycle.easeTo(this, this.getLocation());\r\n  //     });\r\n\r\n  //   return this;\r\n  // }\r\n\r\n  public easeTween(to: any, time: number = 0.5) {\r\n    Lifecycle.easeTween(this, { time, undefined, to });\r\n    return this;\r\n  }\r\n\r\n  // public easeTween(to: any, time: number = 0.5, ease: any = 'ease') {\r\n  //   const from = Tools.union(to, { ease: Back[ease] });\r\n\r\n  //   TweenLite.to(this, time, from).eventCallback('onComplete', () =>\r\n  //     this.override(to)\r\n  //   );\r\n  //   Lifecycle.easeTween(this, { time, ease, to });\r\n  //   return this;\r\n  // }\r\n\r\n  public dropAt(\r\n    x: number = Number.NaN,\r\n    y: number = Number.NaN,\r\n    angle: number = Number.NaN\r\n  ) {\r\n    if (this.didLocationChange(x, y, angle)) {\r\n      Lifecycle.dropped(this, this.getLocation());\r\n    }\r\n    return this;\r\n  }\r\n\r\n  public move(\r\n    x: number = Number.NaN,\r\n    y: number = Number.NaN,\r\n    angle: number = Number.NaN\r\n  ) {\r\n    if (this.didLocationChange(x, y, angle)) {\r\n      Lifecycle.moved(this, this.getLocation());\r\n    }\r\n    return this;\r\n  }\r\n\r\n  public moveTo(loc: iPoint2D, offset?: iPoint2D) {\r\n    const x = loc.x + (offset ? offset.x : 0);\r\n    const y = loc.y + (offset ? offset.y : 0);\r\n    return this.move(x, y);\r\n  }\r\n\r\n  public moveBy(loc: iPoint2D, offset?: iPoint2D) {\r\n    const x = this.x + loc.x + (offset ? offset.x : 0);\r\n    const y = this.y + loc.y + (offset ? offset.y : 0);\r\n    return this.move(x, y);\r\n  }\r\n\r\n  updateContext(ctx: CanvasRenderingContext2D) {\r\n    const mtx = this.getMatrix();\r\n    ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\r\n    ctx.globalAlpha *= this.opacity;\r\n  }\r\n\r\n  getGlobalMatrix() {\r\n    const mtx = new Matrix2D(this.getMatrix());\r\n    const parent = this.myParent && <foGlyph2D>this.myParent();\r\n    if (parent) {\r\n      mtx.prependMatrix(parent.getGlobalMatrix());\r\n    }\r\n    return mtx;\r\n  }\r\n\r\n  getMatrix() {\r\n    if (this._matrix === undefined) {\r\n      this._matrix = new Matrix2D();\r\n      this._matrix.appendTransform(this.x, this.y, 1, 1, 0, 0, 0, 0, 0);\r\n    }\r\n    return this._matrix;\r\n  }\r\n\r\n  getInvMatrix() {\r\n    if (this._invMatrix === undefined) {\r\n      this._invMatrix = this.getMatrix().invertCopy();\r\n    }\r\n    return this._invMatrix;\r\n  }\r\n\r\n  localToGlobal(x: number, y: number, pt?: cPoint2D) {\r\n    const mtx = this.getGlobalMatrix();\r\n    return mtx.transformPoint(x, y, pt);\r\n  }\r\n\r\n  localToGlobalPoint(pt: cPoint2D): cPoint2D {\r\n    const mtx = this.getGlobalMatrix();\r\n    return mtx.transformPoint(pt.x, pt.y, pt);\r\n  }\r\n\r\n  globalToLocal(x: number, y: number, pt?: cPoint2D): cPoint2D {\r\n    const inv = this.getGlobalMatrix().invertCopy();\r\n    return inv.transformPoint(x, y, pt);\r\n  }\r\n\r\n  globalToLocalPoint(pt: cPoint2D): cPoint2D {\r\n    const inv = this.getGlobalMatrix().invertCopy();\r\n    return inv.transformPoint(pt.x, pt.y, pt);\r\n  }\r\n\r\n  globalToLocalFrame(\r\n    x1: number,\r\n    y1: number,\r\n    x2: number,\r\n    y2: number,\r\n    frame?: cFrame\r\n  ): cFrame {\r\n    frame = frame || new cFrame();\r\n    const inv = this.getGlobalMatrix().invertCopy();\r\n\r\n    frame.init(inv.transformPoint(x1, y1, frame.point));\r\n    frame.minmax(inv.transformPoint(x1, y2, frame.point));\r\n    frame.minmax(inv.transformPoint(x2, y1, frame.point));\r\n    frame.minmax(inv.transformPoint(x2, y2, frame.point));\r\n    return frame;\r\n  }\r\n\r\n  localToLocal(\r\n    x: number,\r\n    y: number,\r\n    target: foGlyph2D,\r\n    pt?: cPoint2D\r\n  ): cPoint2D {\r\n    pt = this.localToGlobal(x, y, pt);\r\n    return target.globalToLocal(pt.x, pt.y, pt);\r\n  }\r\n\r\n  globalCenter(): cPoint2D {\r\n    const { x, y } = this.pinLocation();\r\n    const mtx = this.getGlobalMatrix();\r\n    return mtx.transformPoint(x, y);\r\n  }\r\n\r\n  public isDragable = (): boolean => {\r\n    return true;\r\n  };\r\n\r\n  public getOffset = (loc: iPoint2D): iPoint2D => {\r\n    const x = this.x;\r\n    const y = this.y;\r\n    return new cPoint2D(x - loc.x, y - loc.y);\r\n  };\r\n\r\n  public getLocation = (): any => {\r\n    return {\r\n      x: this.x,\r\n      y: this.y,\r\n      z: 0\r\n    };\r\n  };\r\n\r\n  public pinLocation(): any {\r\n    return {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0\r\n    };\r\n  }\r\n\r\n  public setLocation = (loc?: iPoint2D) => {\r\n    this.x = loc ? loc.x : 0;\r\n    this.y = loc ? loc.y : 0;\r\n  };\r\n\r\n  protected localHitTest = (hit: iPoint2D): boolean => {\r\n    const { x, y } = hit;\r\n    const loc = this.globalToLocal(x, y);\r\n\r\n    if (loc.x < 0) return false;\r\n    if (loc.x > this.width) return false;\r\n\r\n    if (loc.y < 0) return false;\r\n    if (loc.y > this.height) return false;\r\n    return true;\r\n  };\r\n\r\n  public hitTest = (hit: iPoint2D): boolean => {\r\n    return this.isHitable && this.isVisible && this.localHitTest(hit);\r\n  };\r\n\r\n  public overlapTest = (hit: iFrame): boolean => {\r\n    const frame = this.globalToLocalFrame(hit.x1, hit.y1, hit.x2, hit.y2);\r\n\r\n    if (this.localContains(frame.x1, frame.y1)) return true;\r\n    if (this.localContains(frame.x1, frame.y2)) return true;\r\n    if (this.localContains(frame.x2, frame.y1)) return true;\r\n    if (this.localContains(frame.x2, frame.y2)) return true;\r\n    return false;\r\n  };\r\n\r\n  // findObjectUnderPoint(hit: iPoint2D, deep: boolean): foGlyph2D {\r\n  //   let found: foGlyph2D = this.hitTest(hit) ? this : undefined;\r\n\r\n  //   if (deep) {\r\n  //     const child = this.findChildObjectUnderPoint(hit);\r\n  //     found = child ? child : found;\r\n  //   }\r\n  //   return found;\r\n  // }\r\n\r\n\r\n\r\n \r\n\r\n\r\n  public afterRender = (\r\n    ctx: CanvasRenderingContext2D,\r\n    deep: boolean = true\r\n  ) => {\r\n    ctx.save();\r\n    ctx.lineWidth = 4;\r\n    ctx.strokeStyle = 'pink';\r\n    this.drawBoundry(ctx);\r\n    ctx.restore();\r\n\r\n    // deep &&\r\n    //   this.nodes.forEach(item => {\r\n    //     item.afterRender(ctx, deep);\r\n    //   });\r\n  };\r\n\r\n  public render(ctx: CanvasRenderingContext2D, deep: boolean = true) {\r\n    if (this.isInvisible) return;\r\n    ctx.save();\r\n\r\n    //this.drawOrigin(ctx);\r\n    this.updateContext(ctx);\r\n    //this.drawOriginX(ctx);\r\n\r\n    this.preDraw && this.preDraw(ctx);\r\n    this.draw(ctx);\r\n    this.drawHover && this.drawHover(ctx);\r\n    this.postDraw && this.postDraw(ctx);\r\n\r\n    //this.isSelected && this.drawSelected(ctx);\r\n\r\n    // deep &&\r\n    //   this.nodes.forEach(item => {\r\n    //     item.render(ctx, deep);\r\n    //   });\r\n\r\n    ctx.restore();\r\n  }\r\n\r\n  public drawFont(\r\n    ctx: CanvasRenderingContext2D,\r\n    size: number = 20,\r\n    fontFamily: string = 'Arial',\r\n    align: any = 'center',\r\n    base: any = 'middle'\r\n  ) {\r\n    ctx.textAlign = align;\r\n    ctx.textBaseline = base;\r\n    ctx.font = `${size}px ${fontFamily}`;\r\n  }\r\n\r\n  //https://stackoverflow.com/questions/6061880/html5-canvas-circle-text\r\n\r\n  public drawTextCircle = (\r\n    ctx: CanvasRenderingContext2D,\r\n    text: string,\r\n    radius: number = 100,\r\n    start: number = Math.PI / 2,\r\n    x: number = 0,\r\n    y: number = 0\r\n  ): void => {\r\n    if (text) {\r\n\r\n      ctx.save();\r\n      ctx.textAlign = 'center';\r\n      ctx.textBaseline = 'middle';\r\n      ctx.translate(x, y);\r\n      ctx.rotate(start - Math.PI / 2);\r\n\r\n      let len = text.length;\r\n      for (let i = 0; i < len; i++) {\r\n        let s = text[i];\r\n        let letterAngle = 0.5 * (ctx.measureText(s).width / radius);\r\n\r\n        ctx.rotate(letterAngle);\r\n        ctx.save();\r\n\r\n        ctx.translate(0, -radius);\r\n        ctx.fillText(s, 0, 0);\r\n        ctx.restore();\r\n\r\n        ctx.rotate(letterAngle);\r\n      }\r\n      ctx.restore();\r\n    }\r\n  };\r\n\r\n  public drawText = (\r\n    ctx: CanvasRenderingContext2D,\r\n    text: string,\r\n    x: number = 0,\r\n    y: number = 0\r\n  ): void => {\r\n    if (text) {\r\n      ctx.fillText(text, x, y);\r\n    }\r\n  };\r\n\r\n  public drawPin(ctx: CanvasRenderingContext2D) {\r\n    const { x, y } = this.pinLocation();\r\n\r\n    ctx.save();\r\n    ctx.beginPath();\r\n\r\n    ctx.arc(x, y, 6, 0, 2 * Math.PI, false);\r\n    ctx.fillStyle = 'pink';\r\n    ctx.fill();\r\n    ctx.lineWidth = 1;\r\n    ctx.strokeStyle = '#003300';\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n\r\n  public drawOrigin(ctx: CanvasRenderingContext2D) {\r\n    const { x, y } = this.pinLocation();\r\n\r\n    ctx.save();\r\n    ctx.beginPath();\r\n    ctx.setLineDash([5, 5]);\r\n    ctx.moveTo(x - 50, y);\r\n    ctx.lineTo(x + 50, y);\r\n    ctx.moveTo(x, y - 50);\r\n    ctx.lineTo(x, y + 50);\r\n    ctx.lineWidth = 1;\r\n    ctx.strokeStyle = '#003300';\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n\r\n  public drawOriginX(ctx: CanvasRenderingContext2D) {\r\n    const { x, y } = this.pinLocation();\r\n\r\n    ctx.save();\r\n    ctx.beginPath();\r\n    ctx.setLineDash([5, 5]);\r\n    ctx.moveTo(x - 50, y - 50);\r\n    ctx.lineTo(x + 50, y + 50);\r\n    ctx.moveTo(x + 50, y - 50);\r\n    ctx.lineTo(x - 50, y + 50);\r\n    ctx.lineWidth = 1;\r\n    ctx.strokeStyle = '#003300';\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n\r\n  public drawHighlight(ctx: CanvasRenderingContext2D) {\r\n    ctx.save();\r\n    ctx.strokeStyle = 'yellow';\r\n    ctx.lineWidth = 4;\r\n    this.drawOutline(ctx);\r\n    ctx.restore();\r\n  }\r\n\r\n  public drawHighlightOverlap(ctx: CanvasRenderingContext2D) {\r\n    ctx.strokeStyle = 'green';\r\n    ctx.lineWidth = 8;\r\n    this.drawOutline(ctx);\r\n    ctx.strokeStyle = 'yellow';\r\n    ctx.lineWidth = 4;\r\n    this.drawOutline(ctx);\r\n  }\r\n\r\n  public drawOutline(ctx: CanvasRenderingContext2D) {\r\n    ctx.beginPath();\r\n    ctx.setLineDash([15, 5]);\r\n    ctx.rect(0, 0, this.width, this.height);\r\n    ctx.stroke();\r\n  }\r\n\r\n \r\n\r\n  \r\n  public drawSelected = (ctx: CanvasRenderingContext2D): void => {\r\n    ctx.strokeStyle = 'red';\r\n    ctx.lineWidth = 4;\r\n    this.drawOutline(ctx);\r\n    //this.drawHandles(ctx);\r\n    this.drawPin(ctx);\r\n  };\r\n\r\n  public draw = (ctx: CanvasRenderingContext2D): void => {\r\n    ctx.fillStyle = this.color;\r\n    ctx.lineWidth = 1;\r\n    ctx.fillRect(0, 0, this.width, this.height);\r\n  };\r\n\r\n  toggleSelected() {\r\n    this.isSelected = !this.isSelected;\r\n  }\r\n\r\n  // layoutSubcomponentsVertical(resize: boolean = true, space: number = 0) {\r\n  //   let loc = this.getLocation() as cPoint2D;\r\n  //   const self = this;\r\n\r\n  //   if (resize) {\r\n  //     self.height = self.width = 0;\r\n  //     loc.x = loc.y = 0;\r\n  //   } else {\r\n  //     loc = this.nodes.first().getLocation() as cPoint2D;\r\n  //   }\r\n\r\n  //   this.nodes.forEach(item => {\r\n  //     item.setLocation(loc);\r\n  //   });\r\n\r\n  //   this.nodes.forEach(item => {\r\n  //     const { x: pinX, y: pinY } = item.pinLocation();\r\n  //     loc.x = resize ? pinX : loc.x;\r\n  //     loc.y += pinY;\r\n  //     item.easeToNoLifecycle(loc.x, loc.y);\r\n  //     loc.y += space + item.height - pinY;\r\n\r\n  //     if (resize) {\r\n  //       self.width = Math.max(self.width, item.width);\r\n  //       self.height = loc.y;\r\n  //     }\r\n  //   });\r\n\r\n  //   Lifecycle.layout(this, {\r\n  //     method: 'layoutSubcomponentsVertical',\r\n  //     resize,\r\n  //     space\r\n  //   });\r\n  //   return this;\r\n  // }\r\n\r\n  // layoutSubcomponentsHorizontal(resize: boolean = true, space: number = 0) {\r\n  //   let loc = this.getLocation() as cPoint2D;\r\n  //   const self = this;\r\n\r\n  //   if (resize) {\r\n  //     self.height = self.width = 0;\r\n  //     loc.x = loc.y = 0;\r\n  //   } else {\r\n  //     loc = this.nodes.first().getLocation() as cPoint2D;\r\n  //   }\r\n\r\n  //   this.nodes.forEach(item => {\r\n  //     item.setLocation(loc);\r\n  //   });\r\n\r\n  //   this.nodes.forEach(item => {\r\n  //     const { x: pinX, y: pinY } = item.pinLocation();\r\n  //     loc.x += pinX;\r\n  //     loc.y = resize ? pinY : loc.y;\r\n  //     item.easeToNoLifecycle(loc.x, loc.y);\r\n  //     loc.x += space + item.width - pinX;\r\n\r\n  //     if (resize) {\r\n  //       self.width = loc.x;\r\n  //       self.height = Math.max(self.height, item.height);\r\n  //     }\r\n  //   });\r\n\r\n  //   Lifecycle.layout(this, {\r\n  //     method: 'layoutSubcomponentsHorizontal',\r\n  //     resize,\r\n  //     space\r\n  //   });\r\n  //   return this;\r\n  // }\r\n\r\n  // \r\n  \r\n\r\n  // layoutMarginTop(resize: boolean = false, space: number = 0) {\r\n  //   const loc = this.getLocation() as cPoint2D;\r\n  //   const self = this;\r\n\r\n  //   loc.x = 10;\r\n  //   loc.y = space + this.height;\r\n\r\n  //   this.nodes.forEach(item => {\r\n  //     const { x: pinX, y: pinY } = item.pinLocation();\r\n  //     loc.y += pinY;\r\n  //     item.easeToNoLifecycle(loc.x + pinX, loc.y);\r\n  //     loc.y += space + item.height - pinY;\r\n\r\n  //     if (resize) {\r\n  //       self.width = Math.max(self.width, item.width);\r\n  //       self.height = loc.y;\r\n  //     }\r\n  //   });\r\n  //   Lifecycle.layout(this, { method: 'layoutMarginTop', resize, space });\r\n  //   return this;\r\n  // }\r\n}\r\n\r\n\r\n\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foTools.ts",["73"],"export enum foNames {\r\n  UNKNOWN = 'unknown',\r\n  AT = '@',\r\n  THIS = 'this',\r\n  SELF = 'self',\r\n  ROOT = 'root'\r\n}\r\n\r\n// Converts numeric degrees to radians\r\n// if (typeof (Number.prototype.toRad) === \"undefined\") {\r\n//     Number.prototype.toRad = function () {\r\n//         return this * Math.PI / 180;\r\n//     }\r\n// }\r\n// if (typeof (Number.prototype.toDeg) === \"undefined\") {\r\n//     Number.prototype.toDeg = function () {\r\n//         return this * 180 / Math.PI;\r\n//     }\r\n// }\r\n\r\nexport class foTools {\r\n  // Speed up calls to hasOwnProperty\r\n  private hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\n  constructor() {}\r\n\r\n  /**\r\n   * http://stackoverflow.com/questions/6588977/how-to-to-extract-a-javascript-function-from-a-javascript-file\r\n   * @param funct\r\n   */\r\n  getFunctionName(funct) {\r\n    let ret = funct.toString(); //do with regx\r\n    ret = ret.substr('function '.length);\r\n    ret = ret.substr(0, ret.indexOf('('));\r\n    return ret.trim();\r\n  }\r\n\r\n  //http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\r\n  generateUUID() {\r\n    let d = new Date().getTime();\r\n    const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(\r\n      /[xy]/g,\r\n      function(c) {\r\n        // tslint:disable-next-line:no-bitwise\r\n        const r = ((d + Math.random() * 16) % 16) | 0;\r\n        d = Math.floor(d / 16);\r\n        // tslint:disable-next-line:no-bitwise\r\n        return (c === 'x' ? r : (r & 0x7) | 0x8).toString(16);\r\n      }\r\n    );\r\n    return uuid;\r\n  }\r\n\r\n  asJson(target: any) {\r\n    const result = this.stringify(target);\r\n    return JSON.parse(result);\r\n  }\r\n\r\n  stringify(target: any, func = undefined, deep = 3) {\r\n    function resolveReference(value) {\r\n      if (value && value.asReference) {\r\n        return (\r\n          'resolveRef(' +\r\n          value.asReference() +\r\n          ',' +\r\n          value.constructor.name +\r\n          ')'\r\n        );\r\n      }\r\n      return value;\r\n    }\r\n    function resolveCircular(key, value) {\r\n      switch (key) {\r\n        case 'myParent':\r\n          return resolveReference(value);\r\n        case 'myMembers':\r\n          return value\r\n            ? value.map(function(item) {\r\n                return resolveReference(item);\r\n              })\r\n            : value;\r\n        case '_lookup':\r\n          return value;\r\n        case '_members':\r\n          return value;\r\n      }\r\n      if (key.startsWith('_')) {\r\n        return;\r\n      }\r\n      //if (this.isCustomLinkName(key)) {\r\n      //    return resolveReference(value);\r\n      //}\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(target, resolveCircular, deep);\r\n  }\r\n\r\n  splitNamespaceType(id: string, primitive?: string) {\r\n    const typeId = id.split('::');\r\n    let result = { namespace: '', name: id };\r\n    if (typeId.length === 2) {\r\n      result = {\r\n        namespace: typeId[0],\r\n        name: typeId[1]\r\n      };\r\n    } else if (primitive) {\r\n      result = {\r\n        namespace: typeId[0],\r\n        name: primitive\r\n      };\r\n    }\r\n    return result;\r\n  }\r\n\r\n  getNamespace(obj) {\r\n    let myNamespace = obj.myType ? obj.myType.split('::') : [''];\r\n    myNamespace = myNamespace[0];\r\n    return myNamespace;\r\n  }\r\n\r\n  getType(obj): string {\r\n    let myType = obj.myType ? obj.myType.split('::') : [''];\r\n    myType = myType.length === 2 ? myType[1] : myType[0];\r\n    return myType;\r\n  }\r\n\r\n  namespace(namespace: string, name: string) {\r\n    return `${namespace}::${name}`;\r\n  }\r\n\r\n  randomInt(low: number, high: number) {\r\n    return low + Math.floor(Math.random() * (high - low + 1));\r\n  }\r\n\r\n  random(low: number, high: number) {\r\n    return low + Math.random() * (high - low);\r\n  }\r\n\r\n  randomRGBColor() {\r\n    // tslint:disable-next-line:no-bitwise\r\n    const r = (255 * Math.random()) | 0;\r\n      // tslint:disable-next-line:no-bitwise\r\n    const g = (255 * Math.random()) | 0;\r\n      // tslint:disable-next-line:no-bitwise\r\n    const b = (255 * Math.random()) | 0;\r\n    return `rgb(${r},${g},${b})`;\r\n  }\r\n\r\n  matches(str1: string, str2: string) {\r\n    if (str1 === str2) {\r\n      return true;\r\n    }\r\n    return (\r\n      str1 && str2 && str1.toLocaleLowerCase() === str2.toLocaleLowerCase()\r\n    );\r\n  }\r\n\r\n  startsWith(str1: string, str2: string) {\r\n    if (str1 === str2) {\r\n      return true;\r\n    }\r\n    return (\r\n      str1 && str2 && str1.toLocaleLowerCase().startsWith(str2.toLocaleLowerCase())\r\n    );\r\n  }\r\n\r\n  capitalizeFirstLetter(str1: string) {\r\n    return str1.charAt(0).toUpperCase() + str1.slice(1);\r\n  }\r\n\r\n  isSelf(ref) {\r\n    return (\r\n      this.matches(ref, foNames.AT) ||\r\n      this.matches(ref, foNames.THIS) ||\r\n      this.matches(ref, foNames.SELF)\r\n    );\r\n  }\r\n\r\n  isArray(obj) {\r\n    if (Array.isArray) {\r\n      return Array.isArray(obj);\r\n    }\r\n    return Object.prototype.toString.call(obj) === '[object Array]'\r\n      ? true\r\n      : false;\r\n  }\r\n\r\n  isFunction(obj) {\r\n    return typeof obj === 'function';\r\n  }\r\n\r\n  isString(obj) {\r\n    return typeof obj === 'string';\r\n  }\r\n\r\n  isNumber(obj) {\r\n    return typeof obj === 'number';\r\n  }\r\n\r\n  isDate(obj) {\r\n    return obj instanceof Date;\r\n  }\r\n\r\n  isObject(obj) {\r\n    return obj && typeof obj === 'object'; //prevents typeOf null === 'object'\r\n  }\r\n\r\n  isCustomLinkName(key) {\r\n    return false;\r\n  }\r\n\r\n  isTyped(obj) {\r\n    return obj && obj.isInstanceOf;\r\n  }\r\n\r\n  isEmpty(obj) {\r\n    // null and undefined are \"empty\"\r\n    if (obj == null) {\r\n      return true;\r\n    }\r\n\r\n    // Assume if it has a length property with a non-zero value\r\n    // that that property is correct.\r\n    if (obj.length > 0) {\r\n      return false;\r\n    }\r\n    if (obj.length === 0) {\r\n      return true;\r\n    }\r\n\r\n    // If it isn't an object at this point\r\n    // it is empty, but it can't be anything *but* empty\r\n    // Is it empty?  Depends on your application.\r\n    if (typeof obj !== 'object') {\r\n      return true;\r\n    }\r\n\r\n    // Otherwise, does it have any properties of its own?\r\n    // Note that this doesn't handle\r\n    // toString and valueOf enumeration bugs in IE < 9\r\n    // tslint:disable-next-line:prefer-const\r\n    for (let key in obj) {\r\n      if (this.hasOwnProperty.call(obj, key)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  removeDQ(str: string): string {\r\n    return str.replace(/^\"(.*)\"$/, '$1');\r\n  }\r\n\r\n  unwrap(str: string): string {\r\n    return str.substring(1, str.length - 1);\r\n  }\r\n\r\n  wrapDQ(str: string): string {\r\n    return `\"${str}\"`;\r\n  }\r\n\r\n  wrapSQ(str: string): string {\r\n    return `'${str}'`;\r\n  }\r\n\r\n  decomposeHostPath(filename) {\r\n    let string = filename.toLowerCase();\r\n    string = string.replace('http://', '');\r\n    string = string.replace('https://', '');\r\n\r\n    const host = string.split('/')[0];\r\n    const path = string.replace(host, '');\r\n    return {\r\n      fullpath: filename,\r\n      host: host,\r\n      path: path\r\n    };\r\n  }\r\n\r\n  extend(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n    // tslint:disable-next-line:prefer-const\r\n    for (let key in source) {\r\n      if (this.hasOwnProperty.call(source, key)) {\r\n        target[key] = source[key];\r\n      }\r\n    }\r\n    return target;\r\n  }\r\n\r\n  mixin(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n    if (!target) {\r\n      return source;\r\n    }\r\n\r\n    for (const key of source) {\r\n      target[key] = source[key];\r\n    }\r\n    return target;\r\n  }\r\n\r\n  mixExact(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n    if (!target) {\r\n      return source;\r\n    }\r\n    for (const key in source) {\r\n      if (foTools.hasOwnProperty.call(target, key)) {\r\n        target[key] = source[key];\r\n      }\r\n    }\r\n    return target;\r\n  }\r\n\r\n  mixout(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n    if (!target) {\r\n      return source;\r\n    }\r\n    for (const key in source) {\r\n      if (this.hasOwnProperty.call(target, key)) {\r\n        delete target[key];\r\n      }\r\n    }\r\n    return target;\r\n  }\r\n\r\n  extract(target, keys?: string[]) {\r\n    const spec = {};\r\n    keys &&\r\n      keys.forEach(key => {\r\n        spec[key] = target[key];\r\n      });\r\n    return spec;\r\n  }\r\n\r\n  mixMap(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n\r\n    let result = {};\r\n    for (let key in target) {\r\n      const keyMap = source[key] || key;\r\n      result[keyMap] = target[key];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  intersect(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n    if (!target) {\r\n      return source;\r\n    }\r\n    const intersect = {};\r\n    for (const key in target) {\r\n      if (this.hasOwnProperty.call(source, key)) {\r\n        intersect[key] = source[key];\r\n      } else {\r\n        intersect[key] = target[key];\r\n      }\r\n    }\r\n    return intersect;\r\n  }\r\n\r\n  union(target, source) {\r\n    const result = {};\r\n    if (target) {\r\n      for (let key in target) {\r\n        result[key] = target[key];\r\n      }\r\n    }\r\n    if (source) {\r\n      for (let key in source) {\r\n        result[key] = source[key];\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  defineComputeOnlyProperty(target, name, func) {\r\n    //var self = target;\r\n    Object.defineProperty(target, name, {\r\n      enumerable: true,\r\n      configurable: true,\r\n      get: func\r\n    });\r\n    return target;\r\n  }\r\n\r\n  defineCalculatedProperty(target, name, func) {\r\n    //var self = target;\r\n    Object.defineProperty(target, name, {\r\n      enumerable: true,\r\n      configurable: true,\r\n      get: func, //.call(self, self),\r\n      set: function(value) {\r\n        this[`_${name}`] = value;\r\n      }\r\n    });\r\n    return target;\r\n  }\r\n\r\n  getMethods(obj) {\r\n    const list = [];\r\n    for (const m in obj.prototype) {\r\n      if (typeof obj[m] === 'function') {\r\n        list.push(m);\r\n      }\r\n    }\r\n    return list;\r\n  }\r\n\r\n  asArray(obj, funct?) {\r\n    if (this.isArray(obj)) {\r\n      return obj;\r\n    }\r\n    return this.mapOverKeyValue(obj, function(key, value) {\r\n      return funct ? funct(key, value) : value;\r\n    });\r\n  }\r\n\r\n  applyOverKeyValue(obj, mapFunc) {\r\n    //funct has 2 args.. key,value\r\n    const body = {};\r\n    const keys = obj ? Object.keys(obj) : [];\r\n    keys.forEach(key => {\r\n      if (this.hasOwnProperty.call(obj, key)) {\r\n        const value = obj[key];\r\n        const result = mapFunc(key, value);\r\n        if (result) {\r\n          body[key] = result;\r\n        }\r\n      }\r\n    });\r\n    return body;\r\n  }\r\n\r\n  mapOverKeyValue(obj, mapFunc) {\r\n    //funct has 2 args.. key,value\r\n    const list = [];\r\n    const keys = obj ? Object.keys(obj) : [];\r\n    keys.forEach(key => {\r\n      if (this.hasOwnProperty.call(obj, key)) {\r\n        const value = obj[key];\r\n        const result = mapFunc(key, value);\r\n        if (result) {\r\n          list.push(result);\r\n        }\r\n      }\r\n    });\r\n    return list;\r\n  }\r\n\r\n  forEachKeyValue(obj, mapFunc) {\r\n    //funct has 2 args.. key,value\r\n    const keys = obj ? Object.keys(obj) : [];\r\n    keys.forEach(key => {\r\n      if (this.hasOwnProperty.call(obj, key)) {\r\n        const value = obj[key];\r\n        mapFunc(key, value);\r\n      }\r\n    });\r\n  }\r\n\r\n  findKeyForValue(obj, key) {\r\n    for (const name in obj) {\r\n      if (this.hasOwnProperty.call(obj, key)) {\r\n        if (obj[name].matches(key)) {\r\n          return name;\r\n        }\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n\r\n  extractReadWriteKeys(spec) {\r\n    const keys: string[] = [];\r\n    Tools.forEachKeyValue(spec, (k, v) => {\r\n      if (!Tools.isFunction(v)) {\r\n        keys.push(k);\r\n      }\r\n    });\r\n    return keys;\r\n  }\r\n\r\n  extractComputedKeys(spec) {\r\n    const keys: string[] = [];\r\n    Tools.forEachKeyValue(spec, (k, v) => {\r\n      if (Tools.isFunction(v)) {\r\n        keys.push(k);\r\n      }\r\n    });\r\n    return keys;\r\n  }\r\n\r\n  overrideComputed(obj: any, properties: any) {\r\n    Tools.forEachKeyValue(properties, (key, value) => {\r\n      try {\r\n        if (Tools.isFunction(value)) {\r\n          Tools.defineCalculatedProperty(obj, key, value);\r\n        } else {\r\n          obj[key] = value;\r\n        }\r\n      } catch (ex) {\r\n        console.log(ex);\r\n      }\r\n    });\r\n  }\r\n\r\n  extendComputed(obj: any, properties: any) {\r\n    Tools.forEachKeyValue(properties, (key, value) => {\r\n      try {\r\n        if (!obj[key]) {\r\n          if (Tools.isFunction(value)) {\r\n            Tools.defineCalculatedProperty(obj, key, value);\r\n          } else {\r\n            obj[key] = value;\r\n          }\r\n        }\r\n      } catch (ex) {\r\n        console.log(ex);\r\n      }\r\n    });\r\n  }\r\n\r\n  pluck(name) {\r\n    return function(x) {\r\n      return x[name];\r\n    };\r\n  }\r\n\r\n  distinctItems(list) {\r\n    const distinct = {};\r\n    list.forEach(item => {\r\n      distinct[item] = item;\r\n    });\r\n    return Object.keys(distinct);\r\n  }\r\n\r\n  groupBy(pluckBy, list) {\r\n    const dictionary = {};\r\n    list.forEach(item => {\r\n      const key = pluckBy(item);\r\n      if (!dictionary[key]) {\r\n        dictionary[key] = [];\r\n      }\r\n      dictionary[key].push(item);\r\n    });\r\n    return dictionary;\r\n  }\r\n\r\n  //add this to new service to dynamicaly load javascript,  maybe over signalR\r\n\r\n  // xmlHttpGet(url:string, onComplete, onFailure) {\r\n  //     let xmlHttp = new window.XMLHttpRequest();\r\n  //     xmlHttp.onload = function () {\r\n  //        let result = xmlHttp.responseText;\r\n  //         onComplete && onComplete(result, xmlHttp);\r\n  //     };\r\n  //     try {\r\n  //         xmlHttp.open(\"GET\", url, false);  //this may give chrome some problems\r\n  //         xmlHttp.send(null);\r\n  //     }\r\n  //     catch (ex) {\r\n  //         onFailure && onFailure(ex, xmlHttp);\r\n  //     }\r\n  // }\r\n  // loadAsScript(url:string, onComplete) {\r\n  //     this.xmlHttpGet(url, function (text, xhr) {\r\n  //         if (xhr.status == 200 || xhr.status == 304) {\r\n  //            let head = document.getElementsByTagName(\"head\")[0];\r\n  //            let script = document.createElement('script');\r\n  //             script.innerHTML = text;\r\n  //             head.appendChild(script);\r\n  //             onComplete && onComplete(script);\r\n  //         }\r\n  //     });\r\n  //}\r\n}\r\n\r\nexport let Tools: foTools = new foTools();\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foLifecycle.ts",["74"],"import { Action } from './foInterface';\r\nimport { foObject } from './foObject.model';\r\nimport { Tools } from './foTools';\r\n\r\n// https://github.com/ReactiveX/rxjs/blob/master/docs_app/content/guide/v6/migration.md\r\nimport { Observable, Subject } from 'rxjs';\r\nimport { debounceTime, filter } from 'rxjs/operators';\r\n\r\nlet counter = 0;\r\nexport enum LifecycleEventTypes {\r\n  primitive,\r\n  defined,\r\n  created,\r\n  destroyed,\r\n}\r\n\r\nexport class foLifecycleEvent {\r\n  id: number = 0;\r\n  cmd: string = '';\r\n  object: foObject;\r\n  value: any;\r\n\r\n  get guid() {\r\n    return this.object.myGuid;\r\n  }\r\n  get simpleGuid() {\r\n    return this.object.myGuid.slice(-8);\r\n  }\r\n  get myGuid() {\r\n    return this.object.myGuid;\r\n  }\r\n  get myType() {\r\n    return this.object.myType;\r\n  }\r\n\r\n  get myClass() {\r\n    return this.object['myClass'];\r\n  }\r\n\r\n  get myName() {\r\n    return this.object.myName;\r\n  }\r\n\r\n  isNamed(name: string) {\r\n    return Tools.matches(name, this.myName);\r\n  }\r\n\r\n  isCmd(cmd: string) {\r\n    return Tools.matches(cmd, this.cmd);\r\n  }\r\n\r\n  constructor(cmd: string, obj: foObject, count: number = 0, value?: any) {\r\n    this.id = count;\r\n    this.cmd = cmd;\r\n    this.object = obj;\r\n    this.value = value;\r\n  }\r\n}\r\n\r\n//this is needed to prevent circular communiation\r\n// create => create => create across browsers\r\nexport class foLifecycleEventLock {\r\n  private _processLock = {};\r\n\r\n  isLocked(guid: string) {\r\n    return this._processLock[guid] ? true : false;\r\n  }\r\n\r\n  addLock(guid: string) {\r\n    if (!this.isLocked(guid)) {\r\n      this._processLock[guid] = 0;\r\n    }\r\n    this._processLock[guid] += 1;\r\n  }\r\n\r\n  unLock(guid: string) {\r\n    if (this.isLocked(guid)) {\r\n      this._processLock[guid] -= 1;\r\n      if (this._processLock[guid] <= 0) {\r\n        delete this._processLock[guid];\r\n      }\r\n    }\r\n  }\r\n\r\n  protected(guid: string, context: any, func: Action<any>) {\r\n    this.addLock(guid);\r\n    try {\r\n      func(context);\r\n    } catch (ex) {\r\n      console.error('protected', ex);\r\n    }\r\n    this.unLock(guid);\r\n  }\r\n\r\n  whenUnprotected(guid: string, context: any, func: Action<any>) {\r\n    if (!this.isLocked(guid)) {\r\n      try {\r\n        func(context);\r\n      } catch (ex) {\r\n        console.error('whenUnprotected ', ex);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport let LifecycleLock: foLifecycleEventLock = new foLifecycleEventLock();\r\nexport let KnowcycleLock: foLifecycleEventLock = new foLifecycleEventLock();\r\n\r\n\r\n\r\nexport class foLifecycle {\r\n  mute: boolean = false;\r\n\r\n  public observable: Observable<foLifecycleEvent>;\r\n  public emit: Subject<foLifecycleEvent>;\r\n\r\n  private debounced: Subject<foLifecycleEvent>;\r\n\r\n  constructor(debouce: number = 500) {\r\n    this.emit = new Subject<foLifecycleEvent>();\r\n    this.observable = this.emit.asObservable();\r\n\r\n    this.debounced = new Subject<foLifecycleEvent>();\r\n\r\n    this.debounced\r\n      .asObservable()\r\n      .pipe(debounceTime(debouce))\r\n      .subscribe(event => {\r\n        event.id = counter++;\r\n        this.broadcast(event);\r\n      });\r\n  }\r\n\r\n  broadcast(obj: foLifecycleEvent) {\r\n    !this.mute && this.emit.next(obj);\r\n    return this;\r\n  }\r\n\r\n  primitive(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('primitive', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  defined(obj?: foObject) {\r\n    this.broadcast(new foLifecycleEvent('defined', obj, counter++));\r\n    return this;\r\n  }\r\n\r\n  event(eventName: string, obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent(eventName, obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  created(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('created', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  destroyed(obj: foObject) {\r\n    this.broadcast(new foLifecycleEvent('destroyed', obj, counter++));\r\n    return this;\r\n  }\r\n\r\n  unparent(obj: foObject) {\r\n    this.broadcast(new foLifecycleEvent('unparent', obj, counter++));\r\n    return this;\r\n  }\r\n\r\n  reparent(obj: foObject) {\r\n    this.broadcast(new foLifecycleEvent('reparent', obj, counter++));\r\n    return this;\r\n  }\r\n\r\n  action(obj: foObject, action: string, params?: any) {\r\n    this.broadcast(\r\n      new foLifecycleEvent('run', obj, counter++, {\r\n        action: action,\r\n        params: params\r\n      })\r\n    );\r\n    return this;\r\n  }\r\n\r\n  command(obj: foObject, method: string) {\r\n    this.broadcast(new foLifecycleEvent('command', obj, counter++, method));\r\n    return this;\r\n  }\r\n\r\n  selected(obj: foObject, value: any) {\r\n    this.broadcast(new foLifecycleEvent('selected', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  pageSelections(obj: foObject, value: any) {\r\n    this.broadcast(new foLifecycleEvent('pageselections', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  layout(obj: foObject, value: any) {\r\n    this.broadcast(new foLifecycleEvent('layout', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  changed(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('changed', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  glued(obj: foObject, value: any) {\r\n    this.broadcast(new foLifecycleEvent('glued', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  unglued(obj: foObject, value: any) {\r\n    this.broadcast(new foLifecycleEvent('unglued', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  dropped(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('dropped', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  handle(obj: foObject, value?: any) {\r\n    this.debounced.next(new foLifecycleEvent('handle', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  moved(obj: foObject, value?: any) {\r\n    this.debounced.next(new foLifecycleEvent('moved', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  easeTo(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('easeTo', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  easeTween(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('easeTween', obj, counter++, value));\r\n    return this;\r\n  }\r\n}\r\n\r\nexport let Lifecycle: foLifecycle = new foLifecycle(300);\r\nexport let Knowcycle: foLifecycle = new foLifecycle();\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foObject.model.ts",[],["75","76"],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foMatrix2D.ts",["77","78","79","80"],"/**\r\n * Represents an affine transformation matrix, and provides tools for constructing and concatenating matrices.\r\n *\r\n * This matrix can be visualized as:\r\n *\r\n * \t[ a  c  tx\r\n * \t  b  d  ty\r\n * \t  0  0  1  ]\r\n *\r\n * Note the locations of b and c.\r\n *\r\n * @class Matrix2D\r\n * @param {Number} [a=1] Specifies the a property for the new matrix.\r\n * @param {Number} [b=0] Specifies the b property for the new matrix.\r\n * @param {Number} [c=0] Specifies the c property for the new matrix.\r\n * @param {Number} [d=1] Specifies the d property for the new matrix.\r\n * @param {Number} [tx=0] Specifies the tx property for the new matrix.\r\n * @param {Number} [ty=0] Specifies the ty property for the new matrix.\r\n * @constructor\r\n **/\r\n\r\nimport { cPoint2D } from './foGeometry2D';\r\n\r\n\r\nexport class Matrix2D {\r\n    static DEG_TO_RAD: number = Math.PI / 180;\r\n\r\n    public a: number = 1; //Position (0, 0) in a 3x3 affine transformation matrix.\r\n    public b: number = 0; //Position (0, 1) in a 3x3 affine transformation matrix.\r\n    public c: number = 0; //Position (1, 0) in a 3x3 affine transformation matrix.\r\n    public d: number = 1; //Position (1, 1) in a 3x3 affine transformation matrix.\r\n    public tx: number = 0; //Position (2, 0) in a 3x3 affine transformation matrix.\r\n    public ty: number = 0; //Position (2, 1) in a 3x3 affine transformation matrix.\r\n\r\n    constructor(matrix?: Matrix2D) {\r\n        if ( matrix) {\r\n            this.copy(matrix)\r\n        }\r\n    }\r\n\r\n    append(a: number, b: number, c: number, d: number, tx: number, ty: number) {\r\n        let a1 = this.a;\r\n        let b1 = this.b;\r\n        let c1 = this.c;\r\n        let d1 = this.d;\r\n        if (a != 1 || b != 0 || c != 0 || d != 1) {\r\n            this.a = a1 * a + c1 * b;\r\n            this.b = b1 * a + d1 * b;\r\n            this.c = a1 * c + c1 * d;\r\n            this.d = b1 * c + d1 * d;\r\n        }\r\n        this.tx = a1 * tx + c1 * ty + this.tx;\r\n        this.ty = b1 * tx + d1 * ty + this.ty;\r\n        return this;\r\n    };\r\n\r\n    prepend(a: number, b: number, c: number, d: number, tx: number, ty: number) {\r\n\r\n        var a1 = this.a;\r\n        var c1 = this.c;\r\n        var tx1 = this.tx;\r\n\r\n        this.a = a * a1 + c * this.b;\r\n        this.b = b * a1 + d * this.b;\r\n        this.c = a * c1 + c * this.d;\r\n        this.d = b * c1 + d * this.d;\r\n        this.tx = a * tx1 + c * this.ty + tx;\r\n        this.ty = b * tx1 + d * this.ty + ty;\r\n        return this;\r\n    };\r\n\r\n    set(a: number, b: number, c: number, d: number, tx: number, ty: number) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n        this.d = d;\r\n        this.tx = tx;\r\n        this.ty = ty;\r\n        return this;\r\n    }\r\n\r\n\r\n    appendMatrix(matrix: Matrix2D) {\r\n        return this.append(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\r\n    };\r\n\r\n    prependMatrix(matrix: Matrix2D) {\r\n        return this.prepend(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\r\n    };\r\n\r\n    appendTransform(x: number, y: number, scaleX: number, scaleY: number, rotation: number, skewX: number, skewY: number, regX: number, regY: number) {\r\n        if (rotation % 360) {\r\n            var r = rotation * Matrix2D.DEG_TO_RAD;\r\n            var cos = Math.cos(r);\r\n            var sin = Math.sin(r);\r\n        } else {\r\n            cos = 1;\r\n            sin = 0;\r\n        }\r\n\r\n        if (skewX || skewY) {\r\n            // TODO: can this be combined into a single append operation?\r\n            skewX *= Matrix2D.DEG_TO_RAD;\r\n            skewY *= Matrix2D.DEG_TO_RAD;\r\n            this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);\r\n            this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, 0, 0);\r\n        } else {\r\n            this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, x, y);\r\n        }\r\n\r\n        if (regX || regY) {\r\n            // append the registration offset:\r\n            this.tx -= regX * this.a + regY * this.c;\r\n            this.ty -= regX * this.b + regY * this.d;\r\n        }\r\n        return this;\r\n    };\r\n\r\n\r\n    prependTransform(x: number, y: number, scaleX: number, scaleY: number, rotation: number, skewX: number, skewY: number, regX: number, regY: number) {\r\n        if (rotation % 360) {\r\n            var r = rotation * Matrix2D.DEG_TO_RAD;\r\n            var cos = Math.cos(r);\r\n            var sin = Math.sin(r);\r\n        } else {\r\n            cos = 1;\r\n            sin = 0;\r\n        }\r\n\r\n        if (regX || regY) {\r\n            // prepend the registration offset:\r\n            this.tx -= regX; this.ty -= regY;\r\n        }\r\n        if (skewX || skewY) {\r\n            // TODO: can this be combined into a single prepend operation?\r\n            skewX *= Matrix2D.DEG_TO_RAD;\r\n            skewY *= Matrix2D.DEG_TO_RAD;\r\n            this.prepend(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, 0, 0);\r\n            this.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);\r\n        } else {\r\n            this.prepend(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, x, y);\r\n        }\r\n        return this;\r\n    };\r\n\r\n\r\n    rotate(angle: number) {\r\n        angle = angle * Matrix2D.DEG_TO_RAD;\r\n        var cos = Math.cos(angle);\r\n        var sin = Math.sin(angle);\r\n\r\n        var a1 = this.a;\r\n        var b1 = this.b;\r\n\r\n        this.a = a1 * cos + this.c * sin;\r\n        this.b = b1 * cos + this.d * sin;\r\n        this.c = -a1 * sin + this.c * cos;\r\n        this.d = -b1 * sin + this.d * cos;\r\n        return this;\r\n    };\r\n\r\n    skew(skewX: number, skewY: number) {\r\n        skewX = skewX * Matrix2D.DEG_TO_RAD;\r\n        skewY = skewY * Matrix2D.DEG_TO_RAD;\r\n        this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);\r\n        return this;\r\n    };\r\n\r\n    scale(x: number, y: number) {\r\n        this.a *= x;\r\n        this.b *= x;\r\n        this.c *= y;\r\n        this.d *= y;\r\n        return this;\r\n    };\r\n\r\n    translate(x: number, y: number) {\r\n        this.tx += this.a * x + this.c * y;\r\n        this.ty += this.b * x + this.d * y;\r\n        return this;\r\n    };\r\n\r\n    identity() {\r\n        this.a = this.d = 1;\r\n        this.b = this.c = this.tx = this.ty = 0;\r\n        return this;\r\n    };\r\n\r\n    invert() {\r\n        let a1 = this.a;\r\n        let b1 = this.b;\r\n        let c1 = this.c;\r\n        let d1 = this.d;\r\n        let tx1 = this.tx;\r\n        //let ty1 = this.ty;\r\n        let n = a1 * d1 - b1 * c1;\r\n\r\n        this.a = d1 / n;\r\n        this.b = -b1 / n;\r\n        this.c = -c1 / n;\r\n        this.d = a1 / n;\r\n        this.tx = (c1 * this.ty - d1 * tx1) / n;\r\n        this.ty = -(a1 * this.ty - b1 * tx1) / n;\r\n        return this;\r\n    };\r\n\r\n    invertCopy(){\r\n        let result = new Matrix2D(this);\r\n        return result.invert();\r\n    }\r\n\r\n    isIdentity() {\r\n        return this.tx === 0 && this.ty === 0 && this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1;\r\n    };\r\n\r\n    equals(matrix: Matrix2D) {\r\n        return this.tx === matrix.tx && this.ty === matrix.ty && this.a === matrix.a && this.b === matrix.b && this.c === matrix.c && this.d === matrix.d;\r\n    };\r\n\r\n\r\n    transformPoint(x: number, y: number, pt?: cPoint2D): cPoint2D {\r\n        pt = pt || new cPoint2D();\r\n        pt.x = x * this.a + y * this.c + this.tx;\r\n        pt.y = x * this.b + y * this.d + this.ty;\r\n        return pt;\r\n    };\r\n\r\n    invertPoint(x: number, y: number, pt?: cPoint2D): cPoint2D {\r\n        let inv = this.invertCopy();\r\n        return inv.transformPoint(x, y, pt);\r\n    };\r\n\r\n    decompose(target) {\r\n        // TODO: it would be nice to be able to solve for whether the matrix can be decomposed into only scale/rotation even when scale is negative\r\n        if (target == null) { target = {}; }\r\n        target.x = this.tx;\r\n        target.y = this.ty;\r\n        target.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);\r\n        target.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);\r\n\r\n        var skewX = Math.atan2(-this.c, this.d);\r\n        var skewY = Math.atan2(this.b, this.a);\r\n\r\n        var delta = Math.abs(1 - skewX / skewY);\r\n        if (delta < 0.00001) { // effectively identical, can use rotation:\r\n            target.rotation = skewY / Matrix2D.DEG_TO_RAD;\r\n            if (this.a < 0 && this.d >= 0) {\r\n                target.rotation += (target.rotation <= 0) ? 180 : -180;\r\n            }\r\n            target.skewX = target.skewY = 0;\r\n        } else {\r\n            target.skewX = skewX / Matrix2D.DEG_TO_RAD;\r\n            target.skewY = skewY / Matrix2D.DEG_TO_RAD;\r\n        }\r\n        return target;\r\n    };\r\n\r\n    copy(matrix: Matrix2D) {\r\n        this.a = matrix.a;\r\n        this.b = matrix.b;\r\n        this.c = matrix.c;\r\n        this.d = matrix.d;\r\n        this.tx = matrix.tx;\r\n        this.ty = matrix.ty;\r\n        return this;\r\n    };\r\n\r\n    clone() {\r\n        let matrix = new Matrix2D(this);\r\n        return matrix\r\n\r\n    };\r\n\r\n    toString() {\r\n        return \"[Matrix2D (a=\" + this.a + \" b=\" + this.b + \" c=\" + this.c + \" d=\" + this.d + \" tx=\" + this.tx + \" ty=\" + this.ty + \")]\";\r\n    };\r\n}\r\n\r\nexport let Identity: Matrix2D = new Matrix2D();","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foGeometry2D.ts",["81","82"],"\r\nimport { iPoint2D, iRect, iBox, iMargin, iFrame } from './foInterface';\r\nimport { Vector2, Matrix3 } from 'three';\r\nexport { Vector2, Matrix3 } from 'three';\r\n\r\nexport class cPoint2D extends Vector2 implements iPoint2D {\r\n\r\n    public myName: string;\r\n    public x: number;\r\n    public y: number;\r\n\r\n    constructor(x: number = 0, y: number = 0, name?: string) {\r\n        super(x, y);\r\n        this.myName = name;\r\n    }\r\n\r\n    asVector(): Vector2 {\r\n        return new Vector2(this.x, this.y);\r\n    }\r\n\r\n    setValues(x: number = 0, y: number = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    clonePoint(): cPoint2D {\r\n        return new cPoint2D(this.x, this.y, this.myName);\r\n    }\r\n\r\n    isEqualTo(p: cPoint2D): boolean {\r\n        return this.x === p.x && this.y === p.y;\r\n    }\r\n\r\n    isNear(p: cPoint2D, radius: number): boolean {\r\n        const dx = Math.abs(p.x - this.x);\r\n        if (dx > radius) { return false; }\r\n\r\n        const dy = Math.abs(p.y - this.y);\r\n        if (dy > radius) { return false; }\r\n        return true;\r\n\r\n    }\r\n\r\n    addPoint(x: number = 0, y: number = 0): cPoint2D {\r\n        this.x += x;\r\n        this.y += y;\r\n        return this;\r\n    }\r\n\r\n\r\n\r\n    subtractPoint(x: number = 0, y: number = 0): cPoint2D {\r\n        this.x -= x;\r\n        this.y -= y;\r\n        return this;\r\n    }\r\n\r\n    midPoint(pt: cPoint2D): cPoint2D {\r\n        const x = (this.x + pt.x) / 2;\r\n        const y = (this.y + pt.y) / 2;\r\n        return new cPoint2D(x, y, 'midpoint');\r\n    }\r\n\r\n    mag(): number {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y);\r\n    }\r\n\r\n    atan(): number {\r\n        return Math.atan2(this.y,  this.x);\r\n    }\r\n\r\n    normal(): cPoint2D {\r\n        let mag = this.mag();\r\n        mag = mag ? mag : 1.0; //if zero set to 1 you get the same result\r\n        return new cPoint2D(this.x / mag, this.y / mag, 'normal');\r\n    }\r\n\r\n    sum(p: cPoint2D): cPoint2D {\r\n        this.x += p.x;\r\n        this.y += p.y;\r\n        return this;\r\n    }\r\n\r\n    sumTo(p: cPoint2D): cPoint2D {\r\n        p.x += this.x;\r\n        p.y += this.y;\r\n        return p;\r\n    }\r\n\r\n    setTo(p: cPoint2D): cPoint2D {\r\n        p.x = this.x;\r\n        p.y = this.y;\r\n        return p;\r\n    }\r\n\r\n    subtract(p: cPoint2D): cPoint2D {\r\n        this.x -= p.x;\r\n        this.y -= p.y;\r\n        return this;\r\n    }\r\n\r\n    deltaBetween(pt: cPoint2D): cPoint2D {\r\n        const x = this.x - pt.x;\r\n        const y = this.y - pt.y;\r\n        return new cPoint2D(x, y, 'delta');\r\n    }\r\n\r\n    scale(s: number): cPoint2D {\r\n        this.x *= s;\r\n        this.y *= s;\r\n        return this;\r\n    }\r\n}\r\n\r\nexport class cRect implements iRect {\r\n    public x: number;\r\n    public y: number;\r\n    public width: number;\r\n    public height: number;\r\n    public myName: string;\r\n\r\n    constructor(x: number, y: number, width: number, height: number, name?: string) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.myName = name;\r\n    }\r\n\r\n    moveBy(x: number = 0, y: number = 0): iRect {\r\n        this.x += x;\r\n        this.y += y;\r\n        return this;\r\n    }\r\n\r\n    moveTo(x: number = 0, y: number = 0): iRect {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    sizeBy(width: number, height: number): iRect {\r\n        this.width += width;\r\n        this.height += height;\r\n        return this;\r\n    }\r\n\r\n    sizeTo(width: number, height: number): iRect {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    set(x: number, y: number, width: number, height: number): iRect {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    contains(x: number, y: number) {\r\n        return this.x <= x && x <= this.x + this.width && this.y <= y && y <= this.y + this.height;\r\n    }\r\n\r\n    localContains(x: number, y: number): boolean {\r\n        return 0 <= x && x <= this.width && 0 <= y && y <= this.height;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, fill?: boolean) {\r\n        if (fill) {\r\n            ctx.fillRect(this.x, this.y, this.width, this.height);\r\n        } else {\r\n            ctx.rect(this.x, this.y, this.width, this.height);\r\n        }\r\n        return this;\r\n    }\r\n}\r\n\r\n\r\nexport class cFrame implements iFrame {\r\n    public x1: number;\r\n    public y1: number;\r\n    public x2: number;\r\n    public y2: number;\r\n\r\n    public point: cPoint2D = new cPoint2D();\r\n    public source: any;\r\n\r\n    constructor(source?: any) {\r\n        this.source = source;\r\n    }\r\n\r\n    set(x1: number, y1: number, x2: number, y2: number): iFrame {\r\n        this.x1 = x1;\r\n        this.y1 = y1;\r\n        this.x2 = x2;\r\n        this.y2 = y2;\r\n        return this;\r\n    }\r\n\r\n    width(): number {\r\n        return this.x2 - this.x1;\r\n    }\r\n\r\n    heigth(): number {\r\n        return this.y2 - this.y1;\r\n    }\r\n\r\n    centerX(): number {\r\n        return (this.x2 + this.x1) / 2.0;\r\n    }\r\n\r\n    centerY(): number {\r\n        return (this.y2 + this.y1) / 2.0;\r\n    }\r\n\r\n    init(obj: iPoint2D): iFrame {\r\n        this.x1 = obj.x;\r\n        this.y1 = obj.y;\r\n        this.x2 = obj.x;\r\n        this.y2 = obj.y;\r\n        return this;\r\n    }\r\n\r\n    merge(obj: iFrame): iFrame {\r\n        this.x1 = Math.min(this.x1, obj.x1, obj.x2);\r\n        this.y1 = Math.min(this.y1, obj.y1, obj.y2);\r\n        this.x2 = Math.max(this.x2, obj.x2, obj.x1);\r\n        this.y2 = Math.max(this.y2, obj.y2, obj.y1);\r\n        return this;\r\n    }\r\n\r\n    minmax(obj: iPoint2D): iFrame {\r\n        this.x1 = Math.min(this.x1, obj.x);\r\n        this.y1 = Math.min(this.y1, obj.y);\r\n        this.x2 = Math.max(this.x2, obj.x);\r\n        this.y2 = Math.max(this.y2, obj.y);\r\n        return this;\r\n    }\r\n\r\n    contains(x: number, y: number) {\r\n        return this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, fill?: boolean) {\r\n        const width = this.x2 - this.x1;\r\n        const height = this.y2 - this.y1;\r\n        if (fill) {\r\n            ctx.fillRect(this.x1, this.y1, width, height);\r\n        } else {\r\n            ctx.rect(this.x1, this.y1, width, height);\r\n        }\r\n        return this;\r\n    }\r\n}\r\n\r\nexport class cMargin implements iMargin {\r\n    public left: number = 0;\r\n    public top: number = 0;\r\n    public right: number = 0;\r\n    public bottom: number = 0;\r\n\r\n\r\n    constructor(left: number = 0, top: number = 0, right: number = 0, bottom: number = 0) {\r\n        this.left = left;\r\n        this.top = top;\r\n        this.right = right;\r\n        this.bottom = bottom;\r\n    }\r\n\r\n    setAll(size: number = 0) {\r\n        this.left = size;\r\n        this.top = size;\r\n        this.right = size;\r\n        this.bottom = size;\r\n        return this;\r\n    }\r\n\r\n    get width() {\r\n        return this.left + this.right;\r\n    }\r\n    get height() {\r\n        return this.top + this.bottom;\r\n    }\r\n}\r\n\r\nexport class cBox extends cRect implements iBox {\r\n\r\n    constructor(x: number, y: number, width: number, height: number, name?: string) {\r\n        super(x, y, width, height, name);\r\n    }\r\n\r\n    pinX(): number {\r\n        return 0 * this.width;\r\n    }\r\n\r\n    pinY(): number {\r\n        return 0 * this.height;\r\n    }\r\n\r\n\r\n    draw(ctx: CanvasRenderingContext2D, fill?: boolean) {\r\n        if (fill) {\r\n            ctx.fillRect(this.x, this.y, this.width, this.height);\r\n        } else {\r\n            ctx.rect(this.x, this.y, this.width, this.height);\r\n        }\r\n        return this;\r\n    }\r\n}\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foShape2D.model.ts",["83","84"],"import { Tools } from './foTools';\r\nimport { cPoint2D } from './foGeometry2D';\r\nimport { Vector2, Vector3 } from 'three';\r\nimport { iPoint2D, iFrame } from './foInterface';\r\n\r\nimport { foObject } from './foObject.model';\r\nimport { Matrix2D } from './foMatrix2D';\r\n\r\nimport { foGlyph2D } from './foGlyph2D.model';\r\n\r\nimport { Lifecycle } from './foLifecycle';\r\n\r\nexport enum shape2DNames {\r\n  left = 'left',\r\n  right = 'right',\r\n  top = 'top',\r\n  bottom = 'bottom',\r\n  center = 'center'\r\n}\r\n\r\n//a Shape is a graphic designed to behave like a visio shape\r\n//and have all the same properties\r\nexport class foShape2D extends foGlyph2D {\r\n  protected _angle: number;\r\n  get angle(): number {\r\n    return this._angle || 0.0;\r\n  }\r\n  set angle(value: number) {\r\n    this.smash();\r\n    this._angle = value;\r\n  }\r\n\r\n\r\n\r\n  public pinX = (): number => 0.5 * this.width;\r\n  public pinY = (): number => 0.5 * this.height;\r\n  public rotationZ = (): number => this.angle;\r\n\r\n  public setPinLeft() {\r\n    this.pinX = (): number => 0.0 * this.width;\r\n    return this;\r\n  }\r\n  public setPinRight() {\r\n    this.pinX = (): number => 1.0 * this.width;\r\n    return this;\r\n  }\r\n  public setPinCenter() {\r\n    this.pinX = (): number => 0.5 * this.width;\r\n    return this;\r\n  }\r\n\r\n  public setPinTop() {\r\n    this.pinY = (): number => 0.0 * this.height;\r\n    return this;\r\n  }\r\n  public setPinMiddle() {\r\n    this.pinY = (): number => 0.5 * this.height;\r\n    return this;\r\n  }\r\n  public setPinBottom() {\r\n    this.pinY = (): number => 1.0 * this.height;\r\n    return this;\r\n  }\r\n\r\n  pinVector(): Vector3 {\r\n    return new Vector3(this.pinX(), this.pinY(), 0);\r\n  }\r\n\r\n  protected originPosition(): Vector3 {\r\n    const pin = this.pinVector();\r\n    return new Vector3(this.x - pin.x, this.y - pin.y, 0);\r\n  }\r\n\r\n  public pinLocation() {\r\n    return {\r\n      x: this.pinX(),\r\n      y: this.pinY(),\r\n      z: 0\r\n    };\r\n  }\r\n\r\n  constructor(\r\n    properties?: any,\r\n    parent?: foObject\r\n  ) {\r\n    super(properties, parent);\r\n    this.override(properties);\r\n  }\r\n\r\n  protected toJson(): any {\r\n    return Tools.mixin(super.toJson(), {\r\n      angle: this.angle\r\n      // glue: this._glue && Tools.asArray(this.glue.asJson)\r\n    });\r\n  }\r\n\r\n  public didLocationChange(\r\n    x: number = Number.NaN,\r\n    y: number = Number.NaN,\r\n    angle: number = Number.NaN\r\n  ): boolean {\r\n    let changed = super.didLocationChange(x, y, angle);\r\n    if (!Number.isNaN(angle) && this.angle !== angle) {\r\n      changed = true;\r\n      this.angle = angle;\r\n    }\r\n    return changed;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  public move(\r\n    x: number = Number.NaN,\r\n    y: number = Number.NaN,\r\n    angle: number = Number.NaN\r\n  ) {\r\n    if (this.didLocationChange(x, y, angle)) {\r\n      const point = this.getLocation();\r\n\r\n      Lifecycle.moved(this, point);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  updateContext(ctx: CanvasRenderingContext2D) {\r\n    const mtx = this.getMatrix();\r\n    ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\r\n    ctx.globalAlpha *= this.opacity;\r\n  }\r\n\r\n  getMatrix() {\r\n    if (this._matrix === undefined) {\r\n      this._matrix = new Matrix2D();\r\n      this._matrix.appendTransform(\r\n        this.x,\r\n        this.y,\r\n        1,\r\n        1,\r\n        this.rotationZ(),\r\n        0,\r\n        0,\r\n        this.pinX(),\r\n        this.pinY()\r\n      );\r\n    }\r\n    return this._matrix;\r\n  }\r\n\r\n  protected localHitTest = (hit: any): boolean => {\r\n    const { x, y } = hit as iPoint2D;\r\n    const loc = this.globalToLocal(x, y);\r\n\r\n    if (loc.x < 0) return false;\r\n    if (loc.x > this.width) return false;\r\n\r\n    if (loc.y < 0) return false;\r\n    if (loc.y > this.height) return false;\r\n\r\n    return true;\r\n  }\r\n\r\n  public hitTest = (hit: any): boolean => {\r\n    return this.isHitable && this.isVisible && this.localHitTest(hit);\r\n  }\r\n\r\n  public overlapTest = (hit: iFrame): boolean => {\r\n    const frame = this.globalToLocalFrame(hit.x1, hit.y1, hit.x2, hit.y2);\r\n\r\n    if (this.localContains(frame.x1, frame.y1)) return true;\r\n    if (this.localContains(frame.x1, frame.y2)) return true;\r\n    if (this.localContains(frame.x2, frame.y1)) return true;\r\n    if (this.localContains(frame.x2, frame.y2)) return true;\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n  public render(ctx: CanvasRenderingContext2D, deep: boolean = true) {\r\n    if (this.isInvisible) return;\r\n    ctx.save();\r\n\r\n    //this.drawOrigin(ctx);\r\n    this.updateContext(ctx);\r\n    //this.drawOriginX(ctx);\r\n\r\n    this.preDraw && this.preDraw(ctx);\r\n    this.draw(ctx);\r\n    this.drawHover && this.drawHover(ctx);\r\n    this.postDraw && this.postDraw(ctx);\r\n\r\n    this.isSelected && this.drawSelected(ctx);\r\n\r\n    // deep &&\r\n    //   this._subcomponents.forEach(item => {\r\n    //     item.render(ctx, deep);\r\n    //   });\r\n    ctx.restore();\r\n  }\r\n\r\n  public drawOutline(ctx: CanvasRenderingContext2D) {\r\n    ctx.beginPath();\r\n    ctx.setLineDash([15, 5]);\r\n    ctx.rect(0, 0, this.width, this.height);\r\n    ctx.stroke();\r\n  }\r\n\r\n  public drawSelected = (ctx: CanvasRenderingContext2D): void => {\r\n    ctx.strokeStyle = 'red';\r\n    ctx.lineWidth = 4;\r\n    this.drawOutline(ctx);\r\n\r\n    this.drawPin(ctx);\r\n  }\r\n\r\n  public drawBackground = (ctx: CanvasRenderingContext2D): void => {\r\n    ctx.fillStyle = this.color;\r\n    ctx.lineWidth = 1;\r\n    ctx.globalAlpha = this.opacity;\r\n    ctx.fillRect(0, 0, this.width, this.height);\r\n  }\r\n\r\n  public draw = (ctx: CanvasRenderingContext2D): void => {\r\n    this.drawBackground(ctx);\r\n  }\r\n}\r\n\r\n",{"ruleId":"85","replacedBy":"86"},{"ruleId":"87","replacedBy":"88"},{"ruleId":"89","severity":1,"message":"90","line":2,"column":10,"nodeType":"91","messageId":"92","endLine":2,"endColumn":18},{"ruleId":"89","severity":1,"message":"93","line":2,"column":20,"nodeType":"91","messageId":"92","endLine":2,"endColumn":26},{"ruleId":"89","severity":1,"message":"94","line":3,"column":10,"nodeType":"91","messageId":"92","endLine":3,"endColumn":18},{"ruleId":"89","severity":1,"message":"95","line":3,"column":20,"nodeType":"91","messageId":"92","endLine":3,"endColumn":26},{"ruleId":"89","severity":1,"message":"96","line":7,"column":10,"nodeType":"91","messageId":"92","endLine":7,"endColumn":21},{"ruleId":"89","severity":1,"message":"97","line":9,"column":10,"nodeType":"91","messageId":"92","endLine":9,"endColumn":18},{"ruleId":"89","severity":1,"message":"98","line":5,"column":10,"nodeType":"91","messageId":"92","endLine":5,"endColumn":16},{"ruleId":"99","severity":1,"message":"100","line":284,"column":37,"nodeType":"101","messageId":"102","endLine":284,"endColumn":63},{"ruleId":"103","severity":1,"message":"104","line":25,"column":3,"nodeType":"105","messageId":"106","endLine":25,"endColumn":19},{"ruleId":"89","severity":1,"message":"107","line":7,"column":24,"nodeType":"91","messageId":"92","endLine":7,"endColumn":30},{"ruleId":"85","replacedBy":"108"},{"ruleId":"87","replacedBy":"109"},{"ruleId":"110","severity":1,"message":"111","line":46,"column":15,"nodeType":"112","messageId":"113","endLine":46,"endColumn":17},{"ruleId":"110","severity":1,"message":"111","line":46,"column":25,"nodeType":"112","messageId":"113","endLine":46,"endColumn":27},{"ruleId":"110","severity":1,"message":"111","line":46,"column":35,"nodeType":"112","messageId":"113","endLine":46,"endColumn":37},{"ruleId":"110","severity":1,"message":"111","line":46,"column":45,"nodeType":"112","messageId":"113","endLine":46,"endColumn":47},{"ruleId":"89","severity":1,"message":"114","line":3,"column":19,"nodeType":"91","messageId":"92","endLine":3,"endColumn":26},{"ruleId":"103","severity":1,"message":"104","line":291,"column":5,"nodeType":"105","messageId":"106","endLine":293,"endColumn":6},{"ruleId":"89","severity":1,"message":"90","line":2,"column":10,"nodeType":"91","messageId":"92","endLine":2,"endColumn":18},{"ruleId":"89","severity":1,"message":"115","line":3,"column":10,"nodeType":"91","messageId":"92","endLine":3,"endColumn":17},"no-native-reassign",["116"],"no-negated-in-lhs",["117"],"@typescript-eslint/no-unused-vars","'cPoint2D' is defined but never used.","Identifier","unusedVar","'cFrame' is defined but never used.","'iPoint2D' is defined but never used.","'Action' is defined but never used.","'WhereClause' is defined but never used.","'Matrix2D' is defined but never used.","'iShape' is defined but never used.","@typescript-eslint/consistent-type-assertions","Use 'as foGlyph2D' instead of '<foGlyph2D>'.","TSTypeAssertion","as","@typescript-eslint/no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","'filter' is defined but never used.",["116"],["117"],"eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","'Matrix3' is defined but never used.","'Vector2' is defined but never used.","no-global-assign","no-unsafe-negation"]