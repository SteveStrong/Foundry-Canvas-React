[{"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\App.tsx":"1","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\Canvas.tsx":"2","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\CanvasHook.ts":"3","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\index.tsx":"4","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\core\\foRenderer.tsx":"5","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foObject.model.ts":"6","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foTools.ts":"7","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foInterface.ts":"8","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foCollection.model.ts":"9","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foLifecycle.ts":"10","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foController.ts":"11","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foPubSub.ts":"12","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foChange.ts":"13"},{"size":1486,"mtime":1607313411078,"results":"14","hashOfConfig":"15"},{"size":517,"mtime":1607302617322,"results":"16","hashOfConfig":"15"},{"size":1070,"mtime":1607313543478,"results":"17","hashOfConfig":"15"},{"size":200,"mtime":1607284035886,"results":"18","hashOfConfig":"15"},{"size":1640,"mtime":1607313595907,"results":"19","hashOfConfig":"15"},{"size":10110,"mtime":1607313060588,"results":"20","hashOfConfig":"15"},{"size":14080,"mtime":1607303146208,"results":"21","hashOfConfig":"15"},{"size":3902,"mtime":1607303144915,"results":"22","hashOfConfig":"15"},{"size":3191,"mtime":1607303143876,"results":"23","hashOfConfig":"15"},{"size":6154,"mtime":1607303145117,"results":"24","hashOfConfig":"15"},{"size":1568,"mtime":1607303144183,"results":"25","hashOfConfig":"15"},{"size":815,"mtime":1607303145812,"results":"26","hashOfConfig":"15"},{"size":3128,"mtime":1607303143835,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"1x4sejr",{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"41","messages":"42","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"44"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"44"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"44"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"44"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"44"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\App.tsx",[],["61","62"],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\Canvas.tsx",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\CanvasHook.ts",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\index.tsx",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\core\\foRenderer.tsx",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foObject.model.ts",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foTools.ts",["63"],"export enum foNames {\r\n  UNKNOWN = 'unknown',\r\n  AT = '@',\r\n  THIS = 'this',\r\n  SELF = 'self',\r\n  ROOT = 'root'\r\n}\r\n\r\n// Converts numeric degrees to radians\r\n// if (typeof (Number.prototype.toRad) === \"undefined\") {\r\n//     Number.prototype.toRad = function () {\r\n//         return this * Math.PI / 180;\r\n//     }\r\n// }\r\n// if (typeof (Number.prototype.toDeg) === \"undefined\") {\r\n//     Number.prototype.toDeg = function () {\r\n//         return this * 180 / Math.PI;\r\n//     }\r\n// }\r\n\r\nexport class foTools {\r\n  // Speed up calls to hasOwnProperty\r\n  private hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\n  constructor() {}\r\n\r\n  /**\r\n   * http://stackoverflow.com/questions/6588977/how-to-to-extract-a-javascript-function-from-a-javascript-file\r\n   * @param funct\r\n   */\r\n  getFunctionName(funct) {\r\n    let ret = funct.toString(); //do with regx\r\n    ret = ret.substr('function '.length);\r\n    ret = ret.substr(0, ret.indexOf('('));\r\n    return ret.trim();\r\n  }\r\n\r\n  //http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\r\n  generateUUID() {\r\n    let d = new Date().getTime();\r\n    const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(\r\n      /[xy]/g,\r\n      function(c) {\r\n        // tslint:disable-next-line:no-bitwise\r\n        const r = ((d + Math.random() * 16) % 16) | 0;\r\n        d = Math.floor(d / 16);\r\n        // tslint:disable-next-line:no-bitwise\r\n        return (c === 'x' ? r : (r & 0x7) | 0x8).toString(16);\r\n      }\r\n    );\r\n    return uuid;\r\n  }\r\n\r\n  asJson(target: any) {\r\n    const result = this.stringify(target);\r\n    return JSON.parse(result);\r\n  }\r\n\r\n  stringify(target: any, func = undefined, deep = 3) {\r\n    function resolveReference(value) {\r\n      if (value && value.asReference) {\r\n        return (\r\n          'resolveRef(' +\r\n          value.asReference() +\r\n          ',' +\r\n          value.constructor.name +\r\n          ')'\r\n        );\r\n      }\r\n      return value;\r\n    }\r\n    function resolveCircular(key, value) {\r\n      switch (key) {\r\n        case 'myParent':\r\n          return resolveReference(value);\r\n        case 'myMembers':\r\n          return value\r\n            ? value.map(function(item) {\r\n                return resolveReference(item);\r\n              })\r\n            : value;\r\n        case '_lookup':\r\n          return value;\r\n        case '_members':\r\n          return value;\r\n      }\r\n      if (key.startsWith('_')) {\r\n        return;\r\n      }\r\n      //if (this.isCustomLinkName(key)) {\r\n      //    return resolveReference(value);\r\n      //}\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(target, resolveCircular, deep);\r\n  }\r\n\r\n  splitNamespaceType(id: string, primitive?: string) {\r\n    const typeId = id.split('::');\r\n    let result = { namespace: '', name: id };\r\n    if (typeId.length === 2) {\r\n      result = {\r\n        namespace: typeId[0],\r\n        name: typeId[1]\r\n      };\r\n    } else if (primitive) {\r\n      result = {\r\n        namespace: typeId[0],\r\n        name: primitive\r\n      };\r\n    }\r\n    return result;\r\n  }\r\n\r\n  getNamespace(obj) {\r\n    let myNamespace = obj.myType ? obj.myType.split('::') : [''];\r\n    myNamespace = myNamespace[0];\r\n    return myNamespace;\r\n  }\r\n\r\n  getType(obj): string {\r\n    let myType = obj.myType ? obj.myType.split('::') : [''];\r\n    myType = myType.length === 2 ? myType[1] : myType[0];\r\n    return myType;\r\n  }\r\n\r\n  namespace(namespace: string, name: string) {\r\n    return `${namespace}::${name}`;\r\n  }\r\n\r\n  randomInt(low: number, high: number) {\r\n    return low + Math.floor(Math.random() * (high - low + 1));\r\n  }\r\n\r\n  random(low: number, high: number) {\r\n    return low + Math.random() * (high - low);\r\n  }\r\n\r\n  randomRGBColor() {\r\n    // tslint:disable-next-line:no-bitwise\r\n    const r = (255 * Math.random()) | 0;\r\n      // tslint:disable-next-line:no-bitwise\r\n    const g = (255 * Math.random()) | 0;\r\n      // tslint:disable-next-line:no-bitwise\r\n    const b = (255 * Math.random()) | 0;\r\n    return `rgb(${r},${g},${b})`;\r\n  }\r\n\r\n  matches(str1: string, str2: string) {\r\n    if (str1 === str2) {\r\n      return true;\r\n    }\r\n    return (\r\n      str1 && str2 && str1.toLocaleLowerCase() === str2.toLocaleLowerCase()\r\n    );\r\n  }\r\n\r\n  startsWith(str1: string, str2: string) {\r\n    if (str1 === str2) {\r\n      return true;\r\n    }\r\n    return (\r\n      str1 && str2 && str1.toLocaleLowerCase().startsWith(str2.toLocaleLowerCase())\r\n    );\r\n  }\r\n\r\n  capitalizeFirstLetter(str1: string) {\r\n    return str1.charAt(0).toUpperCase() + str1.slice(1);\r\n  }\r\n\r\n  isSelf(ref) {\r\n    return (\r\n      this.matches(ref, foNames.AT) ||\r\n      this.matches(ref, foNames.THIS) ||\r\n      this.matches(ref, foNames.SELF)\r\n    );\r\n  }\r\n\r\n  isArray(obj) {\r\n    if (Array.isArray) {\r\n      return Array.isArray(obj);\r\n    }\r\n    return Object.prototype.toString.call(obj) === '[object Array]'\r\n      ? true\r\n      : false;\r\n  }\r\n\r\n  isFunction(obj) {\r\n    return typeof obj === 'function';\r\n  }\r\n\r\n  isString(obj) {\r\n    return typeof obj === 'string';\r\n  }\r\n\r\n  isNumber(obj) {\r\n    return typeof obj === 'number';\r\n  }\r\n\r\n  isDate(obj) {\r\n    return obj instanceof Date;\r\n  }\r\n\r\n  isObject(obj) {\r\n    return obj && typeof obj === 'object'; //prevents typeOf null === 'object'\r\n  }\r\n\r\n  isCustomLinkName(key) {\r\n    return false;\r\n  }\r\n\r\n  isTyped(obj) {\r\n    return obj && obj.isInstanceOf;\r\n  }\r\n\r\n  isEmpty(obj) {\r\n    // null and undefined are \"empty\"\r\n    if (obj == null) {\r\n      return true;\r\n    }\r\n\r\n    // Assume if it has a length property with a non-zero value\r\n    // that that property is correct.\r\n    if (obj.length > 0) {\r\n      return false;\r\n    }\r\n    if (obj.length === 0) {\r\n      return true;\r\n    }\r\n\r\n    // If it isn't an object at this point\r\n    // it is empty, but it can't be anything *but* empty\r\n    // Is it empty?  Depends on your application.\r\n    if (typeof obj !== 'object') {\r\n      return true;\r\n    }\r\n\r\n    // Otherwise, does it have any properties of its own?\r\n    // Note that this doesn't handle\r\n    // toString and valueOf enumeration bugs in IE < 9\r\n    // tslint:disable-next-line:prefer-const\r\n    for (let key in obj) {\r\n      if (this.hasOwnProperty.call(obj, key)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  removeDQ(str: string): string {\r\n    return str.replace(/^\"(.*)\"$/, '$1');\r\n  }\r\n\r\n  unwrap(str: string): string {\r\n    return str.substring(1, str.length - 1);\r\n  }\r\n\r\n  wrapDQ(str: string): string {\r\n    return `\"${str}\"`;\r\n  }\r\n\r\n  wrapSQ(str: string): string {\r\n    return `'${str}'`;\r\n  }\r\n\r\n  decomposeHostPath(filename) {\r\n    let string = filename.toLowerCase();\r\n    string = string.replace('http://', '');\r\n    string = string.replace('https://', '');\r\n\r\n    const host = string.split('/')[0];\r\n    const path = string.replace(host, '');\r\n    return {\r\n      fullpath: filename,\r\n      host: host,\r\n      path: path\r\n    };\r\n  }\r\n\r\n  extend(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n    // tslint:disable-next-line:prefer-const\r\n    for (let key in source) {\r\n      if (this.hasOwnProperty.call(source, key)) {\r\n        target[key] = source[key];\r\n      }\r\n    }\r\n    return target;\r\n  }\r\n\r\n  mixin(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n    if (!target) {\r\n      return source;\r\n    }\r\n\r\n    for (const key of source) {\r\n      target[key] = source[key];\r\n    }\r\n    return target;\r\n  }\r\n\r\n  mixExact(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n    if (!target) {\r\n      return source;\r\n    }\r\n    for (const key in source) {\r\n      if (foTools.hasOwnProperty.call(target, key)) {\r\n        target[key] = source[key];\r\n      }\r\n    }\r\n    return target;\r\n  }\r\n\r\n  mixout(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n    if (!target) {\r\n      return source;\r\n    }\r\n    for (const key in source) {\r\n      if (this.hasOwnProperty.call(target, key)) {\r\n        delete target[key];\r\n      }\r\n    }\r\n    return target;\r\n  }\r\n\r\n  extract(target, keys?: string[]) {\r\n    const spec = {};\r\n    keys &&\r\n      keys.forEach(key => {\r\n        spec[key] = target[key];\r\n      });\r\n    return spec;\r\n  }\r\n\r\n  mixMap(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n\r\n    let result = {};\r\n    for (let key in target) {\r\n      const keyMap = source[key] || key;\r\n      result[keyMap] = target[key];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  intersect(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n    if (!target) {\r\n      return source;\r\n    }\r\n    const intersect = {};\r\n    for (const key in target) {\r\n      if (this.hasOwnProperty.call(source, key)) {\r\n        intersect[key] = source[key];\r\n      } else {\r\n        intersect[key] = target[key];\r\n      }\r\n    }\r\n    return intersect;\r\n  }\r\n\r\n  union(target, source) {\r\n    const result = {};\r\n    if (target) {\r\n      for (let key in target) {\r\n        result[key] = target[key];\r\n      }\r\n    }\r\n    if (source) {\r\n      for (let key in source) {\r\n        result[key] = source[key];\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  defineComputeOnlyProperty(target, name, func) {\r\n    //var self = target;\r\n    Object.defineProperty(target, name, {\r\n      enumerable: true,\r\n      configurable: true,\r\n      get: func\r\n    });\r\n    return target;\r\n  }\r\n\r\n  defineCalculatedProperty(target, name, func) {\r\n    //var self = target;\r\n    Object.defineProperty(target, name, {\r\n      enumerable: true,\r\n      configurable: true,\r\n      get: func, //.call(self, self),\r\n      set: function(value) {\r\n        this[`_${name}`] = value;\r\n      }\r\n    });\r\n    return target;\r\n  }\r\n\r\n  getMethods(obj) {\r\n    const list = [];\r\n    for (const m in obj.prototype) {\r\n      if (typeof obj[m] === 'function') {\r\n        list.push(m);\r\n      }\r\n    }\r\n    return list;\r\n  }\r\n\r\n  asArray(obj, funct?) {\r\n    if (this.isArray(obj)) {\r\n      return obj;\r\n    }\r\n    return this.mapOverKeyValue(obj, function(key, value) {\r\n      return funct ? funct(key, value) : value;\r\n    });\r\n  }\r\n\r\n  applyOverKeyValue(obj, mapFunc) {\r\n    //funct has 2 args.. key,value\r\n    const body = {};\r\n    const keys = obj ? Object.keys(obj) : [];\r\n    keys.forEach(key => {\r\n      if (this.hasOwnProperty.call(obj, key)) {\r\n        const value = obj[key];\r\n        const result = mapFunc(key, value);\r\n        if (result) {\r\n          body[key] = result;\r\n        }\r\n      }\r\n    });\r\n    return body;\r\n  }\r\n\r\n  mapOverKeyValue(obj, mapFunc) {\r\n    //funct has 2 args.. key,value\r\n    const list = [];\r\n    const keys = obj ? Object.keys(obj) : [];\r\n    keys.forEach(key => {\r\n      if (this.hasOwnProperty.call(obj, key)) {\r\n        const value = obj[key];\r\n        const result = mapFunc(key, value);\r\n        if (result) {\r\n          list.push(result);\r\n        }\r\n      }\r\n    });\r\n    return list;\r\n  }\r\n\r\n  forEachKeyValue(obj, mapFunc) {\r\n    //funct has 2 args.. key,value\r\n    const keys = obj ? Object.keys(obj) : [];\r\n    keys.forEach(key => {\r\n      if (this.hasOwnProperty.call(obj, key)) {\r\n        const value = obj[key];\r\n        mapFunc(key, value);\r\n      }\r\n    });\r\n  }\r\n\r\n  findKeyForValue(obj, key) {\r\n    for (const name in obj) {\r\n      if (this.hasOwnProperty.call(obj, key)) {\r\n        if (obj[name].matches(key)) {\r\n          return name;\r\n        }\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n\r\n  extractReadWriteKeys(spec) {\r\n    const keys: string[] = [];\r\n    Tools.forEachKeyValue(spec, (k, v) => {\r\n      if (!Tools.isFunction(v)) {\r\n        keys.push(k);\r\n      }\r\n    });\r\n    return keys;\r\n  }\r\n\r\n  extractComputedKeys(spec) {\r\n    const keys: string[] = [];\r\n    Tools.forEachKeyValue(spec, (k, v) => {\r\n      if (Tools.isFunction(v)) {\r\n        keys.push(k);\r\n      }\r\n    });\r\n    return keys;\r\n  }\r\n\r\n  overrideComputed(obj: any, properties: any) {\r\n    Tools.forEachKeyValue(properties, function(key, value) {\r\n      try {\r\n        if (Tools.isFunction(value)) {\r\n          Tools.defineCalculatedProperty(obj, key, value);\r\n        } else {\r\n          obj[key] = value;\r\n        }\r\n      } catch (ex) {\r\n        console.log(ex);\r\n      }\r\n    });\r\n  }\r\n\r\n  extendComputed(obj: any, properties: any) {\r\n    Tools.forEachKeyValue(properties, function(key, value) {\r\n      try {\r\n        if (!obj[key]) {\r\n          if (Tools.isFunction(value)) {\r\n            Tools.defineCalculatedProperty(obj, key, value);\r\n          } else {\r\n            obj[key] = value;\r\n          }\r\n        }\r\n      } catch (ex) {\r\n        console.log(ex);\r\n      }\r\n    });\r\n  }\r\n\r\n  pluck(name) {\r\n    return function(x) {\r\n      return x[name];\r\n    };\r\n  }\r\n\r\n  distinctItems(list) {\r\n    const distinct = {};\r\n    list.forEach(item => {\r\n      distinct[item] = item;\r\n    });\r\n    return Object.keys(distinct);\r\n  }\r\n\r\n  groupBy(pluckBy, list) {\r\n    const dictionary = {};\r\n    list.forEach(item => {\r\n      const key = pluckBy(item);\r\n      if (!dictionary[key]) {\r\n        dictionary[key] = [];\r\n      }\r\n      dictionary[key].push(item);\r\n    });\r\n    return dictionary;\r\n  }\r\n\r\n  //add this to new service to dynamicaly load javascript,  maybe over signalR\r\n\r\n  // xmlHttpGet(url:string, onComplete, onFailure) {\r\n  //     let xmlHttp = new window.XMLHttpRequest();\r\n  //     xmlHttp.onload = function () {\r\n  //        let result = xmlHttp.responseText;\r\n  //         onComplete && onComplete(result, xmlHttp);\r\n  //     };\r\n  //     try {\r\n  //         xmlHttp.open(\"GET\", url, false);  //this may give chrome some problems\r\n  //         xmlHttp.send(null);\r\n  //     }\r\n  //     catch (ex) {\r\n  //         onFailure && onFailure(ex, xmlHttp);\r\n  //     }\r\n  // }\r\n  // loadAsScript(url:string, onComplete) {\r\n  //     this.xmlHttpGet(url, function (text, xhr) {\r\n  //         if (xhr.status == 200 || xhr.status == 304) {\r\n  //            let head = document.getElementsByTagName(\"head\")[0];\r\n  //            let script = document.createElement('script');\r\n  //             script.innerHTML = text;\r\n  //             head.appendChild(script);\r\n  //             onComplete && onComplete(script);\r\n  //         }\r\n  //     });\r\n  //}\r\n}\r\n\r\nexport let Tools: foTools = new foTools();\r\n",["64","65"],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foInterface.ts",["66"],"//https://www.typescriptlang.org/docs/handbook/decorators.html\r\n\r\nexport type Action<T> = (item: T) => void;\r\n\r\nexport type ModelRef<T> = () => T;\r\n\r\nexport type Func<T, R> = (item: T) => R;\r\n\r\nexport type WhereClause<T> = (item: T) => boolean;\r\n\r\nexport interface Spec<T> {\r\n  (spec?: any);\r\n}\r\n\r\nexport interface iObject {\r\n  myName: string;\r\n  myParent: ModelRef<iObject>;\r\n  myGuid: string;\r\n  asReference(): string;\r\n  getChildAt(i: number): iObject;\r\n  override(properties?: any);\r\n  hasAncestor(member?: iObject): boolean;\r\n  defaultName(name?: string);\r\n  asJson: string;\r\n  isPublic: boolean;\r\n}\r\n\r\nexport interface iNode {\r\n  addAsSubcomponent(obj: iNode);\r\n  addSubcomponent(obj: iNode);\r\n  removeSubcomponent(obj: iNode);\r\n\r\n  // canCaptureSubcomponent(obj:iNode):boolean;\r\n  // captureSubcomponent(obj:iNode);\r\n}\r\n\r\nexport interface iKnowledge extends iObject {}\r\n\r\n// export interface iConnectionPoint extends iObject {\r\n//     doMoveProxy: (loc: any) => void;\r\n//     hitTest: (hit: iPoint2D) => boolean\r\n//     render(ctx: CanvasRenderingContext2D);\r\n// }\r\n\r\n//FOR GLYPHS and SHAPES\r\nexport interface iName {\r\n  myName: string;\r\n}\r\n\r\nexport interface iPoint2D extends iName {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport interface iPoint3D extends iPoint2D {\r\n  z: number;\r\n}\r\n\r\nexport interface iMargin {\r\n  left: number;\r\n  top: number;\r\n  right: number;\r\n  bottom: number;\r\n}\r\n\r\nexport interface iSize {\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\nexport interface iRect {\r\n  x: number;\r\n  y: number;\r\n  width: number;\r\n  height: number;\r\n  myName: string;\r\n\r\n  set(x: number, y: number, width: number, height: number): iRect;\r\n  contains(x: number, y: number): boolean;\r\n  localContains(x: number, y: number): boolean;\r\n}\r\n\r\nexport interface iFrame {\r\n  x1: number;\r\n  y1: number;\r\n  x2: number;\r\n  y2: number;\r\n\r\n  set(x1: number, y1: number, x2: number, y2: number): iFrame;\r\n  contains(x: number, y: number): boolean;\r\n  merge(obj: iFrame): iFrame;\r\n  minmax(obj: iPoint2D): iFrame;\r\n}\r\n\r\nexport interface iBox extends iRect {\r\n  x: number;\r\n  y: number;\r\n  width: number;\r\n  height: number;\r\n\r\n  pinX(): number;\r\n  pinY(): number;\r\n\r\n  set(x: number, y: number, width: number, height: number): iRect;\r\n}\r\n\r\nexport interface iFence {\r\n  x1: number;\r\n  y1: number;\r\n  z1: number;\r\n  x2: number;\r\n  y2: number;\r\n  z2: number;\r\n\r\n  set(\r\n    x1: number,\r\n    y1: number,\r\n    z1: number,\r\n    x2: number,\r\n    y2: number,\r\n    z2: number\r\n  ): iFence;\r\n  contains(x: number, y: number, z: number): boolean;\r\n  minmax(obj: iPoint3D): iFrame;\r\n}\r\n\r\nexport interface iCube {\r\n  x: number;\r\n  y: number;\r\n  z: number;\r\n  width: number;\r\n  height: number;\r\n  depth: number;\r\n  myName: string;\r\n\r\n  set(\r\n    x: number,\r\n    y: number,\r\n    z: number,\r\n    width: number,\r\n    height: number,\r\n    depth: number\r\n  ): iCube;\r\n  contains(x: number, y: number, z: number): boolean;\r\n  localContains(x: number, y: number, z: number): boolean;\r\n}\r\n\r\nexport interface iGlueSignature {\r\n  sourceGuid: string;\r\n  sourceName: string;\r\n  targetGuid: string;\r\n  targetName: string;\r\n}\r\n\r\nexport interface iShape extends iRect, iNode {\r\n  // isSelected: boolean;\r\n\r\n  render(ctx: CanvasRenderingContext2D, deep: boolean): void;\r\n  draw(ctx: CanvasRenderingContext2D): void;\r\n  drawHover(ctx: CanvasRenderingContext2D): void;\r\n\r\n  hitTest: (hit: iPoint2D) => boolean;\r\n  overlapTest: (hit: iFrame) => boolean;\r\n\r\n  // getOffset(loc: iPoint2D): iPoint2D;\r\n  // getLocation(): any;\r\n  // moveTo(loc: iPoint2D, offset?: iPoint2D);\r\n  // moveBy(loc: iPoint2D, offset?: iPoint2D)\r\n}\r\n\r\nexport interface iSolid extends iCube, iNode {\r\n  isSelected: boolean;\r\n\r\n  hitTest: (hit: iPoint3D) => boolean;\r\n  overlapTest: (hit: iFence) => boolean;\r\n\r\n  // getOffset(loc: iPoint2D): iPoint2D;\r\n  // getLocation(): any;\r\n  // moveTo(loc: iPoint2D, offset?: iPoint2D);\r\n  // moveBy(loc: iPoint2D, offset?: iPoint2D)\r\n}\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foCollection.model.ts",["67"],"import { Tools } from './foTools';\r\nimport { foObject } from './foObject.model';\r\nimport { iObject, Action, Func } from './foInterface';\r\n\r\n//we want foCollection to be observable\r\n\r\nexport class foCollection<T extends iObject> extends foObject {\r\n  protected _members: Array<T>;\r\n\r\n  isHidden: boolean = false;\r\n  isSelectable: boolean = true;\r\n  constructor(list?: Array<T>) {\r\n    super();\r\n\r\n    this._members = new Array<T>();\r\n    list && list.forEach(item => this.addMember(item));\r\n  }\r\n\r\n  getChildAt(i: number): T {\r\n    return this._members[i];\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this._members.length === 0;\r\n  }\r\n\r\n  clearAll() {\r\n    this._members = [];\r\n  }\r\n\r\n  get length() {\r\n    return this._members.length;\r\n  }\r\n\r\n  get count() {\r\n    return this._members.length;\r\n  }\r\n\r\n  get hasMembers(): boolean {\r\n    return this.length > 0;\r\n  }\r\n\r\n  map(funct) {\r\n    return this._members.map(funct);\r\n  }\r\n\r\n  forEach(funct: Action<T>) {\r\n    this._members.forEach(funct);\r\n  }\r\n\r\n  first() {\r\n    return this._members[0];\r\n  }\r\n\r\n  last() {\r\n    return this._members[this._members.length - 1];\r\n  }\r\n\r\n  filter(funct: Func<T, boolean>) {\r\n    return this._members.filter(funct);\r\n  }\r\n\r\n  find(funct: Func<T, boolean>) {\r\n    return this._members.find(funct);\r\n  }\r\n\r\n  findMember(name: string): T {\r\n    const found = this._members.find(item => {\r\n      return item.myName === name || item.myGuid === name;\r\n    });\r\n    return found;\r\n  }\r\n\r\n  getMember(id): T {\r\n    return this._members[id];\r\n  }\r\n\r\n  copyMembers(list: foCollection<T>): foCollection<T> {\r\n    list.members.forEach(item => {\r\n      this.addMember(item);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  isMember(item: T) {\r\n    const loc = this._members.indexOf(item);\r\n    return loc !== -1;\r\n  }\r\n\r\n  push(obj: any) {\r\n    this._members.push(obj);\r\n  }\r\n  shift(): any {\r\n    return this._members.shift();\r\n  }\r\n\r\n  addMember(obj: T): T {\r\n    this._members.push(obj);\r\n    return obj;\r\n  }\r\n\r\n  removeMembers(list: foCollection<T>): foCollection<T> {\r\n    list.members.forEach(item => {\r\n      this.removeMember(item);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  removeMember(obj: T): T {\r\n    const index = this._members.indexOf(obj);\r\n    if (index > -1) {\r\n      this._members.splice(index, 1);\r\n    }\r\n    return obj;\r\n  }\r\n\r\n  get members() {\r\n    return this._members;\r\n  }\r\n\r\n  get publicMembers() {\r\n    return this.members.filter(item => item.isPublic);\r\n  }\r\n\r\n  moveToTop(item: T) {\r\n    const loc = this._members.indexOf(item);\r\n    if (loc !== -1) {\r\n      this._members.splice(loc, 1);\r\n      this._members.push(item);\r\n    }\r\n    return this._members;\r\n  }\r\n\r\n  moveToBottom(item: T) {\r\n    const loc = this._members.indexOf(item);\r\n    if (loc !== -1) {\r\n      this._members.splice(loc, 1);\r\n      this._members.unshift(item);\r\n    }\r\n    return this._members;\r\n  }\r\n\r\n  protected toJson(): any {\r\n    if ( this.hasMembers ) {\r\n      const local = super.toJson();\r\n      local.members = this._members.map(item => item.asJson);\r\n      return local;\r\n    }\r\n    return {};\r\n  }\r\n\r\n  public isEqualTo(obj: foCollection<T>, deep: boolean = true) {\r\n    const result = true;\r\n    return result;\r\n  }\r\n}\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foLifecycle.ts",["68"],"import { Action } from './foInterface';\r\nimport { foObject } from './foObject.model';\r\nimport { Tools } from './foTools';\r\n\r\n// https://github.com/ReactiveX/rxjs/blob/master/docs_app/content/guide/v6/migration.md\r\nimport { Observable, Subject } from 'rxjs';\r\nimport { debounceTime, filter } from 'rxjs/operators';\r\n\r\nlet counter = 0;\r\nexport enum LifecycleEventTypes {\r\n  primitive,\r\n  defined,\r\n  created,\r\n  destroyed,\r\n}\r\n\r\nexport class foLifecycleEvent {\r\n  id: number = 0;\r\n  cmd: string = '';\r\n  object: foObject;\r\n  value: any;\r\n\r\n  get guid() {\r\n    return this.object.myGuid;\r\n  }\r\n  get simpleGuid() {\r\n    return this.object.myGuid.slice(-8);\r\n  }\r\n  get myGuid() {\r\n    return this.object.myGuid;\r\n  }\r\n  get myType() {\r\n    return this.object.myType;\r\n  }\r\n\r\n  get myClass() {\r\n    return this.object['myClass'];\r\n  }\r\n\r\n  get myName() {\r\n    return this.object.myName;\r\n  }\r\n\r\n  isNamed(name: string) {\r\n    return Tools.matches(name, this.myName);\r\n  }\r\n\r\n  isCmd(cmd: string) {\r\n    return Tools.matches(cmd, this.cmd);\r\n  }\r\n\r\n  constructor(cmd: string, obj: foObject, count: number = 0, value?: any) {\r\n    this.id = count;\r\n    this.cmd = cmd;\r\n    this.object = obj;\r\n    this.value = value;\r\n  }\r\n}\r\n\r\n//this is needed to prevent circular communiation\r\n// create => create => create across browsers\r\nexport class foLifecycleEventLock {\r\n  private _processLock = {};\r\n\r\n  isLocked(guid: string) {\r\n    return this._processLock[guid] ? true : false;\r\n  }\r\n\r\n  addLock(guid: string) {\r\n    if (!this.isLocked(guid)) {\r\n      this._processLock[guid] = 0;\r\n    }\r\n    this._processLock[guid] += 1;\r\n  }\r\n\r\n  unLock(guid: string) {\r\n    if (this.isLocked(guid)) {\r\n      this._processLock[guid] -= 1;\r\n      if (this._processLock[guid] <= 0) {\r\n        delete this._processLock[guid];\r\n      }\r\n    }\r\n  }\r\n\r\n  protected(guid: string, context: any, func: Action<any>) {\r\n    this.addLock(guid);\r\n    try {\r\n      func(context);\r\n    } catch (ex) {\r\n      console.error('protected', ex);\r\n    }\r\n    this.unLock(guid);\r\n  }\r\n\r\n  whenUnprotected(guid: string, context: any, func: Action<any>) {\r\n    if (!this.isLocked(guid)) {\r\n      try {\r\n        func(context);\r\n      } catch (ex) {\r\n        console.error('whenUnprotected ', ex);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport let LifecycleLock: foLifecycleEventLock = new foLifecycleEventLock();\r\nexport let KnowcycleLock: foLifecycleEventLock = new foLifecycleEventLock();\r\n\r\n\r\n\r\nexport class foLifecycle {\r\n  mute: boolean = false;\r\n\r\n  public observable: Observable<foLifecycleEvent>;\r\n  public emit: Subject<foLifecycleEvent>;\r\n\r\n  private debounced: Subject<foLifecycleEvent>;\r\n\r\n  constructor(debouce: number = 500) {\r\n    this.emit = new Subject<foLifecycleEvent>();\r\n    this.observable = this.emit.asObservable();\r\n\r\n    this.debounced = new Subject<foLifecycleEvent>();\r\n\r\n    this.debounced\r\n      .asObservable()\r\n      .pipe(debounceTime(debouce))\r\n      .subscribe(event => {\r\n        event.id = counter++;\r\n        this.broadcast(event);\r\n      });\r\n  }\r\n\r\n  broadcast(obj: foLifecycleEvent) {\r\n    !this.mute && this.emit.next(obj);\r\n    return this;\r\n  }\r\n\r\n  primitive(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('primitive', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  defined(obj?: foObject) {\r\n    this.broadcast(new foLifecycleEvent('defined', obj, counter++));\r\n    return this;\r\n  }\r\n\r\n  event(eventName: string, obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent(eventName, obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  created(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('created', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  destroyed(obj: foObject) {\r\n    this.broadcast(new foLifecycleEvent('destroyed', obj, counter++));\r\n    return this;\r\n  }\r\n\r\n  unparent(obj: foObject) {\r\n    this.broadcast(new foLifecycleEvent('unparent', obj, counter++));\r\n    return this;\r\n  }\r\n\r\n  reparent(obj: foObject) {\r\n    this.broadcast(new foLifecycleEvent('reparent', obj, counter++));\r\n    return this;\r\n  }\r\n\r\n  action(obj: foObject, action: string, params?: any) {\r\n    this.broadcast(\r\n      new foLifecycleEvent('run', obj, counter++, {\r\n        action: action,\r\n        params: params\r\n      })\r\n    );\r\n    return this;\r\n  }\r\n\r\n  command(obj: foObject, method: string) {\r\n    this.broadcast(new foLifecycleEvent('command', obj, counter++, method));\r\n    return this;\r\n  }\r\n\r\n  selected(obj: foObject, value: any) {\r\n    this.broadcast(new foLifecycleEvent('selected', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  pageSelections(obj: foObject, value: any) {\r\n    this.broadcast(new foLifecycleEvent('pageselections', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  layout(obj: foObject, value: any) {\r\n    this.broadcast(new foLifecycleEvent('layout', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  changed(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('changed', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  glued(obj: foObject, value: any) {\r\n    this.broadcast(new foLifecycleEvent('glued', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  unglued(obj: foObject, value: any) {\r\n    this.broadcast(new foLifecycleEvent('unglued', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  dropped(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('dropped', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  handle(obj: foObject, value?: any) {\r\n    this.debounced.next(new foLifecycleEvent('handle', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  moved(obj: foObject, value?: any) {\r\n    this.debounced.next(new foLifecycleEvent('moved', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  easeTo(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('easeTo', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  easeTween(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('easeTween', obj, counter++, value));\r\n    return this;\r\n  }\r\n}\r\n\r\nexport let Lifecycle: foLifecycle = new foLifecycle(300);\r\nexport let Knowcycle: foLifecycle = new foLifecycle();\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foController.ts",["69"],"import { foObject } from './foObject.model';\r\n\r\n//SRS integrate mYName , DisplayName and isVisible  into command rendering\r\n\r\nexport class foCommand extends foObject {\r\n  doAction: () => void;\r\n  getLabel: () => string;\r\n\r\n  constructor(myName: string, doAction: () => void, getLabel?: () => string) {\r\n    super();\r\n    this.myName = myName;\r\n    this.doAction = doAction;\r\n    this.getLabel = getLabel ? getLabel : () => this.myName;\r\n  }\r\n}\r\n\r\nexport class foToggle extends foObject {\r\n  doToggle: () => void;\r\n  getState: () => any;\r\n  getLabel: () => string;\r\n\r\n  constructor(\r\n    myName: string,\r\n    doToggle: () => void,\r\n    getState: () => any,\r\n    getLabel?: () => string\r\n  ) {\r\n    super();\r\n    this.myName = myName;\r\n    this.doToggle = doToggle;\r\n    this.getState = getState;\r\n    this.getLabel = getLabel ? getLabel : () => this.myName;\r\n  }\r\n}\r\n\r\nexport class foController extends foObject {\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  private _commands: Array<foCommand> = new Array<foCommand>();\r\n  addCommands(...cmds: foCommand[]) {\r\n    this._commands.push(...cmds);\r\n    this._toggle.forEach(item => !item.hasParent && item.setParent(this));\r\n    return this;\r\n  }\r\n\r\n  get commands(): Array<foCommand> {\r\n    return this._commands;\r\n  }\r\n\r\n  private _toggle: Array<foToggle> = new Array<foToggle>();\r\n  addToggle(...cmds: foToggle[]) {\r\n    this._toggle.push(...cmds);\r\n    this._toggle.forEach(item => !item.hasParent && item.setParent(this));\r\n    return this;\r\n  }\r\n\r\n  get toggles(): Array<foToggle> {\r\n    return this._toggle;\r\n  }\r\n}\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foPubSub.ts",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foChange.ts",[],{"ruleId":"70","replacedBy":"71"},{"ruleId":"72","replacedBy":"73"},{"ruleId":"74","severity":1,"message":"75","line":25,"column":3,"nodeType":"76","messageId":"77","endLine":25,"endColumn":19},{"ruleId":"70","replacedBy":"78"},{"ruleId":"72","replacedBy":"79"},{"ruleId":"80","severity":1,"message":"81","line":11,"column":23,"nodeType":"82","messageId":"83","endLine":11,"endColumn":24},{"ruleId":"80","severity":1,"message":"84","line":1,"column":10,"nodeType":"82","messageId":"83","endLine":1,"endColumn":15},{"ruleId":"80","severity":1,"message":"85","line":7,"column":24,"nodeType":"82","messageId":"83","endLine":7,"endColumn":30},{"ruleId":"74","severity":1,"message":"75","line":37,"column":3,"nodeType":"76","messageId":"77","endLine":39,"endColumn":4},"no-native-reassign",["86"],"no-negated-in-lhs",["87"],"@typescript-eslint/no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor",["86"],["87"],"@typescript-eslint/no-unused-vars","'T' is defined but never used.","Identifier","unusedVar","'Tools' is defined but never used.","'filter' is defined but never used.","no-global-assign","no-unsafe-negation"]