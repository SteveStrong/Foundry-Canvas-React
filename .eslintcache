[{"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\Canvas.tsx":"1","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\CanvasHook.ts":"2","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\index.tsx":"3","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\core\\foRenderer.tsx":"4","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foPage.model.ts":"5","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foGlyph2D.model.ts":"6","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foTools.ts":"7","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foLifecycle.ts":"8","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foObject.model.ts":"9","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foMatrix2D.ts":"10","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foGeometry2D.ts":"11","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foShape2D.model.ts":"12","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foPubSub.ts":"13","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foCollection.model.ts":"14","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foText2D.model.ts":"15","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foUnDo.ts":"16","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\PaintTest2.tsx":"17","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\PaintTest3.tsx":"18","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\models\\lights.ts":"19","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\models\\timeline.ts":"20","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\PaintTest4.tsx":"21","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\models\\rxPubSub.ts":"22","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\models\\effect.ts":"23"},{"size":525,"mtime":1607789163301,"results":"24","hashOfConfig":"25"},{"size":1002,"mtime":1607826746524,"results":"26","hashOfConfig":"25"},{"size":246,"mtime":1607826746524,"results":"27","hashOfConfig":"25"},{"size":1640,"mtime":1607314452076,"results":"28","hashOfConfig":"25"},{"size":5187,"mtime":1607826746524,"results":"29","hashOfConfig":"25"},{"size":17865,"mtime":1607826746524,"results":"30","hashOfConfig":"25"},{"size":14138,"mtime":1607789163318,"results":"31","hashOfConfig":"25"},{"size":6154,"mtime":1607314452085,"results":"32","hashOfConfig":"25"},{"size":10904,"mtime":1607314452086,"results":"33","hashOfConfig":"25"},{"size":9184,"mtime":1607397956264,"results":"34","hashOfConfig":"25"},{"size":7560,"mtime":1607315554112,"results":"35","hashOfConfig":"25"},{"size":5879,"mtime":1607826746524,"results":"36","hashOfConfig":"25"},{"size":815,"mtime":1607314452098,"results":"37","hashOfConfig":"25"},{"size":3191,"mtime":1607314452081,"results":"38","hashOfConfig":"25"},{"size":11581,"mtime":1607397956270,"results":"39","hashOfConfig":"25"},{"size":2590,"mtime":1607397956272,"results":"40","hashOfConfig":"25"},{"size":2837,"mtime":1607789163304,"results":"41","hashOfConfig":"25"},{"size":4394,"mtime":1607789163306,"results":"42","hashOfConfig":"25"},{"size":6135,"mtime":1607826746540,"results":"43","hashOfConfig":"25"},{"size":6267,"mtime":1607826746543,"results":"44","hashOfConfig":"25"},{"size":4302,"mtime":1607826746524,"results":"45","hashOfConfig":"25"},{"size":399,"mtime":1607826746541,"results":"46","hashOfConfig":"25"},{"size":2617,"mtime":1607826746524,"results":"47","hashOfConfig":"25"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"51"},"1x4sejr",{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61","usedDeprecatedRules":"51"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"64","usedDeprecatedRules":"51"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67","usedDeprecatedRules":"51"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"70","usedDeprecatedRules":"51"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"77","usedDeprecatedRules":"78"},{"filePath":"79","messages":"80","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"81","messages":"82","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"83"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"86","usedDeprecatedRules":"51"},{"filePath":"87","messages":"88","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"89","usedDeprecatedRules":"83"},{"filePath":"90","messages":"91","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"83"},{"filePath":"92","messages":"93","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"94","messages":"95","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"96","usedDeprecatedRules":"83"},{"filePath":"97","messages":"98","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"99","messages":"100","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"101","usedDeprecatedRules":"51"},{"filePath":"102","messages":"103","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"104","usedDeprecatedRules":"51"},{"filePath":"105","messages":"106","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"107","messages":"108","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"109","usedDeprecatedRules":"51"},"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\Canvas.tsx",["110"],"import { useCanvas2D } from 'CanvasHook';\r\nimport React, { Fragment, FunctionComponent, ReactElement } from 'react';\r\nimport { ToJSON } from './core/foRenderer'\r\n\r\n\r\nexport const Canvas: FunctionComponent<any> = (props: any): ReactElement => {\r\n    const { draw, ...rest } = props;\r\n    const canvasRef = useCanvas2D(draw);\r\n\r\n    return (\r\n        <Fragment>\r\n            <h1>{props.title}</h1>\r\n            <canvas ref={canvasRef} {...rest} />\r\n            {/* <ToJSON {...props} /> */}\r\n        </Fragment>\r\n    );\r\n};\r\n\r\n",["111","112"],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\CanvasHook.ts",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\index.tsx",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\core\\foRenderer.tsx",[],["113","114"],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foPage.model.ts",["115"],"\r\n\r\n\r\n\r\nimport { TorusGeometry } from 'three';\r\nimport { foObject } from './foObject.model';\r\nimport { foShape2D, IfoShape2DProperties } from './foShape2D.model';\r\n\r\nexport interface IfoPageProperties extends IfoShape2DProperties {\r\n  marginX?: number;\r\n  marginY?: number;\r\n  showBoundry?: boolean;\r\n}\r\n\r\n//a Shape is a graphic designed to behave like a visio shape\r\n//and have all the same properties\r\nexport class foPage extends foShape2D implements IfoPageProperties {\r\n  private _isDirty: boolean = true;\r\n  gridSizeX: number = 50;\r\n  gridSizeY: number = 50;\r\n  showBoundry: boolean = true;\r\n\r\n\r\n  constructor(\r\n    properties?: IfoPageProperties,\r\n    parent?: foObject\r\n  ) {\r\n    super(properties, parent);\r\n    this.override(properties);\r\n  }\r\n\r\n  markAsDirty(): foPage {\r\n    this._isDirty = true;\r\n    return this;\r\n  }\r\n  markAsClean(): foPage {\r\n    this._isDirty = false;\r\n    return this;\r\n  }\r\n\r\n  get isDirty() {\r\n    return this._isDirty;\r\n  }\r\n\r\n\r\n  protected _marginX: number;\r\n  get marginX(): number {\r\n    return this._marginX || 0.0;\r\n  }\r\n  set marginX(value: number) {\r\n    this.smash();\r\n    this._marginX = value;\r\n  }\r\n\r\n  protected _marginY: number;\r\n  get marginY(): number {\r\n    return this._marginY || 0.0;\r\n  }\r\n  set marginY(value: number) {\r\n    this.smash();\r\n    this._marginY = value;\r\n  }\r\n\r\n  protected _scaleX: number;\r\n  get scaleX(): number {\r\n    return this._scaleX || 1.0;\r\n  }\r\n  set scaleX(value: number) {\r\n    this.smash();\r\n    this._scaleX = value;\r\n  }\r\n\r\n  protected _scaleY: number;\r\n  get scaleY(): number {\r\n    return this._scaleY || 1.0;\r\n  }\r\n  set scaleY(value: number) {\r\n    this.smash();\r\n    this._scaleY = value;\r\n  }\r\n\r\n\r\n  mouseLoc: any = {};\r\n\r\n\r\n\r\n\r\n\r\n  zoomBy(zoom: number) {\r\n    this.scaleX *= zoom;\r\n    this.scaleY *= zoom;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  drawGrid(ctx: CanvasRenderingContext2D) {\r\n    ctx.save();\r\n    ctx.beginPath();\r\n\r\n    ctx.setLineDash([5, 1]);\r\n    ctx.strokeStyle = 'gray';\r\n\r\n    const left = this.marginX - this.x;\r\n    const top = this.marginY - this.y;\r\n    const width = this.width / this.scaleX;\r\n    const height = this.height / this.scaleY;\r\n    const right = left + width;\r\n    const bottom = top + height;\r\n\r\n    //ctx.fillStyle = 'yellow';\r\n    //ctx.fillRect(left,top, width, height);\r\n\r\n    //draw vertical...\r\n    let x = this.gridSizeX; //left;\r\n    while (x < right) {\r\n      ctx.moveTo(x, top);\r\n      ctx.lineTo(x, bottom);\r\n      x += this.gridSizeX;\r\n    }\r\n    x = -this.gridSizeX; //left;\r\n    while (x > left) {\r\n      ctx.moveTo(x, top);\r\n      ctx.lineTo(x, bottom);\r\n      x -= this.gridSizeX;\r\n    }\r\n\r\n    //draw horizontal...\r\n    let y = this.gridSizeY; //top;\r\n    while (y < bottom) {\r\n      ctx.moveTo(left, y);\r\n      ctx.lineTo(right, y);\r\n      y += this.gridSizeY;\r\n    }\r\n\r\n    y = -this.gridSizeY; //top;\r\n    while (y > top) {\r\n      ctx.moveTo(left, y);\r\n      ctx.lineTo(right, y);\r\n      y -= this.gridSizeY;\r\n    }\r\n\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n\r\n  drawAxis(ctx: CanvasRenderingContext2D) {\r\n    ctx.save();\r\n    ctx.beginPath();\r\n\r\n    ctx.strokeStyle = 'black';\r\n    ctx.lineWidth = 3;\r\n\r\n    const left = this.marginX - this.x;\r\n    const top = this.marginY - this.y;\r\n    const width = this.width / this.scaleX;\r\n    const height = this.height / this.scaleY;\r\n    const right = left + width;\r\n    const bottom = top + height;\r\n\r\n    //draw vertical...\r\n    ctx.moveTo(0, top);\r\n    ctx.lineTo(0, bottom);\r\n\r\n    //draw horizontal...\r\n\r\n    ctx.moveTo(left, 0);\r\n    ctx.lineTo(right, 0);\r\n\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n\r\n  drawPage(ctx: CanvasRenderingContext2D) {\r\n    ctx.save();\r\n    ctx.beginPath();\r\n\r\n    ctx.strokeStyle = 'black';\r\n    ctx.lineWidth = 5;\r\n\r\n    //let left = this.marginX - this.x;\r\n    //let top = this.marginY - this.y;\r\n    //let width = this.width / this.scaleX;\r\n    //let height = this.height / this.scaleY;\r\n    //let right = left + width;\r\n    //let bottom = top + height;\r\n\r\n    //draw vertical...\r\n    ctx.rect(0, 0, this.width, this.height);\r\n\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n\r\n  drawName(ctx: CanvasRenderingContext2D) {\r\n    ctx.save();\r\n    ctx.font = '50pt Calibri';\r\n    ctx.lineWidth = 3;\r\n    ctx.strokeStyle = 'blue';\r\n    ctx.strokeText(this.myName, 10, 50);\r\n    ctx.restore();\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  public render(ctx: CanvasRenderingContext2D, deep: boolean = true): foPage {\r\n    ctx.clearRect(0, 0, this.width, this.height);\r\n\r\n    ctx.save();\r\n\r\n    this.drawName(ctx);\r\n\r\n    this.preDraw && this.preDraw(ctx);\r\n    this.draw(ctx);\r\n    //this.drawHover && this.drawHover(ctx);\r\n    this.postDraw && this.postDraw(ctx);\r\n\r\n    deep &&\r\n      this._subcomponents?.forEach(item => {\r\n        item.render(ctx, deep);\r\n      });\r\n    ctx.restore();\r\n\r\n    this.showBoundry && this.afterRender(ctx);\r\n\r\n    return this.markAsClean();\r\n  }\r\n\r\n  public preDraw = (ctx: CanvasRenderingContext2D): void => {\r\n    ctx.fillStyle = this.color;\r\n    ctx.fillRect(0, 0, this.width, this.height);\r\n  }\r\n\r\n  public draw = (ctx: CanvasRenderingContext2D): void => {\r\n    this.drawGrid(ctx);\r\n    this.drawAxis(ctx);\r\n    this.drawPage(ctx);\r\n    this.drawPin(ctx);\r\n  }\r\n}\r\n\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foGlyph2D.model.ts",["116"],"import { Tools } from './foTools';\r\nimport { cPoint2D, cFrame } from './foGeometry2D';\r\nimport { Matrix2D } from './foMatrix2D';\r\n\r\nimport { iPoint2D, iRect, iFrame } from './foInterface';\r\n\r\n\r\nimport { Lifecycle } from './foLifecycle';\r\n\r\n\r\nimport { foObject } from './foObject.model';\r\n\r\n\r\nexport interface IfoGlyph2DProperties {\r\n  opacity?: number;\r\n  isSelected?: boolean;\r\n  color?: string;\r\n\r\n  x?: number;\r\n  y?: number;\r\n  width?: number;\r\n  height?: number; \r\n  [propName: string]: any;\r\n}\r\n\r\n// a Glyph is a graphic designed to draw on a canvas in absolute coordinates\r\nexport class foGlyph2D extends foObject implements IfoGlyph2DProperties {\r\n\r\n  public opacity: number = 1.0;\r\n  public isSelected: boolean = false;\r\n  public color: any;\r\n\r\n  protected _x: number;\r\n  protected _y: number;\r\n  protected _width: number;\r\n  protected _height: number;\r\n\r\n  constructor(properties?: IfoGlyph2DProperties, parent?: foObject) {\r\n    super(properties, parent);\r\n\r\n    this.override(properties);\r\n  }\r\n\r\n  get x(): number {\r\n    return this._x || 0.0;\r\n  }\r\n  set x(value: number) {\r\n    this.smash();\r\n    this._x = value;\r\n  }\r\n  get y(): number {\r\n    return this._y || 0.0;\r\n  }\r\n  set y(value: number) {\r\n    this.smash();\r\n    this._y = value;\r\n  }\r\n\r\n  get width(): number {\r\n    return this._width || 0.0;\r\n  }\r\n  set width(value: number) {\r\n    this._width = value;\r\n  }\r\n\r\n  get height(): number {\r\n    return this._height || 0.0;\r\n  }\r\n  set height(value: number) {\r\n    this._height = value;\r\n  }\r\n\r\n  public rotationZ = (): number => {\r\n    return 0;\r\n  };\r\n\r\n  public doubleClick: (keys: any) => void;\r\n\r\n  public openEditor: () => void;\r\n  public closeEditor: () => void;\r\n  public drawHover: (ctx: CanvasRenderingContext2D) => void;\r\n  public setupHoverEnterDraw: () => void;\r\n  public setupHoverExitDraw: () => void;\r\n  public setupOverlapEnterDraw: () => void;\r\n  public setupOverlapExitDraw: () => void;\r\n\r\n  public sendKeys: (e: KeyboardEvent, keys: any) => void;\r\n  public preDraw: (ctx: CanvasRenderingContext2D) => void;\r\n  public postDraw: (ctx: CanvasRenderingContext2D) => void;\r\n\r\n  protected _matrix: Matrix2D;\r\n  protected _invMatrix: Matrix2D;\r\n  smash() {\r\n    //console.log('smash matrix')\r\n    this._matrix = undefined;\r\n    this._invMatrix = undefined;\r\n  }\r\n\r\n  computeBoundry(frame: cFrame): cFrame {\r\n    const mtx = this.getGlobalMatrix();\r\n    //this is a buffer so we create less garbage\r\n    const pt = frame.point;\r\n    frame.init(mtx.transformPoint(0, 0, pt));\r\n    frame.minmax(mtx.transformPoint(0, this.height, pt));\r\n    frame.minmax(mtx.transformPoint(this.width, 0, pt));\r\n    frame.minmax(mtx.transformPoint(this.width, this.height, pt));\r\n    return frame;\r\n  }\r\n\r\n  protected _boundry: cFrame = new cFrame(this);\r\n  get boundryFrame(): cFrame {\r\n    this.computeBoundry(this._boundry);\r\n\r\n\r\n    return this._boundry;\r\n  }\r\n\r\n  public drawBoundry(ctx: CanvasRenderingContext2D) {\r\n    ctx.beginPath();\r\n    ctx.setLineDash([5, 5]);\r\n    this.boundryFrame.draw(ctx, false);\r\n    ctx.stroke();\r\n  }\r\n\r\n\r\n\r\n  is2D() {\r\n    return true;\r\n  }\r\n\r\n  set(x: number, y: number, width: number, height: number): iRect {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = width;\r\n    this.height = height;\r\n    return this;\r\n  }\r\n\r\n  contains(x: number, y: number): boolean {\r\n    return (\r\n      this.x <= x &&\r\n      x <= this.x + this.width &&\r\n      this.y <= y &&\r\n      y <= this.y + this.height\r\n    );\r\n  }\r\n\r\n  localContains(x: number, y: number): boolean {\r\n    return 0 <= x && x <= this.width && 0 <= y && y <= this.height;\r\n  }\r\n\r\n  protected toJson(): any {\r\n    return Tools.mixin(super.toJson(), {\r\n      x: this.x,\r\n      y: this.y,\r\n      width: this.width,\r\n      height: this.height\r\n    });\r\n  }\r\n\r\n  public initialize(\r\n    x: number = Number.NaN,\r\n    y: number = Number.NaN,\r\n    ang: number = Number.NaN\r\n  ) {\r\n    return this;\r\n  }\r\n\r\n  public didLocationChange(\r\n    x: number = Number.NaN,\r\n    y: number = Number.NaN,\r\n    angle: number = Number.NaN\r\n  ): boolean {\r\n    let changed = false;\r\n    if (!Number.isNaN(x) && this.x !== x) {\r\n      changed = true;\r\n      this.x = x;\r\n    }\r\n\r\n    if (!Number.isNaN(y) && this.y !== y) {\r\n      changed = true;\r\n      this.y = y;\r\n    }\r\n\r\n    return changed;\r\n  }\r\n\r\n  public easeToNoLifecycle(x: number, y: number) {\r\n    this.initialize(x, y);\r\n    return this;\r\n  }\r\n\r\n  // public easeToNoLifecycle(\r\n  //   x: number,\r\n  //   y: number,\r\n  //   time: number = 0.5,\r\n  //   ease: any = Back.easeInOut\r\n  // ) {\r\n  //   TweenLite.to(this, time, {\r\n  //     x: x,\r\n  //     y: y,\r\n  //     ease: ease\r\n  //     // }).eventCallback(\"onUpdate\", () => {\r\n  //     //     this.drop();\r\n  //   }).eventCallback('onComplete', () => {\r\n  //     this.initialize(x, y);\r\n  //   });\r\n\r\n  //   return this;\r\n  // }\r\n\r\n  // public easeTo(x: number, y: number) {\r\n  //   this.initialize(x, y);\r\n  //   return this;\r\n  // }\r\n\r\n  // public easeTo(\r\n  //   x: number,\r\n  //   y: number,\r\n  //   time: number = 0.5,\r\n  //   ease: any = Back.easeInOut\r\n  // ) {\r\n  //   TweenLite.to(this, time, {\r\n  //     x: x,\r\n  //     y: y,\r\n  //     ease: ease\r\n  //   })\r\n  //     .eventCallback('onUpdate', () => {\r\n  //       this.move();\r\n  //     })\r\n  //     .eventCallback('onComplete', () => {\r\n  //       this.dropAt(x, y);\r\n  //       Lifecycle.easeTo(this, this.getLocation());\r\n  //     });\r\n\r\n  //   return this;\r\n  // }\r\n\r\n  public easeTween(to: any, time: number = 0.5) {\r\n    Lifecycle.easeTween(this, { time, undefined, to });\r\n    return this;\r\n  }\r\n\r\n  // public easeTween(to: any, time: number = 0.5, ease: any = 'ease') {\r\n  //   const from = Tools.union(to, { ease: Back[ease] });\r\n\r\n  //   TweenLite.to(this, time, from).eventCallback('onComplete', () =>\r\n  //     this.override(to)\r\n  //   );\r\n  //   Lifecycle.easeTween(this, { time, ease, to });\r\n  //   return this;\r\n  // }\r\n\r\n  public dropAt(\r\n    x: number = Number.NaN,\r\n    y: number = Number.NaN,\r\n    angle: number = Number.NaN\r\n  ) {\r\n    if (this.didLocationChange(x, y, angle)) {\r\n      Lifecycle.dropped(this, this.getLocation());\r\n    }\r\n    return this;\r\n  }\r\n\r\n  public move(\r\n    x: number = Number.NaN,\r\n    y: number = Number.NaN,\r\n    angle: number = Number.NaN\r\n  ) {\r\n    if (this.didLocationChange(x, y, angle)) {\r\n      Lifecycle.moved(this, this.getLocation());\r\n    }\r\n    return this;\r\n  }\r\n\r\n  public moveTo(loc: iPoint2D, offset?: iPoint2D) {\r\n    const x = loc.x + (offset ? offset.x : 0);\r\n    const y = loc.y + (offset ? offset.y : 0);\r\n    return this.move(x, y);\r\n  }\r\n\r\n  public moveBy(loc: iPoint2D, offset?: iPoint2D) {\r\n    const x = this.x + loc.x + (offset ? offset.x : 0);\r\n    const y = this.y + loc.y + (offset ? offset.y : 0);\r\n    return this.move(x, y);\r\n  }\r\n\r\n  updateContext(ctx: CanvasRenderingContext2D) {\r\n    const mtx = this.getMatrix();\r\n    ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\r\n    ctx.globalAlpha *= this.opacity;\r\n  }\r\n\r\n  getGlobalMatrix() {\r\n    const mtx = new Matrix2D(this.getMatrix());\r\n    const parent = this.myParent && <foGlyph2D>this.myParent();\r\n    if (parent) {\r\n      mtx.prependMatrix(parent.getGlobalMatrix());\r\n    }\r\n    return mtx;\r\n  }\r\n\r\n  getMatrix() {\r\n    if (this._matrix === undefined) {\r\n      this._matrix = new Matrix2D();\r\n      this._matrix.appendTransform(this.x, this.y, 1, 1, 0, 0, 0, 0, 0);\r\n    }\r\n    return this._matrix;\r\n  }\r\n\r\n  getInvMatrix() {\r\n    if (this._invMatrix === undefined) {\r\n      this._invMatrix = this.getMatrix().invertCopy();\r\n    }\r\n    return this._invMatrix;\r\n  }\r\n\r\n  localToGlobal(x: number, y: number, pt?: cPoint2D) {\r\n    const mtx = this.getGlobalMatrix();\r\n    return mtx.transformPoint(x, y, pt);\r\n  }\r\n\r\n  localToGlobalPoint(pt: cPoint2D): cPoint2D {\r\n    const mtx = this.getGlobalMatrix();\r\n    return mtx.transformPoint(pt.x, pt.y, pt);\r\n  }\r\n\r\n  globalToLocal(x: number, y: number, pt?: cPoint2D): cPoint2D {\r\n    const inv = this.getGlobalMatrix().invertCopy();\r\n    return inv.transformPoint(x, y, pt);\r\n  }\r\n\r\n  globalToLocalPoint(pt: cPoint2D): cPoint2D {\r\n    const inv = this.getGlobalMatrix().invertCopy();\r\n    return inv.transformPoint(pt.x, pt.y, pt);\r\n  }\r\n\r\n  globalToLocalFrame(\r\n    x1: number,\r\n    y1: number,\r\n    x2: number,\r\n    y2: number,\r\n    frame?: cFrame\r\n  ): cFrame {\r\n    frame = frame || new cFrame();\r\n    const inv = this.getGlobalMatrix().invertCopy();\r\n\r\n    frame.init(inv.transformPoint(x1, y1, frame.point));\r\n    frame.minmax(inv.transformPoint(x1, y2, frame.point));\r\n    frame.minmax(inv.transformPoint(x2, y1, frame.point));\r\n    frame.minmax(inv.transformPoint(x2, y2, frame.point));\r\n    return frame;\r\n  }\r\n\r\n  localToLocal(\r\n    x: number,\r\n    y: number,\r\n    target: foGlyph2D,\r\n    pt?: cPoint2D\r\n  ): cPoint2D {\r\n    pt = this.localToGlobal(x, y, pt);\r\n    return target.globalToLocal(pt.x, pt.y, pt);\r\n  }\r\n\r\n  globalCenter(): cPoint2D {\r\n    const { x, y } = this.pinLocation();\r\n    const mtx = this.getGlobalMatrix();\r\n    return mtx.transformPoint(x, y);\r\n  }\r\n\r\n  public isDragable = (): boolean => {\r\n    return true;\r\n  };\r\n\r\n  public getOffset = (loc: iPoint2D): iPoint2D => {\r\n    const x = this.x;\r\n    const y = this.y;\r\n    return new cPoint2D(x - loc.x, y - loc.y);\r\n  };\r\n\r\n  public getLocation = (): any => {\r\n    return {\r\n      x: this.x,\r\n      y: this.y,\r\n      z: 0\r\n    };\r\n  };\r\n\r\n  public pinLocation(): any {\r\n    return {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0\r\n    };\r\n  }\r\n\r\n  public setLocation = (loc?: iPoint2D) => {\r\n    this.x = loc ? loc.x : 0;\r\n    this.y = loc ? loc.y : 0;\r\n  };\r\n\r\n  protected localHitTest = (hit: iPoint2D): boolean => {\r\n    const { x, y } = hit;\r\n    const loc = this.globalToLocal(x, y);\r\n\r\n    if (loc.x < 0) return false;\r\n    if (loc.x > this.width) return false;\r\n\r\n    if (loc.y < 0) return false;\r\n    if (loc.y > this.height) return false;\r\n    return true;\r\n  };\r\n\r\n  public hitTest = (hit: iPoint2D): boolean => {\r\n    return this.isHitable && this.isVisible && this.localHitTest(hit);\r\n  };\r\n\r\n  public overlapTest = (hit: iFrame): boolean => {\r\n    const frame = this.globalToLocalFrame(hit.x1, hit.y1, hit.x2, hit.y2);\r\n\r\n    if (this.localContains(frame.x1, frame.y1)) return true;\r\n    if (this.localContains(frame.x1, frame.y2)) return true;\r\n    if (this.localContains(frame.x2, frame.y1)) return true;\r\n    if (this.localContains(frame.x2, frame.y2)) return true;\r\n    return false;\r\n  };\r\n\r\n  // findObjectUnderPoint(hit: iPoint2D, deep: boolean): foGlyph2D {\r\n  //   let found: foGlyph2D = this.hitTest(hit) ? this : undefined;\r\n\r\n  //   if (deep) {\r\n  //     const child = this.findChildObjectUnderPoint(hit);\r\n  //     found = child ? child : found;\r\n  //   }\r\n  //   return found;\r\n  // }\r\n\r\n\r\n\r\n\r\n\r\n\r\n  public afterRender = (\r\n    ctx: CanvasRenderingContext2D,\r\n    deep: boolean = true\r\n  ) => {\r\n    ctx.save();\r\n    ctx.lineWidth = 4;\r\n    ctx.strokeStyle = 'pink';\r\n    this.drawBoundry(ctx);\r\n    ctx.restore();\r\n\r\n    // deep &&\r\n    //   this.nodes.forEach(item => {\r\n    //     item.afterRender(ctx, deep);\r\n    //   });\r\n  };\r\n\r\n  public render(ctx: CanvasRenderingContext2D, deep: boolean = true): foGlyph2D {\r\n    if (this.isInvisible) return;\r\n    ctx.save();\r\n\r\n    //this.drawOrigin(ctx);\r\n    this.updateContext(ctx);\r\n    //this.drawOriginX(ctx);\r\n\r\n    this.preDraw && this.preDraw(ctx);\r\n    this.draw(ctx);\r\n    this.drawHover && this.drawHover(ctx);\r\n    this.postDraw && this.postDraw(ctx);\r\n\r\n    //this.isSelected && this.drawSelected(ctx);\r\n\r\n    // deep &&\r\n    //   this.nodes.forEach(item => {\r\n    //     item.render(ctx, deep);\r\n    //   });\r\n\r\n    ctx.restore();\r\n    return this;\r\n  }\r\n\r\n  public drawFont(\r\n    ctx: CanvasRenderingContext2D,\r\n    size: number = 20,\r\n    fontFamily: string = 'Arial',\r\n    align: any = 'center',\r\n    base: any = 'middle'\r\n  ) {\r\n    ctx.textAlign = align;\r\n    ctx.textBaseline = base;\r\n    ctx.font = `${size}px ${fontFamily}`;\r\n  }\r\n\r\n  //https://stackoverflow.com/questions/6061880/html5-canvas-circle-text\r\n\r\n  public drawTextCircle = (\r\n    ctx: CanvasRenderingContext2D,\r\n    text: string,\r\n    radius: number = 100,\r\n    start: number = Math.PI / 2,\r\n    x: number = 0,\r\n    y: number = 0\r\n  ): void => {\r\n    if (text) {\r\n\r\n      ctx.save();\r\n      ctx.textAlign = 'center';\r\n      ctx.textBaseline = 'middle';\r\n      ctx.translate(x, y);\r\n      ctx.rotate(start - Math.PI / 2);\r\n\r\n      let len = text.length;\r\n      for (let i = 0; i < len; i++) {\r\n        let s = text[i];\r\n        let letterAngle = 0.5 * (ctx.measureText(s).width / radius);\r\n\r\n        ctx.rotate(letterAngle);\r\n        ctx.save();\r\n\r\n        ctx.translate(0, -radius);\r\n        ctx.fillText(s, 0, 0);\r\n        ctx.restore();\r\n\r\n        ctx.rotate(letterAngle);\r\n      }\r\n      ctx.restore();\r\n    }\r\n  };\r\n\r\n  public drawText = (\r\n    ctx: CanvasRenderingContext2D,\r\n    text: string,\r\n    x: number = 0,\r\n    y: number = 0\r\n  ): void => {\r\n    if (text) {\r\n      ctx.fillText(text, x, y);\r\n    }\r\n  };\r\n\r\n  public drawPin(ctx: CanvasRenderingContext2D) {\r\n    const { x, y } = this.pinLocation();\r\n\r\n    ctx.save();\r\n    ctx.beginPath();\r\n\r\n    ctx.arc(x, y, 6, 0, 2 * Math.PI, false);\r\n    ctx.fillStyle = 'pink';\r\n    ctx.fill();\r\n    ctx.lineWidth = 1;\r\n    ctx.strokeStyle = '#003300';\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n\r\n  public drawOrigin(ctx: CanvasRenderingContext2D) {\r\n    const { x, y } = this.pinLocation();\r\n\r\n    ctx.save();\r\n    ctx.beginPath();\r\n    ctx.setLineDash([5, 5]);\r\n    ctx.moveTo(x - 50, y);\r\n    ctx.lineTo(x + 50, y);\r\n    ctx.moveTo(x, y - 50);\r\n    ctx.lineTo(x, y + 50);\r\n    ctx.lineWidth = 1;\r\n    ctx.strokeStyle = '#003300';\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n\r\n  public drawOriginX(ctx: CanvasRenderingContext2D) {\r\n    const { x, y } = this.pinLocation();\r\n\r\n    ctx.save();\r\n    ctx.beginPath();\r\n    ctx.setLineDash([5, 5]);\r\n    ctx.moveTo(x - 50, y - 50);\r\n    ctx.lineTo(x + 50, y + 50);\r\n    ctx.moveTo(x + 50, y - 50);\r\n    ctx.lineTo(x - 50, y + 50);\r\n    ctx.lineWidth = 1;\r\n    ctx.strokeStyle = '#003300';\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n\r\n  public drawHighlight(ctx: CanvasRenderingContext2D) {\r\n    ctx.save();\r\n    ctx.strokeStyle = 'yellow';\r\n    ctx.lineWidth = 4;\r\n    this.drawOutline(ctx);\r\n    ctx.restore();\r\n  }\r\n\r\n  public drawHighlightOverlap(ctx: CanvasRenderingContext2D) {\r\n    ctx.strokeStyle = 'green';\r\n    ctx.lineWidth = 8;\r\n    this.drawOutline(ctx);\r\n    ctx.strokeStyle = 'yellow';\r\n    ctx.lineWidth = 4;\r\n    this.drawOutline(ctx);\r\n  }\r\n\r\n  public drawOutline(ctx: CanvasRenderingContext2D) {\r\n    ctx.beginPath();\r\n    ctx.setLineDash([15, 5]);\r\n    ctx.rect(0, 0, this.width, this.height);\r\n    ctx.stroke();\r\n  }\r\n\r\n\r\n\r\n\r\n  public drawSelected = (ctx: CanvasRenderingContext2D): void => {\r\n    ctx.strokeStyle = 'red';\r\n    ctx.lineWidth = 4;\r\n    this.drawOutline(ctx);\r\n    //this.drawHandles(ctx);\r\n    this.drawPin(ctx);\r\n  };\r\n\r\n  public draw = (ctx: CanvasRenderingContext2D): void => {\r\n    ctx.fillStyle = this.color;\r\n    ctx.lineWidth = 1;\r\n    ctx.fillRect(0, 0, this.width, this.height);\r\n  };\r\n\r\n  toggleSelected() {\r\n    this.isSelected = !this.isSelected;\r\n  }\r\n\r\n  // layoutSubcomponentsVertical(resize: boolean = true, space: number = 0) {\r\n  //   let loc = this.getLocation() as cPoint2D;\r\n  //   const self = this;\r\n\r\n  //   if (resize) {\r\n  //     self.height = self.width = 0;\r\n  //     loc.x = loc.y = 0;\r\n  //   } else {\r\n  //     loc = this.nodes.first().getLocation() as cPoint2D;\r\n  //   }\r\n\r\n  //   this.nodes.forEach(item => {\r\n  //     item.setLocation(loc);\r\n  //   });\r\n\r\n  //   this.nodes.forEach(item => {\r\n  //     const { x: pinX, y: pinY } = item.pinLocation();\r\n  //     loc.x = resize ? pinX : loc.x;\r\n  //     loc.y += pinY;\r\n  //     item.easeToNoLifecycle(loc.x, loc.y);\r\n  //     loc.y += space + item.height - pinY;\r\n\r\n  //     if (resize) {\r\n  //       self.width = Math.max(self.width, item.width);\r\n  //       self.height = loc.y;\r\n  //     }\r\n  //   });\r\n\r\n  //   Lifecycle.layout(this, {\r\n  //     method: 'layoutSubcomponentsVertical',\r\n  //     resize,\r\n  //     space\r\n  //   });\r\n  //   return this;\r\n  // }\r\n\r\n  // layoutSubcomponentsHorizontal(resize: boolean = true, space: number = 0) {\r\n  //   let loc = this.getLocation() as cPoint2D;\r\n  //   const self = this;\r\n\r\n  //   if (resize) {\r\n  //     self.height = self.width = 0;\r\n  //     loc.x = loc.y = 0;\r\n  //   } else {\r\n  //     loc = this.nodes.first().getLocation() as cPoint2D;\r\n  //   }\r\n\r\n  //   this.nodes.forEach(item => {\r\n  //     item.setLocation(loc);\r\n  //   });\r\n\r\n  //   this.nodes.forEach(item => {\r\n  //     const { x: pinX, y: pinY } = item.pinLocation();\r\n  //     loc.x += pinX;\r\n  //     loc.y = resize ? pinY : loc.y;\r\n  //     item.easeToNoLifecycle(loc.x, loc.y);\r\n  //     loc.x += space + item.width - pinX;\r\n\r\n  //     if (resize) {\r\n  //       self.width = loc.x;\r\n  //       self.height = Math.max(self.height, item.height);\r\n  //     }\r\n  //   });\r\n\r\n  //   Lifecycle.layout(this, {\r\n  //     method: 'layoutSubcomponentsHorizontal',\r\n  //     resize,\r\n  //     space\r\n  //   });\r\n  //   return this;\r\n  // }\r\n\r\n  // \r\n\r\n\r\n  // layoutMarginTop(resize: boolean = false, space: number = 0) {\r\n  //   const loc = this.getLocation() as cPoint2D;\r\n  //   const self = this;\r\n\r\n  //   loc.x = 10;\r\n  //   loc.y = space + this.height;\r\n\r\n  //   this.nodes.forEach(item => {\r\n  //     const { x: pinX, y: pinY } = item.pinLocation();\r\n  //     loc.y += pinY;\r\n  //     item.easeToNoLifecycle(loc.x + pinX, loc.y);\r\n  //     loc.y += space + item.height - pinY;\r\n\r\n  //     if (resize) {\r\n  //       self.width = Math.max(self.width, item.width);\r\n  //       self.height = loc.y;\r\n  //     }\r\n  //   });\r\n  //   Lifecycle.layout(this, { method: 'layoutMarginTop', resize, space });\r\n  //   return this;\r\n  // }\r\n}\r\n\r\n\r\n\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foTools.ts",["117"],"export enum foNames {\r\n  UNKNOWN = 'unknown',\r\n  AT = '@',\r\n  THIS = 'this',\r\n  SELF = 'self',\r\n  ROOT = 'root'\r\n}\r\n\r\n// Converts numeric degrees to radians\r\n// if (typeof (Number.prototype.toRad) === \"undefined\") {\r\n//     Number.prototype.toRad = function () {\r\n//         return this * Math.PI / 180;\r\n//     }\r\n// }\r\n// if (typeof (Number.prototype.toDeg) === \"undefined\") {\r\n//     Number.prototype.toDeg = function () {\r\n//         return this * 180 / Math.PI;\r\n//     }\r\n// }\r\n\r\nexport class foTools {\r\n  // Speed up calls to hasOwnProperty\r\n  private hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\n  constructor() {}\r\n\r\n  /**\r\n   * http://stackoverflow.com/questions/6588977/how-to-to-extract-a-javascript-function-from-a-javascript-file\r\n   * @param funct\r\n   */\r\n  getFunctionName(funct) {\r\n    let ret = funct.toString(); //do with regx\r\n    ret = ret.substr('function '.length);\r\n    ret = ret.substr(0, ret.indexOf('('));\r\n    return ret.trim();\r\n  }\r\n\r\n  //http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\r\n  generateUUID() {\r\n    let d = new Date().getTime();\r\n    const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(\r\n      /[xy]/g,\r\n      function(c) {\r\n        // tslint:disable-next-line:no-bitwise\r\n        const r = ((d + Math.random() * 16) % 16) | 0;\r\n        d = Math.floor(d / 16);\r\n        // tslint:disable-next-line:no-bitwise\r\n        return (c === 'x' ? r : (r & 0x7) | 0x8).toString(16);\r\n      }\r\n    );\r\n    return uuid;\r\n  }\r\n\r\n  asJson(target: any) {\r\n    const result = this.stringify(target);\r\n    return JSON.parse(result);\r\n  }\r\n\r\n  stringify(target: any, func = undefined, deep = 3) {\r\n    function resolveReference(value) {\r\n      if (value && value.asReference) {\r\n        return (\r\n          'resolveRef(' +\r\n          value.asReference() +\r\n          ',' +\r\n          value.constructor.name +\r\n          ')'\r\n        );\r\n      }\r\n      return value;\r\n    }\r\n    function resolveCircular(key:string, value:any) {\r\n      switch (key) {\r\n        case 'myParent':\r\n          return resolveReference(value);\r\n        case 'myMembers':\r\n          return value\r\n            ? value.map(function(item) {\r\n                return resolveReference(item);\r\n              })\r\n            : value;\r\n        case '_subcomponents':\r\n          return value;\r\n        case '_lookup':\r\n          return value;\r\n        case '_members':\r\n          return value;\r\n      }\r\n      if (key.startsWith('_')) {\r\n        return;\r\n      }\r\n      //if (this.isCustomLinkName(key)) {\r\n      //    return resolveReference(value);\r\n      //}\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(target, resolveCircular, deep);\r\n  }\r\n\r\n  splitNamespaceType(id: string, primitive?: string) {\r\n    const typeId = id.split('::');\r\n    let result = { namespace: '', name: id };\r\n    if (typeId.length === 2) {\r\n      result = {\r\n        namespace: typeId[0],\r\n        name: typeId[1]\r\n      };\r\n    } else if (primitive) {\r\n      result = {\r\n        namespace: typeId[0],\r\n        name: primitive\r\n      };\r\n    }\r\n    return result;\r\n  }\r\n\r\n  getNamespace(obj) {\r\n    let myNamespace = obj.myType ? obj.myType.split('::') : [''];\r\n    myNamespace = myNamespace[0];\r\n    return myNamespace;\r\n  }\r\n\r\n  getType(obj): string {\r\n    let myType = obj.myType ? obj.myType.split('::') : [''];\r\n    myType = myType.length === 2 ? myType[1] : myType[0];\r\n    return myType;\r\n  }\r\n\r\n  namespace(namespace: string, name: string) {\r\n    return `${namespace}::${name}`;\r\n  }\r\n\r\n  randomInt(low: number, high: number) {\r\n    return low + Math.floor(Math.random() * (high - low + 1));\r\n  }\r\n\r\n  random(low: number, high: number) {\r\n    return low + Math.random() * (high - low);\r\n  }\r\n\r\n  randomRGBColor() {\r\n    // tslint:disable-next-line:no-bitwise\r\n    const r = (255 * Math.random()) | 0;\r\n      // tslint:disable-next-line:no-bitwise\r\n    const g = (255 * Math.random()) | 0;\r\n      // tslint:disable-next-line:no-bitwise\r\n    const b = (255 * Math.random()) | 0;\r\n    return `rgb(${r},${g},${b})`;\r\n  }\r\n\r\n  matches(str1: string, str2: string) {\r\n    if (str1 === str2) {\r\n      return true;\r\n    }\r\n    return (\r\n      str1 && str2 && str1.toLocaleLowerCase() === str2.toLocaleLowerCase()\r\n    );\r\n  }\r\n\r\n  startsWith(str1: string, str2: string) {\r\n    if (str1 === str2) {\r\n      return true;\r\n    }\r\n    return (\r\n      str1 && str2 && str1.toLocaleLowerCase().startsWith(str2.toLocaleLowerCase())\r\n    );\r\n  }\r\n\r\n  capitalizeFirstLetter(str1: string) {\r\n    return str1.charAt(0).toUpperCase() + str1.slice(1);\r\n  }\r\n\r\n  isSelf(ref) {\r\n    return (\r\n      this.matches(ref, foNames.AT) ||\r\n      this.matches(ref, foNames.THIS) ||\r\n      this.matches(ref, foNames.SELF)\r\n    );\r\n  }\r\n\r\n  isArray(obj) {\r\n    if (Array.isArray) {\r\n      return Array.isArray(obj);\r\n    }\r\n    return Object.prototype.toString.call(obj) === '[object Array]'\r\n      ? true\r\n      : false;\r\n  }\r\n\r\n  isFunction(obj) {\r\n    return typeof obj === 'function';\r\n  }\r\n\r\n  isString(obj) {\r\n    return typeof obj === 'string';\r\n  }\r\n\r\n  isNumber(obj) {\r\n    return typeof obj === 'number';\r\n  }\r\n\r\n  isDate(obj) {\r\n    return obj instanceof Date;\r\n  }\r\n\r\n  isObject(obj) {\r\n    return obj && typeof obj === 'object'; //prevents typeOf null === 'object'\r\n  }\r\n\r\n  isCustomLinkName(key) {\r\n    return false;\r\n  }\r\n\r\n  isTyped(obj) {\r\n    return obj && obj.isInstanceOf;\r\n  }\r\n\r\n  isEmpty(obj) {\r\n    // null and undefined are \"empty\"\r\n    if (obj == null) {\r\n      return true;\r\n    }\r\n\r\n    // Assume if it has a length property with a non-zero value\r\n    // that that property is correct.\r\n    if (obj.length > 0) {\r\n      return false;\r\n    }\r\n    if (obj.length === 0) {\r\n      return true;\r\n    }\r\n\r\n    // If it isn't an object at this point\r\n    // it is empty, but it can't be anything *but* empty\r\n    // Is it empty?  Depends on your application.\r\n    if (typeof obj !== 'object') {\r\n      return true;\r\n    }\r\n\r\n    // Otherwise, does it have any properties of its own?\r\n    // Note that this doesn't handle\r\n    // toString and valueOf enumeration bugs in IE < 9\r\n    // tslint:disable-next-line:prefer-const\r\n    for (let key in obj) {\r\n      if (this.hasOwnProperty.call(obj, key)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  removeDQ(str: string): string {\r\n    return str.replace(/^\"(.*)\"$/, '$1');\r\n  }\r\n\r\n  unwrap(str: string): string {\r\n    return str.substring(1, str.length - 1);\r\n  }\r\n\r\n  wrapDQ(str: string): string {\r\n    return `\"${str}\"`;\r\n  }\r\n\r\n  wrapSQ(str: string): string {\r\n    return `'${str}'`;\r\n  }\r\n\r\n  decomposeHostPath(filename) {\r\n    let string = filename.toLowerCase();\r\n    string = string.replace('http://', '');\r\n    string = string.replace('https://', '');\r\n\r\n    const host = string.split('/')[0];\r\n    const path = string.replace(host, '');\r\n    return {\r\n      fullpath: filename,\r\n      host: host,\r\n      path: path\r\n    };\r\n  }\r\n\r\n  extend(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n    // tslint:disable-next-line:prefer-const\r\n    for (let key in source) {\r\n      if (this.hasOwnProperty.call(source, key)) {\r\n        target[key] = source[key];\r\n      }\r\n    }\r\n    return target;\r\n  }\r\n\r\n  mixin(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n    if (!target) {\r\n      return source;\r\n    }\r\n\r\n    for (const key of source) {\r\n      target[key] = source[key];\r\n    }\r\n    return target;\r\n  }\r\n\r\n  mixExact(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n    if (!target) {\r\n      return source;\r\n    }\r\n    for (const key in source) {\r\n      if (foTools.hasOwnProperty.call(target, key)) {\r\n        target[key] = source[key];\r\n      }\r\n    }\r\n    return target;\r\n  }\r\n\r\n  mixout(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n    if (!target) {\r\n      return source;\r\n    }\r\n    for (const key in source) {\r\n      if (this.hasOwnProperty.call(target, key)) {\r\n        delete target[key];\r\n      }\r\n    }\r\n    return target;\r\n  }\r\n\r\n  extract(target, keys?: string[]) {\r\n    const spec = {};\r\n    keys &&\r\n      keys.forEach(key => {\r\n        spec[key] = target[key];\r\n      });\r\n    return spec;\r\n  }\r\n\r\n  mixMap(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n\r\n    let result = {};\r\n    for (let key in target) {\r\n      const keyMap = source[key] || key;\r\n      result[keyMap] = target[key];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  intersect(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n    if (!target) {\r\n      return source;\r\n    }\r\n    const intersect = {};\r\n    for (const key in target) {\r\n      if (this.hasOwnProperty.call(source, key)) {\r\n        intersect[key] = source[key];\r\n      } else {\r\n        intersect[key] = target[key];\r\n      }\r\n    }\r\n    return intersect;\r\n  }\r\n\r\n  union(target, source) {\r\n    const result = {};\r\n    if (target) {\r\n      for (let key in target) {\r\n        result[key] = target[key];\r\n      }\r\n    }\r\n    if (source) {\r\n      for (let key in source) {\r\n        result[key] = source[key];\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  defineComputeOnlyProperty(target, name, func) {\r\n    //var self = target;\r\n    Object.defineProperty(target, name, {\r\n      enumerable: true,\r\n      configurable: true,\r\n      get: func\r\n    });\r\n    return target;\r\n  }\r\n\r\n  defineCalculatedProperty(target, name, func) {\r\n    //var self = target;\r\n    Object.defineProperty(target, name, {\r\n      enumerable: true,\r\n      configurable: true,\r\n      get: func, //.call(self, self),\r\n      set: function(value) {\r\n        this[`_${name}`] = value;\r\n      }\r\n    });\r\n    return target;\r\n  }\r\n\r\n  getMethods(obj) {\r\n    const list = [];\r\n    for (const m in obj.prototype) {\r\n      if (typeof obj[m] === 'function') {\r\n        list.push(m);\r\n      }\r\n    }\r\n    return list;\r\n  }\r\n\r\n  asArray(obj, funct?) {\r\n    if (this.isArray(obj)) {\r\n      return obj;\r\n    }\r\n    return this.mapOverKeyValue(obj, function(key, value) {\r\n      return funct ? funct(key, value) : value;\r\n    });\r\n  }\r\n\r\n  applyOverKeyValue(obj, mapFunc) {\r\n    //funct has 2 args.. key,value\r\n    const body = {};\r\n    const keys = obj ? Object.keys(obj) : [];\r\n    keys.forEach(key => {\r\n      if (this.hasOwnProperty.call(obj, key)) {\r\n        const value = obj[key];\r\n        const result = mapFunc(key, value);\r\n        if (result) {\r\n          body[key] = result;\r\n        }\r\n      }\r\n    });\r\n    return body;\r\n  }\r\n\r\n  mapOverKeyValue(obj, mapFunc) {\r\n    //funct has 2 args.. key,value\r\n    const list = [];\r\n    const keys = obj ? Object.keys(obj) : [];\r\n    keys.forEach(key => {\r\n      if (this.hasOwnProperty.call(obj, key)) {\r\n        const value = obj[key];\r\n        const result = mapFunc(key, value);\r\n        if (result) {\r\n          list.push(result);\r\n        }\r\n      }\r\n    });\r\n    return list;\r\n  }\r\n\r\n  forEachKeyValue(obj, mapFunc) {\r\n    //funct has 2 args.. key,value\r\n    const keys = obj ? Object.keys(obj) : [];\r\n    keys.forEach(key => {\r\n      if (this.hasOwnProperty.call(obj, key)) {\r\n        const value = obj[key];\r\n        mapFunc(key, value);\r\n      }\r\n    });\r\n  }\r\n\r\n  findKeyForValue(obj, key) {\r\n    for (const name in obj) {\r\n      if (this.hasOwnProperty.call(obj, key)) {\r\n        if (obj[name].matches(key)) {\r\n          return name;\r\n        }\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n\r\n  extractReadWriteKeys(spec) {\r\n    const keys: string[] = [];\r\n    Tools.forEachKeyValue(spec, (k, v) => {\r\n      if (!Tools.isFunction(v)) {\r\n        keys.push(k);\r\n      }\r\n    });\r\n    return keys;\r\n  }\r\n\r\n  extractComputedKeys(spec) {\r\n    const keys: string[] = [];\r\n    Tools.forEachKeyValue(spec, (k, v) => {\r\n      if (Tools.isFunction(v)) {\r\n        keys.push(k);\r\n      }\r\n    });\r\n    return keys;\r\n  }\r\n\r\n  overrideComputed(obj: any, properties: any) {\r\n    Tools.forEachKeyValue(properties, (key, value) => {\r\n      try {\r\n        if (Tools.isFunction(value)) {\r\n          Tools.defineCalculatedProperty(obj, key, value);\r\n        } else {\r\n          obj[key] = value;\r\n        }\r\n      } catch (ex) {\r\n        console.log(ex);\r\n      }\r\n    });\r\n  }\r\n\r\n  extendComputed(obj: any, properties: any) {\r\n    Tools.forEachKeyValue(properties, (key, value) => {\r\n      try {\r\n        if (!obj[key]) {\r\n          if (Tools.isFunction(value)) {\r\n            Tools.defineCalculatedProperty(obj, key, value);\r\n          } else {\r\n            obj[key] = value;\r\n          }\r\n        }\r\n      } catch (ex) {\r\n        console.log(ex);\r\n      }\r\n    });\r\n  }\r\n\r\n  pluck(name) {\r\n    return function(x) {\r\n      return x[name];\r\n    };\r\n  }\r\n\r\n  distinctItems(list) {\r\n    const distinct = {};\r\n    list.forEach(item => {\r\n      distinct[item] = item;\r\n    });\r\n    return Object.keys(distinct);\r\n  }\r\n\r\n  groupBy(pluckBy, list) {\r\n    const dictionary = {};\r\n    list.forEach(item => {\r\n      const key = pluckBy(item);\r\n      if (!dictionary[key]) {\r\n        dictionary[key] = [];\r\n      }\r\n      dictionary[key].push(item);\r\n    });\r\n    return dictionary;\r\n  }\r\n\r\n  //add this to new service to dynamicaly load javascript,  maybe over signalR\r\n\r\n  // xmlHttpGet(url:string, onComplete, onFailure) {\r\n  //     let xmlHttp = new window.XMLHttpRequest();\r\n  //     xmlHttp.onload = function () {\r\n  //        let result = xmlHttp.responseText;\r\n  //         onComplete && onComplete(result, xmlHttp);\r\n  //     };\r\n  //     try {\r\n  //         xmlHttp.open(\"GET\", url, false);  //this may give chrome some problems\r\n  //         xmlHttp.send(null);\r\n  //     }\r\n  //     catch (ex) {\r\n  //         onFailure && onFailure(ex, xmlHttp);\r\n  //     }\r\n  // }\r\n  // loadAsScript(url:string, onComplete) {\r\n  //     this.xmlHttpGet(url, function (text, xhr) {\r\n  //         if (xhr.status == 200 || xhr.status == 304) {\r\n  //            let head = document.getElementsByTagName(\"head\")[0];\r\n  //            let script = document.createElement('script');\r\n  //             script.innerHTML = text;\r\n  //             head.appendChild(script);\r\n  //             onComplete && onComplete(script);\r\n  //         }\r\n  //     });\r\n  //}\r\n}\r\n\r\nexport let Tools: foTools = new foTools();\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foLifecycle.ts",["118"],"import { Action } from './foInterface';\r\nimport { foObject } from './foObject.model';\r\nimport { Tools } from './foTools';\r\n\r\n// https://github.com/ReactiveX/rxjs/blob/master/docs_app/content/guide/v6/migration.md\r\nimport { Observable, Subject } from 'rxjs';\r\nimport { debounceTime, filter } from 'rxjs/operators';\r\n\r\nlet counter = 0;\r\nexport enum LifecycleEventTypes {\r\n  primitive,\r\n  defined,\r\n  created,\r\n  destroyed,\r\n}\r\n\r\nexport class foLifecycleEvent {\r\n  id: number = 0;\r\n  cmd: string = '';\r\n  object: foObject;\r\n  value: any;\r\n\r\n  get guid() {\r\n    return this.object.myGuid;\r\n  }\r\n  get simpleGuid() {\r\n    return this.object.myGuid.slice(-8);\r\n  }\r\n  get myGuid() {\r\n    return this.object.myGuid;\r\n  }\r\n  get myType() {\r\n    return this.object.myType;\r\n  }\r\n\r\n  get myClass() {\r\n    return this.object['myClass'];\r\n  }\r\n\r\n  get myName() {\r\n    return this.object.myName;\r\n  }\r\n\r\n  isNamed(name: string) {\r\n    return Tools.matches(name, this.myName);\r\n  }\r\n\r\n  isCmd(cmd: string) {\r\n    return Tools.matches(cmd, this.cmd);\r\n  }\r\n\r\n  constructor(cmd: string, obj: foObject, count: number = 0, value?: any) {\r\n    this.id = count;\r\n    this.cmd = cmd;\r\n    this.object = obj;\r\n    this.value = value;\r\n  }\r\n}\r\n\r\n//this is needed to prevent circular communiation\r\n// create => create => create across browsers\r\nexport class foLifecycleEventLock {\r\n  private _processLock = {};\r\n\r\n  isLocked(guid: string) {\r\n    return this._processLock[guid] ? true : false;\r\n  }\r\n\r\n  addLock(guid: string) {\r\n    if (!this.isLocked(guid)) {\r\n      this._processLock[guid] = 0;\r\n    }\r\n    this._processLock[guid] += 1;\r\n  }\r\n\r\n  unLock(guid: string) {\r\n    if (this.isLocked(guid)) {\r\n      this._processLock[guid] -= 1;\r\n      if (this._processLock[guid] <= 0) {\r\n        delete this._processLock[guid];\r\n      }\r\n    }\r\n  }\r\n\r\n  protected(guid: string, context: any, func: Action<any>) {\r\n    this.addLock(guid);\r\n    try {\r\n      func(context);\r\n    } catch (ex) {\r\n      console.error('protected', ex);\r\n    }\r\n    this.unLock(guid);\r\n  }\r\n\r\n  whenUnprotected(guid: string, context: any, func: Action<any>) {\r\n    if (!this.isLocked(guid)) {\r\n      try {\r\n        func(context);\r\n      } catch (ex) {\r\n        console.error('whenUnprotected ', ex);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport let LifecycleLock: foLifecycleEventLock = new foLifecycleEventLock();\r\nexport let KnowcycleLock: foLifecycleEventLock = new foLifecycleEventLock();\r\n\r\n\r\n\r\nexport class foLifecycle {\r\n  mute: boolean = false;\r\n\r\n  public observable: Observable<foLifecycleEvent>;\r\n  public emit: Subject<foLifecycleEvent>;\r\n\r\n  private debounced: Subject<foLifecycleEvent>;\r\n\r\n  constructor(debouce: number = 500) {\r\n    this.emit = new Subject<foLifecycleEvent>();\r\n    this.observable = this.emit.asObservable();\r\n\r\n    this.debounced = new Subject<foLifecycleEvent>();\r\n\r\n    this.debounced\r\n      .asObservable()\r\n      .pipe(debounceTime(debouce))\r\n      .subscribe(event => {\r\n        event.id = counter++;\r\n        this.broadcast(event);\r\n      });\r\n  }\r\n\r\n  broadcast(obj: foLifecycleEvent) {\r\n    !this.mute && this.emit.next(obj);\r\n    return this;\r\n  }\r\n\r\n  primitive(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('primitive', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  defined(obj?: foObject) {\r\n    this.broadcast(new foLifecycleEvent('defined', obj, counter++));\r\n    return this;\r\n  }\r\n\r\n  event(eventName: string, obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent(eventName, obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  created(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('created', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  destroyed(obj: foObject) {\r\n    this.broadcast(new foLifecycleEvent('destroyed', obj, counter++));\r\n    return this;\r\n  }\r\n\r\n  unparent(obj: foObject) {\r\n    this.broadcast(new foLifecycleEvent('unparent', obj, counter++));\r\n    return this;\r\n  }\r\n\r\n  reparent(obj: foObject) {\r\n    this.broadcast(new foLifecycleEvent('reparent', obj, counter++));\r\n    return this;\r\n  }\r\n\r\n  action(obj: foObject, action: string, params?: any) {\r\n    this.broadcast(\r\n      new foLifecycleEvent('run', obj, counter++, {\r\n        action: action,\r\n        params: params\r\n      })\r\n    );\r\n    return this;\r\n  }\r\n\r\n  command(obj: foObject, method: string) {\r\n    this.broadcast(new foLifecycleEvent('command', obj, counter++, method));\r\n    return this;\r\n  }\r\n\r\n  selected(obj: foObject, value: any) {\r\n    this.broadcast(new foLifecycleEvent('selected', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  pageSelections(obj: foObject, value: any) {\r\n    this.broadcast(new foLifecycleEvent('pageselections', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  layout(obj: foObject, value: any) {\r\n    this.broadcast(new foLifecycleEvent('layout', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  changed(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('changed', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  glued(obj: foObject, value: any) {\r\n    this.broadcast(new foLifecycleEvent('glued', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  unglued(obj: foObject, value: any) {\r\n    this.broadcast(new foLifecycleEvent('unglued', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  dropped(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('dropped', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  handle(obj: foObject, value?: any) {\r\n    this.debounced.next(new foLifecycleEvent('handle', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  moved(obj: foObject, value?: any) {\r\n    this.debounced.next(new foLifecycleEvent('moved', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  easeTo(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('easeTo', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  easeTween(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('easeTween', obj, counter++, value));\r\n    return this;\r\n  }\r\n}\r\n\r\nexport let Lifecycle: foLifecycle = new foLifecycle(300);\r\nexport let Knowcycle: foLifecycle = new foLifecycle();\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foObject.model.ts",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foMatrix2D.ts",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foGeometry2D.ts",["119","120"],"\r\nimport { iPoint2D, iRect, iBox, iMargin, iFrame } from './foInterface';\r\nimport { Vector2, Matrix3 } from 'three';\r\nexport { Vector2, Matrix3 } from 'three';\r\n\r\nexport class cPoint2D extends Vector2 implements iPoint2D {\r\n\r\n    public myName: string;\r\n    public x: number;\r\n    public y: number;\r\n\r\n    constructor(x: number = 0, y: number = 0, name?: string) {\r\n        super(x, y);\r\n        this.myName = name;\r\n    }\r\n\r\n    asVector(): Vector2 {\r\n        return new Vector2(this.x, this.y);\r\n    }\r\n\r\n    setValues(x: number = 0, y: number = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    clonePoint(): cPoint2D {\r\n        return new cPoint2D(this.x, this.y, this.myName);\r\n    }\r\n\r\n    isEqualTo(p: cPoint2D): boolean {\r\n        return this.x === p.x && this.y === p.y;\r\n    }\r\n\r\n    isNear(p: cPoint2D, radius: number): boolean {\r\n        const dx = Math.abs(p.x - this.x);\r\n        if (dx > radius) { return false; }\r\n\r\n        const dy = Math.abs(p.y - this.y);\r\n        if (dy > radius) { return false; }\r\n        return true;\r\n\r\n    }\r\n\r\n    addPoint(x: number = 0, y: number = 0): cPoint2D {\r\n        this.x += x;\r\n        this.y += y;\r\n        return this;\r\n    }\r\n\r\n\r\n\r\n    subtractPoint(x: number = 0, y: number = 0): cPoint2D {\r\n        this.x -= x;\r\n        this.y -= y;\r\n        return this;\r\n    }\r\n\r\n    midPoint(pt: cPoint2D): cPoint2D {\r\n        const x = (this.x + pt.x) / 2;\r\n        const y = (this.y + pt.y) / 2;\r\n        return new cPoint2D(x, y, 'midpoint');\r\n    }\r\n\r\n    mag(): number {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y);\r\n    }\r\n\r\n    atan(): number {\r\n        return Math.atan2(this.y,  this.x);\r\n    }\r\n\r\n    normal(): cPoint2D {\r\n        let mag = this.mag();\r\n        mag = mag ? mag : 1.0; //if zero set to 1 you get the same result\r\n        return new cPoint2D(this.x / mag, this.y / mag, 'normal');\r\n    }\r\n\r\n    sum(p: cPoint2D): cPoint2D {\r\n        this.x += p.x;\r\n        this.y += p.y;\r\n        return this;\r\n    }\r\n\r\n    sumTo(p: cPoint2D): cPoint2D {\r\n        p.x += this.x;\r\n        p.y += this.y;\r\n        return p;\r\n    }\r\n\r\n    setTo(p: cPoint2D): cPoint2D {\r\n        p.x = this.x;\r\n        p.y = this.y;\r\n        return p;\r\n    }\r\n\r\n    subtract(p: cPoint2D): cPoint2D {\r\n        this.x -= p.x;\r\n        this.y -= p.y;\r\n        return this;\r\n    }\r\n\r\n    deltaBetween(pt: cPoint2D): cPoint2D {\r\n        const x = this.x - pt.x;\r\n        const y = this.y - pt.y;\r\n        return new cPoint2D(x, y, 'delta');\r\n    }\r\n\r\n    scale(s: number): cPoint2D {\r\n        this.x *= s;\r\n        this.y *= s;\r\n        return this;\r\n    }\r\n}\r\n\r\nexport class cRect implements iRect {\r\n    public x: number;\r\n    public y: number;\r\n    public width: number;\r\n    public height: number;\r\n    public myName: string;\r\n\r\n    constructor(x: number, y: number, width: number, height: number, name?: string) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.myName = name;\r\n    }\r\n\r\n    moveBy(x: number = 0, y: number = 0): iRect {\r\n        this.x += x;\r\n        this.y += y;\r\n        return this;\r\n    }\r\n\r\n    moveTo(x: number = 0, y: number = 0): iRect {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    sizeBy(width: number, height: number): iRect {\r\n        this.width += width;\r\n        this.height += height;\r\n        return this;\r\n    }\r\n\r\n    sizeTo(width: number, height: number): iRect {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    set(x: number, y: number, width: number, height: number): iRect {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    contains(x: number, y: number) {\r\n        return this.x <= x && x <= this.x + this.width && this.y <= y && y <= this.y + this.height;\r\n    }\r\n\r\n    localContains(x: number, y: number): boolean {\r\n        return 0 <= x && x <= this.width && 0 <= y && y <= this.height;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, fill?: boolean) {\r\n        if (fill) {\r\n            ctx.fillRect(this.x, this.y, this.width, this.height);\r\n        } else {\r\n            ctx.rect(this.x, this.y, this.width, this.height);\r\n        }\r\n        return this;\r\n    }\r\n}\r\n\r\n\r\nexport class cFrame implements iFrame {\r\n    public x1: number;\r\n    public y1: number;\r\n    public x2: number;\r\n    public y2: number;\r\n\r\n    public point: cPoint2D = new cPoint2D();\r\n    public source: any;\r\n\r\n    constructor(source?: any) {\r\n        this.source = source;\r\n    }\r\n\r\n    set(x1: number, y1: number, x2: number, y2: number): iFrame {\r\n        this.x1 = x1;\r\n        this.y1 = y1;\r\n        this.x2 = x2;\r\n        this.y2 = y2;\r\n        return this;\r\n    }\r\n\r\n    width(): number {\r\n        return this.x2 - this.x1;\r\n    }\r\n\r\n    heigth(): number {\r\n        return this.y2 - this.y1;\r\n    }\r\n\r\n    centerX(): number {\r\n        return (this.x2 + this.x1) / 2.0;\r\n    }\r\n\r\n    centerY(): number {\r\n        return (this.y2 + this.y1) / 2.0;\r\n    }\r\n\r\n    init(obj: iPoint2D): iFrame {\r\n        this.x1 = obj.x;\r\n        this.y1 = obj.y;\r\n        this.x2 = obj.x;\r\n        this.y2 = obj.y;\r\n        return this;\r\n    }\r\n\r\n    merge(obj: iFrame): iFrame {\r\n        this.x1 = Math.min(this.x1, obj.x1, obj.x2);\r\n        this.y1 = Math.min(this.y1, obj.y1, obj.y2);\r\n        this.x2 = Math.max(this.x2, obj.x2, obj.x1);\r\n        this.y2 = Math.max(this.y2, obj.y2, obj.y1);\r\n        return this;\r\n    }\r\n\r\n    minmax(obj: iPoint2D): iFrame {\r\n        this.x1 = Math.min(this.x1, obj.x);\r\n        this.y1 = Math.min(this.y1, obj.y);\r\n        this.x2 = Math.max(this.x2, obj.x);\r\n        this.y2 = Math.max(this.y2, obj.y);\r\n        return this;\r\n    }\r\n\r\n    contains(x: number, y: number) {\r\n        return this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, fill?: boolean) {\r\n        const width = this.x2 - this.x1;\r\n        const height = this.y2 - this.y1;\r\n        if (fill) {\r\n            ctx.fillRect(this.x1, this.y1, width, height);\r\n        } else {\r\n            ctx.rect(this.x1, this.y1, width, height);\r\n        }\r\n        return this;\r\n    }\r\n}\r\n\r\nexport class cMargin implements iMargin {\r\n    public left: number = 0;\r\n    public top: number = 0;\r\n    public right: number = 0;\r\n    public bottom: number = 0;\r\n\r\n\r\n    constructor(left: number = 0, top: number = 0, right: number = 0, bottom: number = 0) {\r\n        this.left = left;\r\n        this.top = top;\r\n        this.right = right;\r\n        this.bottom = bottom;\r\n    }\r\n\r\n    setAll(size: number = 0) {\r\n        this.left = size;\r\n        this.top = size;\r\n        this.right = size;\r\n        this.bottom = size;\r\n        return this;\r\n    }\r\n\r\n    get width() {\r\n        return this.left + this.right;\r\n    }\r\n    get height() {\r\n        return this.top + this.bottom;\r\n    }\r\n}\r\n\r\nexport class cBox extends cRect implements iBox {\r\n\r\n    constructor(x: number, y: number, width: number, height: number, name?: string) {\r\n        super(x, y, width, height, name);\r\n    }\r\n\r\n    pinX(): number {\r\n        return 0 * this.width;\r\n    }\r\n\r\n    pinY(): number {\r\n        return 0 * this.height;\r\n    }\r\n\r\n\r\n    draw(ctx: CanvasRenderingContext2D, fill?: boolean) {\r\n        if (fill) {\r\n            ctx.fillRect(this.x, this.y, this.width, this.height);\r\n        } else {\r\n            ctx.rect(this.x, this.y, this.width, this.height);\r\n        }\r\n        return this;\r\n    }\r\n}\r\n",["121","122"],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foShape2D.model.ts",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foPubSub.ts",[],["123","124"],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foCollection.model.ts",["125"],"import { Tools } from './foTools';\r\nimport { foObject } from './foObject.model';\r\nimport { iObject, Action, Func } from './foInterface';\r\n\r\n//we want foCollection to be observable\r\n\r\nexport class foCollection<T extends iObject> extends foObject {\r\n  protected _members: Array<T>;\r\n\r\n  isHidden: boolean = false;\r\n  isSelectable: boolean = true;\r\n  constructor(list?: Array<T>) {\r\n    super();\r\n\r\n    this._members = new Array<T>();\r\n    list && list.forEach(item => this.addMember(item));\r\n  }\r\n\r\n  getChildAt(i: number): T {\r\n    return this._members[i];\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this._members.length === 0;\r\n  }\r\n\r\n  clearAll() {\r\n    this._members = [];\r\n  }\r\n\r\n  get length() {\r\n    return this._members.length;\r\n  }\r\n\r\n  get count() {\r\n    return this._members.length;\r\n  }\r\n\r\n  get hasMembers(): boolean {\r\n    return this.length > 0;\r\n  }\r\n\r\n  map(funct) {\r\n    return this._members.map(funct);\r\n  }\r\n\r\n  forEach(funct: Action<T>) {\r\n    this._members.forEach(funct);\r\n  }\r\n\r\n  first() {\r\n    return this._members[0];\r\n  }\r\n\r\n  last() {\r\n    return this._members[this._members.length - 1];\r\n  }\r\n\r\n  filter(funct: Func<T, boolean>) {\r\n    return this._members.filter(funct);\r\n  }\r\n\r\n  find(funct: Func<T, boolean>) {\r\n    return this._members.find(funct);\r\n  }\r\n\r\n  findMember(name: string): T {\r\n    const found = this._members.find(item => {\r\n      return item.myName === name || item.myGuid === name;\r\n    });\r\n    return found;\r\n  }\r\n\r\n  getMember(id): T {\r\n    return this._members[id];\r\n  }\r\n\r\n  copyMembers(list: foCollection<T>): foCollection<T> {\r\n    list.members.forEach(item => {\r\n      this.addMember(item);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  isMember(item: T) {\r\n    const loc = this._members.indexOf(item);\r\n    return loc !== -1;\r\n  }\r\n\r\n  push(obj: any) {\r\n    this._members.push(obj);\r\n  }\r\n  shift(): any {\r\n    return this._members.shift();\r\n  }\r\n\r\n  addMember(obj: T): T {\r\n    this._members.push(obj);\r\n    return obj;\r\n  }\r\n\r\n  removeMembers(list: foCollection<T>): foCollection<T> {\r\n    list.members.forEach(item => {\r\n      this.removeMember(item);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  removeMember(obj: T): T {\r\n    const index = this._members.indexOf(obj);\r\n    if (index > -1) {\r\n      this._members.splice(index, 1);\r\n    }\r\n    return obj;\r\n  }\r\n\r\n  get members() {\r\n    return this._members;\r\n  }\r\n\r\n  get publicMembers() {\r\n    return this.members.filter(item => item.isPublic);\r\n  }\r\n\r\n  moveToTop(item: T) {\r\n    const loc = this._members.indexOf(item);\r\n    if (loc !== -1) {\r\n      this._members.splice(loc, 1);\r\n      this._members.push(item);\r\n    }\r\n    return this._members;\r\n  }\r\n\r\n  moveToBottom(item: T) {\r\n    const loc = this._members.indexOf(item);\r\n    if (loc !== -1) {\r\n      this._members.splice(loc, 1);\r\n      this._members.unshift(item);\r\n    }\r\n    return this._members;\r\n  }\r\n\r\n  protected toJson(): any {\r\n    if ( this.hasMembers ) {\r\n      const local = super.toJson();\r\n      local.members = this._members.map(item => item.asJson);\r\n      return local;\r\n    }\r\n    return {};\r\n  }\r\n\r\n  public isEqualTo(obj: foCollection<T>, deep: boolean = true) {\r\n    const result = true;\r\n    return result;\r\n  }\r\n}\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foText2D.model.ts",["126","127"],"import { Tools } from './foTools';\r\nimport { cMargin } from './foGeometry2D';\r\n\r\nimport { foObject } from './foObject.model';\r\nimport { foGlyph2D } from './foGlyph2D.model';\r\n\r\nimport { foShape2D, IfoShape2DProperties } from './foShape2D.model';\r\n\r\nimport { foUnDo } from './foUnDo';\r\n\r\nimport { RuntimeType } from './foRuntimeType';\r\n\r\n// ctx.textAlign = \"left\" || \"right\" || \"center\" || \"start\" || \"end\";\r\n\r\n// ctx.textBaseline = \"top\" || \"hanging\" || \"middle\" || \"alphabetic\" || \"ideographic\" || \"bottom\";\r\n\r\n// ctx.font = '48px serif';\r\n// ctx.font = \"20px Georgia\";\r\n// ctx.font = \"italic 10pt Courier\";\r\n// ctx.font = \"bold 10pt Courier\";\r\n// ctx.font = \"italic bold 10pt Courier\";\r\n\r\nexport interface IfoText2DProperties extends IfoShape2DProperties {\r\n  text?: string;\r\n  fontSize?: number;\r\n  font?: string;\r\n\r\n  background?: string;\r\n}\r\n\r\n//a Shape is a graphic designed to behave like a visio shape\r\n//and have all the same properties\r\nexport class foText2D extends foShape2D implements IfoText2DProperties {\r\n  public text: string;\r\n  public textAlign: string;\r\n  public textBaseline: string;\r\n\r\n  public margin: cMargin;\r\n  public fontSize: number;\r\n  public font: string;\r\n  public resize: boolean = false;\r\n\r\n  protected _background: string;\r\n  get background(): string {\r\n    return this._background || this.color;\r\n  }\r\n  set background(value: string) {\r\n    this._background = value;\r\n  }\r\n\r\n  public pinX = (): number => {\r\n    return 0.5 * this.width;\r\n  }\r\n  public pinY = (): number => {\r\n    return 0.5 * this.height;\r\n  }\r\n\r\n  constructor(\r\n    properties?: IfoText2DProperties,\r\n    parent?: foObject\r\n  ) {\r\n    super(properties, parent);\r\n\r\n    this.override(properties);\r\n    this.setupPreDraw();\r\n  }\r\n\r\n  protected toJson(): any {\r\n    return Tools.mixin(super.toJson(), {\r\n      text: this.text,\r\n      background: this.background,\r\n      fontSize: this.fontSize,\r\n      margin: this.margin\r\n    });\r\n  }\r\n\r\n  get size(): number {\r\n    return this.fontSize || 12;\r\n  }\r\n\r\n  updateContext(ctx: CanvasRenderingContext2D) {\r\n    super.updateContext(ctx);\r\n\r\n    this.drawFont(ctx, this.size, this.font, this.textAlign, this.textBaseline);\r\n  }\r\n\r\n  setupPreDraw() {\r\n    const preDraw = (ctx: CanvasRenderingContext2D): void => {\r\n      if (this.resize) {\r\n        const textMetrics = ctx.measureText(this.text);\r\n        this.width = textMetrics.width + ((this.margin && this.margin.width) || 0);\r\n        this.height = this.size + ((this.margin && this.margin.height) || 0);\r\n      }\r\n      //this.createConnectionPoints();\r\n      //this.createHandles();\r\n      this.preDraw = undefined;\r\n    };\r\n\r\n    this.preDraw = preDraw;\r\n  }\r\n\r\n  public splitText(ctx: CanvasRenderingContext2D, text: string, maxWidth: number): Array<string> {\r\n    const result: Array<string> = new Array<string>();\r\n    const words = text.replace(':', ': ').split(' ');\r\n\r\n    let firstWord = words[0];\r\n    let size = ctx.measureText(firstWord);\r\n    const perChar = size.width / firstWord.length;\r\n    const maxChar = Math.ceil(maxWidth / perChar) - 3;\r\n\r\n    //fill result based on running size\r\n    let phrase = '';\r\n    words.forEach(word => {\r\n      if (phrase.length + word.length + 1 <= maxChar) {\r\n        phrase += ` ${word}`;\r\n      } else {\r\n        result.push(phrase);\r\n        phrase = `${word}`;\r\n      }\r\n    });\r\n    result.push(phrase);\r\n\r\n    return result;\r\n  }\r\n\r\n  public drawOutline(ctx: CanvasRenderingContext2D) {\r\n    ctx.beginPath();\r\n    ctx.setLineDash([15, 5]);\r\n    ctx.rect(0, 0, this.width, this.height);\r\n    ctx.stroke();\r\n  }\r\n\r\n  public drawDefaultSelected(ctx: CanvasRenderingContext2D) {\r\n    ctx.strokeStyle = 'red';\r\n    ctx.lineWidth = 1;\r\n    this.drawOutline(ctx);\r\n    //this.drawHandles(ctx);\r\n    //this.drawConnectionPoints(ctx);\r\n    this.drawPin(ctx);\r\n  }\r\n\r\n  public drawSelected = this.drawDefaultSelected;\r\n\r\n  public drawBackground = (ctx: CanvasRenderingContext2D): void => {\r\n    ctx.fillStyle = this.background;\r\n    ctx.fillRect(0, 0, this.width, this.height);\r\n  }\r\n\r\n  public maxTextWidth() {\r\n    return this.width;\r\n  }\r\n\r\n  public drawTextBox(ctx: CanvasRenderingContext2D, text: string) {\r\n    const left = (this.margin && this.margin.left) || 0;\r\n    const top = (this.margin && this.margin.top) || 0;\r\n    \r\n    // let x = this.pinX() + left;\r\n    let x = this.width/2 +  left;\r\n\r\n    //let y = this.pinY() + top;\r\n    let y = this.height/2 + top;\r\n\r\n    let dy = this.size + 4;\r\n\r\n    let list = this.splitText(ctx, text, this.maxTextWidth());\r\n    y -= (list.length / 2) * dy;\r\n    list.forEach(txt => {\r\n      this.drawText(ctx, txt, x, y);\r\n      y += dy; //rule of thumb to prevent true measure\r\n    });\r\n  }\r\n\r\n  public draw = (ctx: CanvasRenderingContext2D): void => {\r\n\r\n    ctx.save();\r\n\r\n    if (this.background) {\r\n      this.drawBackground(ctx);\r\n    }\r\n\r\n    ctx.fillStyle = this.color;\r\n\r\n    this.drawTextBox(ctx, this.text);\r\n    //this.drawTextCircle(ctx, this.text.toUpperCase(), 0.46 * this.width, 0, this.pinX(), this.pinY());\r\n\r\n    ctx.restore();\r\n  }\r\n}\r\n\r\nexport class foInputText2D extends foText2D {\r\n  private UnDo: foUnDo = new foUnDo();\r\n  private isEditing: boolean = false;\r\n  private showCursor: boolean = false;\r\n  private cursorStart: number;\r\n  private cursorEnd: number;\r\n\r\n  private timer: any;\r\n  private undoRoot: any;\r\n  private initState: any;\r\n\r\n  private setState(state: any) {\r\n    this.text = state.text;\r\n    this.cursorStart = state.start;\r\n    this.cursorEnd = state.end;\r\n  }\r\n\r\n  private getState() {\r\n    return { text: this.text, start: this.cursorStart, end: this.cursorEnd };\r\n  }\r\n\r\n  public doubleClick = (keys: any) => {\r\n  }\r\n\r\n  public openEditor = () => {\r\n    this.isEditing = true;\r\n    this.drawSelected = this.drawIsEditing;\r\n    this.timer = setInterval(() => {\r\n      this.showCursor = !this.showCursor;\r\n    }, 600);\r\n    this.cursorStart = this.cursorEnd = this.text.length;\r\n    this.initState = this.getState();\r\n\r\n    this.UnDo.registerActions(\r\n      'shapeTextChanged',\r\n      p => {\r\n        return p;\r\n      },\r\n      p => {\r\n        return p;\r\n      },\r\n      (o, n) => {\r\n        return o !== n;\r\n      }\r\n    );\r\n  }\r\n\r\n  public closeEditor = () => {\r\n    this.isEditing = false;\r\n    this.drawSelected = this.drawDefaultSelected;\r\n    clearInterval(this.timer);\r\n    this.UnDo.clear();\r\n  }\r\n\r\n  public addCharacter(char) {\r\n    const state = this.getState();\r\n    if (this.UnDo.verifyKeep(this.undoRoot, state)) {\r\n      this.undoRoot = this.UnDo.do('shapeTextChanged', state);\r\n    }\r\n\r\n    const text =\r\n      this.text.slice(0, this.cursorStart) +\r\n      char +\r\n      this.text.slice(this.cursorEnd);\r\n    this.text = text;\r\n    this.cursorStart += 1;\r\n    this.cursorEnd = this.cursorStart;\r\n  }\r\n\r\n  public delCharacter() {\r\n    if (this.cursorStart === 0) return;\r\n\r\n    const state = this.getState();\r\n    if (this.UnDo.verifyKeep(this.undoRoot, state)) {\r\n      this.undoRoot = this.UnDo.do('shapeTextChanged', state);\r\n    }\r\n\r\n    const text =\r\n      this.text.slice(0, this.cursorStart - 1) +\r\n      this.text.slice(this.cursorEnd);\r\n    this.text = text;\r\n    this.cursorStart -= 1;\r\n    this.cursorEnd = this.cursorStart;\r\n  }\r\n\r\n  public sendKeys = (e: KeyboardEvent, keys: any) => {\r\n    if (keys.ctrl && e.key === 'e') {\r\n      this.isEditing ? this.closeEditor() : this.openEditor();\r\n    } else if (keys.ctrl && e.key === 'z') {\r\n      this.UnDo.canUndo() && this.setState(this.UnDo.unDo());\r\n    } else if (this.isEditing) {\r\n      this.editText(e, keys);\r\n    }\r\n    this.setupPreDraw();\r\n  }\r\n\r\n  editText(e: KeyboardEvent, keys: any) {\r\n    if (keys.ctrl && e.key === 'a') {\r\n      this.cursorStart = 0;\r\n      this.cursorEnd = this.text.length;\r\n    } else if (keys.ctrl) {\r\n      return;\r\n    } else if (e.keyCode >= 48 && e.keyCode <= 90) {\r\n      this.addCharacter(e.key);\r\n    } else if (e.keyCode === 32) {\r\n      //space\r\n      this.addCharacter(e.key);\r\n    } else if (e.keyCode === 46) {\r\n      //del\r\n      this.delCharacter();\r\n    } else if (e.keyCode === 8) {\r\n      //backspace\r\n      this.delCharacter();\r\n    } else {\r\n      this.processKeys(e, keys);\r\n    }\r\n  }\r\n\r\n  // 27: \"esc\",\r\n  // 32: \"space\",\r\n  // 33: \"pageup\",\r\n  // 34: \"pagedown\",\r\n  // 35: \"end\",\r\n  // 36: \"home\",\r\n  // 37: \"left\",\r\n  // 38: \"up\",\r\n  // 39: \"right\",\r\n  // 45: \"insert\",\r\n  // 46: \"delete\",\r\n\r\n  processKeys(e: KeyboardEvent, keys: any) {\r\n    const select = keys.shift;\r\n    switch (e.keyCode) {\r\n      case 36: // home\r\n        this.cursorStart = 0;\r\n        if (!select) this.cursorEnd = this.cursorStart;\r\n        break;\r\n      case 35: // end\r\n        this.cursorEnd = this.text.length;\r\n        if (!select) this.cursorStart = this.cursorEnd;\r\n        break;\r\n      case 37: // left\r\n        if (this.cursorStart > 0) {\r\n          this.cursorStart -= 1;\r\n          if (!select) this.cursorEnd = this.cursorStart;\r\n        }\r\n        break;\r\n      case 39: // right\r\n        if (this.cursorEnd < this.text.length) {\r\n          this.cursorEnd += 1;\r\n          if (!select) this.cursorStart = this.cursorEnd;\r\n        }\r\n        break;\r\n      case 13: // return\r\n        this.closeEditor();\r\n        break;\r\n      case 27: // esc\r\n        this.setState(this.initState);\r\n        this.closeEditor();\r\n        break;\r\n      default:\r\n        if (e.key.length === 1) {\r\n          this.addCharacter(e.key);\r\n        }\r\n        break;\r\n    }\r\n  }\r\n\r\n  public drawIsEditing(ctx: CanvasRenderingContext2D) {\r\n    ctx.strokeStyle = 'green';\r\n    ctx.lineWidth = 1;\r\n    ctx.beginPath();\r\n    ctx.rect(0, 0, this.width, this.height);\r\n    ctx.stroke();\r\n\r\n    this.drawSelect(ctx);\r\n    this.showCursor && this.drawCursor(ctx);\r\n    this.draw(ctx);\r\n  }\r\n\r\n  public drawSelect(ctx: CanvasRenderingContext2D) {\r\n    if (this.cursorStart === this.cursorEnd) return;\r\n\r\n    const textStart = this.text.substr(0, this.cursorStart);\r\n    const start = ctx.measureText(textStart);\r\n    const startPos = start.width + ((this.margin && this.margin.width) || 0);\r\n\r\n    const textEnd = this.text.substr(0, this.cursorEnd);\r\n    const end = ctx.measureText(textEnd);\r\n    const endPos = end.width + ((this.margin && this.margin.width) || 0);\r\n\r\n    ctx.fillStyle = 'yellow';\r\n    ctx.fillRect(startPos, 0, endPos - startPos, this.height);\r\n  }\r\n\r\n  public drawCursor(ctx: CanvasRenderingContext2D) {\r\n    const textStart = this.text.substr(0, this.cursorStart);\r\n    const start = ctx.measureText(textStart);\r\n    const startPos = start.width + ((this.margin && this.margin.width) || 0);\r\n\r\n    ctx.fillStyle = 'red';\r\n    ctx.fillRect(startPos, 0, 2, this.height);\r\n  }\r\n\r\n  // drawMultiLineText(ctx: CanvasRenderingContext2D, text: string) {\r\n\r\n  //     //let textMetrics = ctx.measureText(text);\r\n\r\n  //     ctx.textAlign = \"left\" || \"right\" || \"center\" || \"start\" || \"end\";\r\n\r\n  //     ctx.textBaseline = \"top\" || \"hanging\" || \"middle\" || \"alphabetic\" || \"ideographic\" || \"bottom\";\r\n\r\n  //     ctx.font = '48px serif';\r\n  //     ctx.font = \"20px Georgia\";\r\n  //     ctx.font = \"italic 10pt Courier\";\r\n  //     ctx.font = \"bold 10pt Courier\";\r\n  //     ctx.font = \"italic bold 10pt Courier\";\r\n\r\n  //     //http://junerockwell.com/end-of-line-or-line-break-in-html5-canvas/\r\n  //     let fontsize = 60;\r\n  //     let array = text.split('|');\r\n  //     let dx = 10;\r\n  //     let dy = 20;\r\n  //     for (var i = 0; i < array.length; i++) {\r\n  //         ctx.fillText(array[i], dx, dy);\r\n  //         dy += (fontsize + 4);\r\n  //     }\r\n\r\n  // }\r\n}\r\n\r\n\r\n//RuntimeType.define(foText2D);\r\n//RuntimeType.define(foInputText2D);\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foUnDo.ts",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\PaintTest2.tsx",["128","129","130"],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\PaintTest3.tsx",["131","132","133"],"// https://medium.com/@pdx.lucasm/canvas-with-react-js-32e133c05258\r\n// https://github.com/elchininet/ColorTranslator\r\n\r\n// https://elchininet.github.io/ColorTranslator/\r\n\r\nimport { Canvas } from 'Canvas';\r\nimport { foObject } from 'foundry/models/foObject.model';\r\nimport { foPage } from 'foundry/models/foPage.model';\r\nimport { hub } from './models/hub';\r\n\r\nimport React, { FunctionComponent, ReactElement } from 'react';\r\nimport { ColorArray, LEDLight, LightArray, LightDesignPage } from 'models/lights';\r\nimport { ToJSON } from 'core/foRenderer';\r\nimport { Tools } from 'foundry/models/foTools';\r\nimport { ColorTranslator } from 'colortranslator';\r\nimport { Effect, TimeLinePage, TimeStep } from 'models/timeline';\r\n\r\nexport const PaintTest3: FunctionComponent<any> = (props: any): ReactElement => {\r\n    const sourceLED = new LEDLight();\r\n    const sourceStep = new TimeStep();\r\n\r\n    const timelinePage = new TimeLinePage({\r\n        opacity: 0.02,\r\n        color: 'white',\r\n        width: 160 * sourceStep.width,\r\n        height: 5 * sourceStep.height,\r\n        gridSizeX: sourceStep.width,\r\n        gridSizeY: sourceStep.height\r\n    });\r\n\r\n    const EffectStamp = (size: number = 20, row: number = 1, props?: any) => {\r\n        return new Effect({\r\n            total: size,\r\n            x: 0,\r\n            y: sourceStep.height * row\r\n        }).horizontal(TimeStep, props);\r\n    };\r\n\r\n    const Effect1 = EffectStamp(35, 1);\r\n    const Effect2 = EffectStamp(40, 2, { color: 'green' }).followEffect(Effect1);\r\n    const Effect3 = EffectStamp(40, 1, { color: 'yellow' }).followEffect(Effect2);\r\n    const Effect4 = EffectStamp(40, 3, { color: 'red'}).followEffect(Effect3);\r\n\r\n    timelinePage.subcomponents.addMember(Effect1);\r\n    timelinePage.subcomponents.addMember(Effect2);\r\n    timelinePage.subcomponents.addMember(Effect3);\r\n    timelinePage.subcomponents.addMember(Effect4);\r\n    const timelineCanvasParams = {\r\n        width: timelinePage.width,\r\n        height: timelinePage.height,\r\n        title: 'Timeline Canvas',\r\n        draw: (ctx: CanvasRenderingContext2D, count: number) => {\r\n            timelinePage.render(ctx);\r\n            timelinePage.incrementTimecode();\r\n        }\r\n    };\r\n\r\n    const lightPage = new LightDesignPage({\r\n        opacity: 0.02,\r\n        color: 'white',\r\n        width: 71 * sourceLED.width,\r\n        height: 10 * sourceLED.height,\r\n        gridSizeX: sourceLED.width,\r\n        gridSizeY: sourceLED.height\r\n    });\r\n\r\n    const LEDStringStamp = (size: number = 20, row: number = 1, props?: any) => {\r\n        return new LightArray({\r\n            total: size,\r\n            x: lightPage.width / 2,\r\n            y: sourceStep.height * row\r\n        }).horizontal(LEDLight, props);\r\n    };\r\n\r\n    const mult = 5;\r\n    const blends = ColorTranslator.getBlendHEX('#FF00FF', '#FFFF00', mult + 10 * mult);\r\n\r\n    const ColorArrayStamp = (colors: string[], row: number = 1, props?: any) => {\r\n        return new ColorArray({\r\n            colors: colors,\r\n            x: lightPage.width / 2,\r\n            y: sourceLED.height * row\r\n        }).horizontal(LEDLight);\r\n    };\r\n\r\n    const ColorArrayV1 = ColorArrayStamp(blends, 0);\r\n    const ColorArrayV2 = ColorArrayStamp(blends, 1);\r\n    lightPage.subcomponents.addMember(ColorArrayV1);\r\n    lightPage.subcomponents.addMember(ColorArrayV2);\r\n\r\n    const LEDString1 = LEDStringStamp(25, 3);\r\n    const LEDString2 = LEDStringStamp(25, 4);\r\n    const LEDString3 = LEDStringStamp(25, 5);\r\n    const LEDString4 = LEDStringStamp(25, 6);\r\n    const LEDString5 = LEDStringStamp(25, 7);\r\n    const LEDString6 = LEDStringStamp(25, 8);\r\n    lightPage.subcomponents.addMember(LEDString1);\r\n    lightPage.subcomponents.addMember(LEDString2);\r\n    lightPage.subcomponents.addMember(LEDString3);\r\n    lightPage.subcomponents.addMember(LEDString4);\r\n    lightPage.subcomponents.addMember(LEDString5);\r\n    lightPage.subcomponents.addMember(LEDString6);\r\n\r\n    const lightCanvasParams = {\r\n        width: lightPage.width,\r\n        height: lightPage.height,\r\n        title: 'Light Canvas',\r\n        draw: (ctx: CanvasRenderingContext2D, count: number) => {\r\n            lightPage.render(ctx);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <div>\r\n            <Canvas {...timelineCanvasParams} />\r\n            <Canvas {...lightCanvasParams} />\r\n            <ToJSON {...Tools.asJson(ColorArrayV1)} />\r\n        </div>\r\n    );\r\n};\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\models\\lights.ts",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\models\\timeline.ts",["134","135"],"import { foObject } from \"foundry/models/foObject.model\";\r\nimport { foPage } from \"foundry/models/foPage.model\";\r\nimport { foShape2D, IfoShape2DProperties } from \"foundry/models/foShape2D.model\";\r\nimport { Effect } from \"./effect\";\r\nimport { rxPubSub } from \"./rxPubSub\";\r\n\r\nexport class TimeLinePage extends foPage {\r\n    timeCode: number = 0;\r\n    timeDelay: number = 10; // ms\r\n    activeStep: TimeStep;\r\n    _timer: any = undefined;\r\n\r\n    constructor(properties?: IfoShape2DProperties, parent?: foObject) {\r\n        super(properties, parent);\r\n\r\n        this.override(properties);\r\n        this.setPinLeft().setPinTop();\r\n    }\r\n\r\n    start() {\r\n        this._timer && clearTimeout(this._timer);\r\n        this._timer = setTimeout(() => {\r\n            // console.log(this._timer, 'setTimeout');\r\n            if (!!(this._timer && !(this._timer % 2))) {\r\n                this.incrementTimecode();\r\n            }\r\n            this.start();\r\n        }, this.timeDelay);\r\n        return this;\r\n    }\r\n\r\n    stop() {\r\n        this._timer && clearTimeout(this._timer);\r\n        this._timer = undefined;\r\n        this.markAsClean();\r\n    }\r\n\r\n    addEffect(item: Effect<TimeStep>): TimeLinePage {\r\n        this.subcomponents.addMember(item);\r\n        item.computeTimeBoundry(this.timeDelay)\r\n        this.markAsDirty();\r\n        return this;\r\n    }\r\n\r\n    drawTimecode(ctx: CanvasRenderingContext2D) {\r\n        ctx.save();\r\n        ctx.beginPath();\r\n\r\n\r\n        ctx.strokeStyle = 'black';\r\n        ctx.lineWidth = 10;\r\n\r\n        const left = this.marginX - this.x;\r\n        const top = this.marginY - this.y;\r\n        const width = this.width / this.scaleX;\r\n        const height = this.height / this.scaleY;\r\n        const bottom = top + height;\r\n\r\n\r\n        //draw vertical...\r\n        let x = this.gridSizeX * this.timeCode;\r\n        ctx.moveTo(x, top);\r\n        ctx.lineTo(x, bottom);\r\n\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n\r\n    public draw = (ctx: CanvasRenderingContext2D): void => {\r\n        this.drawGrid(ctx);\r\n        //this.drawPage(ctx);\r\n        this.drawTimecode(ctx);\r\n    }\r\n\r\n    setTimecode(code: number) {\r\n        this.timeCode = code - 1;;\r\n        return this.incrementTimecode();\r\n    }\r\n\r\n    incrementTimecode() {\r\n        this.timeCode++;\r\n        if (this.timeCode > this.width / this.gridSizeX) {\r\n            this.timeCode = 0;\r\n        }\r\n        const absTime = this.timeDelay * this.timeCode;\r\n        this._subcomponents?.forEach(item => {\r\n            const step = item as Effect<TimeStep>;\r\n            step.setTimecode(absTime, this.timeCode);\r\n        });\r\n\r\n        this._subcomponents?.forEach(item => {\r\n            const step = item as Effect<TimeStep>;\r\n            this.activeStep = step.activeStep;\r\n            if (step.activeStep != null) {\r\n                //console.log(step.activeStep.color, this.timeCode, this._subcomponents.length)\r\n                rxPubSub.broadcast({\r\n                    groupId: item['groupId'],\r\n                    data: step.activeStep\r\n                })\r\n            }\r\n        })\r\n        return this.markAsDirty();\r\n    }\r\n}\r\n\r\nexport class TimeStep extends foShape2D {\r\n    color: string = 'blue';\r\n    opacity: number = 0.3;\r\n    _width: number = 10;\r\n    _height: number = 50;\r\n\r\n    constructor(properties?: IfoShape2DProperties, parent?: foObject) {\r\n        super(properties, parent);\r\n\r\n        this.override(properties);\r\n        this.setPinLeft().setPinTop();\r\n    }\r\n}\r\n\r\n\r\n\r\nexport interface ITimeLine2DProperties extends IfoShape2DProperties {\r\n    total?: number;\r\n    groupId?: number;\r\n}\r\n\r\nexport class TimeLine<T extends TimeStep> extends foShape2D implements ITimeLine2DProperties {\r\n    opacity: number = 1.0;\r\n    total: number;\r\n    groupId: number;\r\n    private _rebuild: any;\r\n\r\n\r\n    constructor(properties?: ITimeLine2DProperties, parent?: foObject) {\r\n        super(properties, parent);\r\n\r\n        this.override(properties);\r\n        this.setPinLeft().setPinTop();\r\n    }\r\n\r\n    clear() {\r\n        this.subcomponents.clearAll();\r\n    }\r\n    resetSize(i: number) {\r\n        this.total = i;\r\n        this._rebuild && this._rebuild();\r\n        return this;\r\n    }\r\n    horizontal(childType: { new(props?: IfoShape2DProperties): T }, props?: IfoShape2DProperties) {\r\n\r\n        this._rebuild = () => { this.horizontal(childType, props) };\r\n        if (this.subcomponents.length !== this.total) {\r\n            const source = new childType(props);\r\n            this.width = source.width * this.total;\r\n            this.height = source.height;\r\n\r\n            for (let i = 0; i < this.total; i++) {\r\n                const led = new childType({\r\n                    index: i,\r\n                    x: i * (source.width),\r\n                    y: 0,\r\n                    ...props,\r\n                });\r\n                this.subcomponents.addMember(led);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    vertical(childType: { new(props?: IfoShape2DProperties): T }, props?: IfoShape2DProperties) {\r\n\r\n        this._rebuild = () => { this.vertical(childType, props) };\r\n        if (this.subcomponents.length !== this.total) {\r\n            const source = new childType(props);\r\n            this.width = source.width;\r\n            this.height = source.height * this.total;\r\n\r\n            for (let i = 0; i < this.total; i++) {\r\n                const led = new TimeStep({\r\n                    index: i,\r\n                    x: (source.width / 2),\r\n                    y: i * (source.height) + (source.height / 2),\r\n                    ...props,\r\n                });\r\n                this.subcomponents.addMember(led);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    colorRollDown() {\r\n        const items = this.subcomponents.members\r\n        const start = items[0].color;\r\n        for (let i = 1; i < this.total; i++) {\r\n            items[i - 1].color = items[i].color;\r\n        }\r\n        items[this.total - 1].color = start;\r\n    }\r\n\r\n\r\n    colorRollUp() {\r\n        const items = this.subcomponents.members\r\n        const last = this.total - 1\r\n        const end = items[last].color;\r\n        for (let i = last; i > 0; i--) {\r\n            items[i].color = items[i - 1].color;\r\n        }\r\n        items[0].color = end;\r\n    }\r\n}\r\n\r\n\r\n\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\PaintTest4.tsx",["136","137","138","139"],"// https://medium.com/@pdx.lucasm/canvas-with-react-js-32e133c05258\r\n// https://github.com/elchininet/ColorTranslator\r\n\r\n// https://elchininet.github.io/ColorTranslator/\r\n\r\nimport { Canvas } from 'Canvas';\r\n\r\nimport React, { FunctionComponent, ReactElement } from 'react';\r\nimport { ColorArray, LEDLight, LightArray, LightDesignPage } from 'models/lights';\r\nimport { ToJSON } from 'core/foRenderer';\r\nimport { Tools } from 'foundry/models/foTools';\r\nimport { ColorTranslator } from 'colortranslator';\r\nimport { TimeLinePage, TimeStep } from 'models/timeline';\r\nimport { Effect } from 'models/effect';\r\n\r\nexport const PaintTest4: FunctionComponent<any> = (): ReactElement => {\r\n    const sourceLED = new LEDLight();\r\n    const sourceStep = new TimeStep();\r\n\r\n    const timelinePage = new TimeLinePage({\r\n        opacity: 0.02,\r\n        color: 'white',\r\n        width: 160 * sourceStep.width,\r\n        height: 7 * sourceStep.height,\r\n        gridSizeX: sourceStep.width,\r\n        gridSizeY: sourceStep.height\r\n    });\r\n\r\n    const EffectStamp = (size: number = 20, row: number = 1, props?: any) => {\r\n        return new Effect({\r\n            groupId: row,\r\n            total: size,\r\n            x: 0,\r\n            y: sourceStep.height * row\r\n        }).horizontal(TimeStep, props);\r\n    };\r\n\r\n    const Effect1 = EffectStamp(35, 2, { color: 'orange' });\r\n    const Effect2 = EffectStamp(40, 3, { color: 'green' }).followEffect(Effect1);\r\n    const Effect3 = EffectStamp(40, 2, { color: 'yellow' }).followEffect(Effect2);\r\n    const Effect4 = EffectStamp(40, 4, { color: 'red' }).followEffect(Effect3);\r\n\r\n    const Effect5 = EffectStamp(55, 5, { color: 'cyan' });\r\n    Effect5.setX(290);\r\n\r\n\r\n    timelinePage.addEffect(Effect1);\r\n    timelinePage.addEffect(Effect2);\r\n    timelinePage.addEffect(Effect3);\r\n    timelinePage.addEffect(Effect4);\r\n    timelinePage.addEffect(Effect5);\r\n\r\n    const timelineCanvasParams = {\r\n        width: timelinePage.width,\r\n        height: timelinePage.height,\r\n        title: 'Timeline Canvas should draw and wait for change',\r\n        draw: (ctx: CanvasRenderingContext2D) => {\r\n            timelinePage.isDirty && timelinePage.render(ctx);\r\n        }\r\n    };\r\n\r\n    timelinePage.start();\r\n\r\n    const lightPage = new LightDesignPage({\r\n        opacity: 0.02,\r\n        color: 'white',\r\n        width: 71 * sourceLED.width,\r\n        height: 10 * sourceLED.height,\r\n        gridSizeX: sourceLED.width,\r\n        gridSizeY: sourceLED.height\r\n    });\r\n\r\n    const LEDStringStamp = (size: number = 20, row: number = 1, props?: any) => {\r\n        return new LightArray({\r\n            groupId: row,\r\n            total: size,\r\n            x: lightPage.width / 2,\r\n            y: sourceStep.height * row\r\n        }).horizontal(LEDLight, props);\r\n    };\r\n\r\n    const mult = 5;\r\n    const blends = ColorTranslator.getBlendHEX('#FF00FF', '#FFFF00', mult + 10 * mult);\r\n\r\n    const ColorArrayStamp = (colors: string[], row: number = 1) => {\r\n        return new ColorArray({\r\n            colors: colors,\r\n            x: lightPage.width / 2,\r\n            y: sourceLED.height * row\r\n        }).horizontal(LEDLight);\r\n    };\r\n\r\n    const ColorArrayV1 = ColorArrayStamp(blends, 0);\r\n    const ColorArrayV2 = ColorArrayStamp(blends, 1);\r\n    // lightPage.addLightArray(ColorArrayV1);\r\n    // lightPage.addLightArray(ColorArrayV2);\r\n\r\n    const LEDString1 = LEDStringStamp(25, 1);\r\n    const LEDString2 = LEDStringStamp(25, 2);\r\n    const LEDString3 = LEDStringStamp(25, 3);\r\n    const LEDString4 = LEDStringStamp(25, 4);\r\n    const LEDString5 = LEDStringStamp(25, 5);\r\n    const LEDString6 = LEDStringStamp(25, 6);\r\n\r\n    lightPage.addLightArray(LEDString1);\r\n    lightPage.addLightArray(LEDString2);\r\n    lightPage.addLightArray(LEDString3);\r\n    lightPage.addLightArray(LEDString4);\r\n    lightPage.addLightArray(LEDString5);\r\n    lightPage.addLightArray(LEDString6);\r\n\r\n    const lightCanvasParams = {\r\n        width: lightPage.width,\r\n        height: lightPage.height,\r\n        title: 'Light Canvas',\r\n        draw: (ctx: CanvasRenderingContext2D) => {\r\n            lightPage.isDirty && lightPage.render(ctx);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <div>\r\n            <Canvas {...timelineCanvasParams} />\r\n            <Canvas {...lightCanvasParams} />\r\n        </div>\r\n    );\r\n};\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\models\\rxPubSub.ts",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\models\\effect.ts",["140","141","142"],"import { foObject } from \"foundry/models/foObject.model\";\r\nimport { foPage } from \"foundry/models/foPage.model\";\r\nimport { foShape2D, IfoShape2DProperties } from \"foundry/models/foShape2D.model\";\r\nimport { rxPubSub } from \"./rxPubSub\";\r\nimport { ITimeLine2DProperties, TimeLine, TimeStep } from \"./timeline\";\r\n\r\n\r\nexport class EffectStep extends TimeStep {\r\n    color: string = 'tan';\r\n\r\n\r\n    constructor(properties?: IfoShape2DProperties, parent?: foObject) {\r\n        super(properties, parent);\r\n\r\n        this.override(properties);\r\n        this.setPinLeft().setPinTop();\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nexport class Effect<T extends EffectStep> extends TimeLine<T> implements ITimeLine2DProperties {\r\n    timeCode: number = 0;\r\n    absTimeStart: number = 0; // ms\r\n    absTimeSpan: number = 0; // ms\r\n    absTimeEnd: number = 0; // ms\r\n    activeStep: T;\r\n\r\n    constructor(properties?: ITimeLine2DProperties, parent?: foObject) {\r\n        super(properties, parent);\r\n\r\n        this.override(properties);\r\n    }\r\n\r\n    computeTimeBoundry(deltaTime: number) {\r\n        const item = this.subcomponents.first();\r\n        this.absTimeStart = deltaTime * (this.x / item.width);\r\n        this.absTimeSpan = deltaTime * this.subcomponents.length;\r\n        this.absTimeEnd = this.absTimeStart + this.absTimeSpan;\r\n    }\r\n\r\n    computeActiveStep(absTime: number): T {\r\n        const members = this.subcomponents.members;\r\n        const deltaTime = this.absTimeSpan / members.length;\r\n        const localTime = absTime - this.absTimeStart;\r\n        const step = localTime / deltaTime;\r\n        const item = members[step-1];\r\n        this.activeStep = item as T;\r\n        return this.activeStep;\r\n    }\r\n\r\n    setX(x: number) {\r\n        this.x = x;\r\n        return this;\r\n    }\r\n\r\n    followEffect(source: Effect<T>) {\r\n        this.x = source.x + source.width;\r\n        return this;\r\n    }\r\n\r\n    setTimecode(absTime: number, code: number) {\r\n        if (absTime >= this.absTimeStart && absTime <= this.absTimeEnd) {\r\n            this.timeCode = code;\r\n            this.computeActiveStep(absTime);\r\n        } else {\r\n            this.timeCode = -1;\r\n            this.activeStep = undefined;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    \r\n    public draw = (ctx: CanvasRenderingContext2D): void => {\r\n        \r\n        ctx.save();\r\n        ctx.fillStyle = 'black';\r\n        ctx.globalAlpha = 1.0;\r\n\r\n        let x = this.width / 2;\r\n        let y = this.height - 10;\r\n        \r\n        ctx.font = '40px serif';\r\n        this.drawText(ctx, `${this.activeStep ? this.timeCode: '*' }`, x, y);\r\n \r\n        ctx.restore();\r\n    }\r\n}\r\n\r\n",{"ruleId":"143","severity":1,"message":"144","line":3,"column":10,"nodeType":"145","messageId":"146","endLine":3,"endColumn":16},{"ruleId":"147","replacedBy":"148"},{"ruleId":"149","replacedBy":"150"},{"ruleId":"147","replacedBy":"151"},{"ruleId":"149","replacedBy":"152"},{"ruleId":"143","severity":1,"message":"153","line":5,"column":10,"nodeType":"145","messageId":"146","endLine":5,"endColumn":23},{"ruleId":"154","severity":1,"message":"155","line":296,"column":37,"nodeType":"156","messageId":"157","endLine":296,"endColumn":63},{"ruleId":"158","severity":1,"message":"159","line":25,"column":3,"nodeType":"160","messageId":"161","endLine":25,"endColumn":19},{"ruleId":"143","severity":1,"message":"162","line":7,"column":24,"nodeType":"145","messageId":"146","endLine":7,"endColumn":30},{"ruleId":"143","severity":1,"message":"163","line":3,"column":19,"nodeType":"145","messageId":"146","endLine":3,"endColumn":26},{"ruleId":"158","severity":1,"message":"159","line":291,"column":5,"nodeType":"160","messageId":"161","endLine":293,"endColumn":6},{"ruleId":"147","replacedBy":"164"},{"ruleId":"149","replacedBy":"165"},{"ruleId":"147","replacedBy":"166"},{"ruleId":"149","replacedBy":"167"},{"ruleId":"143","severity":1,"message":"168","line":1,"column":10,"nodeType":"145","messageId":"146","endLine":1,"endColumn":15},{"ruleId":"143","severity":1,"message":"169","line":5,"column":10,"nodeType":"145","messageId":"146","endLine":5,"endColumn":19},{"ruleId":"143","severity":1,"message":"170","line":11,"column":10,"nodeType":"145","messageId":"146","endLine":11,"endColumn":21},{"ruleId":"143","severity":1,"message":"171","line":12,"column":8,"nodeType":"145","messageId":"146","endLine":12,"endColumn":13},{"ruleId":"143","severity":1,"message":"172","line":99,"column":15,"nodeType":"145","messageId":"146","endLine":99,"endColumn":20},{"ruleId":"143","severity":1,"message":"173","line":135,"column":11,"nodeType":"145","messageId":"146","endLine":135,"endColumn":18},{"ruleId":"143","severity":1,"message":"174","line":7,"column":10,"nodeType":"145","messageId":"146","endLine":7,"endColumn":18},{"ruleId":"143","severity":1,"message":"175","line":8,"column":10,"nodeType":"145","messageId":"146","endLine":8,"endColumn":16},{"ruleId":"143","severity":1,"message":"176","line":9,"column":10,"nodeType":"145","messageId":"146","endLine":9,"endColumn":13},{"ruleId":"143","severity":1,"message":"177","line":53,"column":15,"nodeType":"145","messageId":"146","endLine":53,"endColumn":19},{"ruleId":"143","severity":1,"message":"178","line":55,"column":15,"nodeType":"145","messageId":"146","endLine":55,"endColumn":20},{"ruleId":"143","severity":1,"message":"144","line":10,"column":10,"nodeType":"145","messageId":"146","endLine":10,"endColumn":16},{"ruleId":"143","severity":1,"message":"168","line":11,"column":10,"nodeType":"145","messageId":"146","endLine":11,"endColumn":15},{"ruleId":"143","severity":1,"message":"179","line":93,"column":11,"nodeType":"145","messageId":"146","endLine":93,"endColumn":23},{"ruleId":"143","severity":1,"message":"180","line":94,"column":11,"nodeType":"145","messageId":"146","endLine":94,"endColumn":23},{"ruleId":"143","severity":1,"message":"175","line":2,"column":10,"nodeType":"145","messageId":"146","endLine":2,"endColumn":16},{"ruleId":"143","severity":1,"message":"181","line":3,"column":10,"nodeType":"145","messageId":"146","endLine":3,"endColumn":19},{"ruleId":"143","severity":1,"message":"182","line":4,"column":10,"nodeType":"145","messageId":"146","endLine":4,"endColumn":18},"@typescript-eslint/no-unused-vars","'ToJSON' is defined but never used.","Identifier","unusedVar","no-native-reassign",["183"],"no-negated-in-lhs",["184"],["183"],["184"],"'TorusGeometry' is defined but never used.","@typescript-eslint/consistent-type-assertions","Use 'as foGlyph2D' instead of '<foGlyph2D>'.","TSTypeAssertion","as","@typescript-eslint/no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","'filter' is defined but never used.","'Matrix3' is defined but never used.",["183"],["184"],["183"],["184"],"'Tools' is defined but never used.","'foGlyph2D' is defined but never used.","'RuntimeType' is defined but never used.","'rules' is defined but never used.","'label' is assigned a value but never used.","'rawdata' is assigned a value but never used.","'foObject' is defined but never used.","'foPage' is defined but never used.","'hub' is defined but never used.","'left' is assigned a value but never used.","'width' is assigned a value but never used.","'ColorArrayV1' is assigned a value but never used.","'ColorArrayV2' is assigned a value but never used.","'foShape2D' is defined but never used.","'rxPubSub' is defined but never used.","no-global-assign","no-unsafe-negation"]