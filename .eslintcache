[{"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\Canvas.tsx":"1","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\CanvasHook.ts":"2","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\index.tsx":"3","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\core\\foRenderer.tsx":"4","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foPage.model.ts":"5","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foGlyph2D.model.ts":"6","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foTools.ts":"7","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foLifecycle.ts":"8","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foObject.model.ts":"9","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foMatrix2D.ts":"10","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foGeometry2D.ts":"11","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foShape2D.model.ts":"12","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foPubSub.ts":"13","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foCollection.model.ts":"14","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foText2D.model.ts":"15","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foUnDo.ts":"16","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\PaintTest2.tsx":"17","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\models\\hub.ts":"18","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\models\\lights.ts":"19","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\PaintTest3.tsx":"20","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\models\\timeline.ts":"21"},{"size":525,"mtime":1607699953262,"results":"22","hashOfConfig":"23"},{"size":1032,"mtime":1607331683811,"results":"24","hashOfConfig":"23"},{"size":275,"mtime":1607698728309,"results":"25","hashOfConfig":"23"},{"size":1640,"mtime":1607314452076,"results":"26","hashOfConfig":"23"},{"size":5576,"mtime":1607397956265,"results":"27","hashOfConfig":"23"},{"size":17870,"mtime":1607397956262,"results":"28","hashOfConfig":"23"},{"size":14138,"mtime":1607659101032,"results":"29","hashOfConfig":"23"},{"size":6154,"mtime":1607314452085,"results":"30","hashOfConfig":"23"},{"size":10904,"mtime":1607314452086,"results":"31","hashOfConfig":"23"},{"size":9184,"mtime":1607397956264,"results":"32","hashOfConfig":"23"},{"size":7560,"mtime":1607315554112,"results":"33","hashOfConfig":"23"},{"size":5903,"mtime":1607397956268,"results":"34","hashOfConfig":"23"},{"size":815,"mtime":1607314452098,"results":"35","hashOfConfig":"23"},{"size":3191,"mtime":1607314452081,"results":"36","hashOfConfig":"23"},{"size":11581,"mtime":1607397956270,"results":"37","hashOfConfig":"23"},{"size":2590,"mtime":1607397956272,"results":"38","hashOfConfig":"23"},{"size":2858,"mtime":1607667522906,"results":"39","hashOfConfig":"23"},{"size":420,"mtime":1607563888383,"results":"40","hashOfConfig":"23"},{"size":4365,"mtime":1607703900415,"results":"41","hashOfConfig":"23"},{"size":3365,"mtime":1607747448747,"results":"42","hashOfConfig":"23"},{"size":3685,"mtime":1607747270532,"results":"43","hashOfConfig":"23"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46","usedDeprecatedRules":"47"},"1x4sejr",{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"47"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"57","usedDeprecatedRules":"47"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"60","usedDeprecatedRules":"47"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63","usedDeprecatedRules":"47"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"66","usedDeprecatedRules":"47"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"73","usedDeprecatedRules":"47"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76","usedDeprecatedRules":"47"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"79"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"82","usedDeprecatedRules":"47"},{"filePath":"83","messages":"84","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"85","usedDeprecatedRules":"79"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"79"},{"filePath":"88","messages":"89","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"90","usedDeprecatedRules":"91"},{"filePath":"92","messages":"93","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"94"},{"filePath":"95","messages":"96","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"97","messages":"98","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"99","messages":"100","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\Canvas.tsx",["101"],"import { useCanvas2D } from 'CanvasHook';\r\nimport React, { Fragment, FunctionComponent, ReactElement } from 'react';\r\nimport { ToJSON } from './core/foRenderer'\r\n\r\n\r\nexport const Canvas: FunctionComponent<any> = (props: any): ReactElement => {\r\n    const { draw, ...rest } = props;\r\n    const canvasRef = useCanvas2D(draw);\r\n\r\n    return (\r\n        <Fragment>\r\n            <h1>{props.title}</h1>\r\n            <canvas ref={canvasRef} {...rest} />\r\n            {/* <ToJSON {...props} /> */}\r\n        </Fragment>\r\n    );\r\n};\r\n\r\n",["102","103"],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\CanvasHook.ts",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\index.tsx",["104"],"import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport { PaintTest2 } from 'PaintTest2';\nimport { PaintTest3 } from 'PaintTest3';\n\n\nReactDOM.render(\n    <React.StrictMode>\n        <PaintTest3 />\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n\n\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\core\\foRenderer.tsx",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foPage.model.ts",["105","106","107","108","109","110","111","112"],"\r\nimport { cPoint2D, cFrame } from './foGeometry2D';\r\nimport { iPoint2D, Action } from './foInterface';\r\n\r\nimport { foGlyph2D, IfoGlyph2DProperties } from './foGlyph2D.model';\r\n\r\nimport { WhereClause } from './foInterface';\r\n\r\nimport { Matrix2D } from './foMatrix2D';\r\nimport { foObject } from './foObject.model';\r\nimport { foShape2D, IfoShape2DProperties } from './foShape2D.model';\r\n\r\nexport interface IfoPageProperties extends IfoShape2DProperties {\r\n  marginX?: number;\r\n  marginY?: number;\r\n  showBoundry?: boolean;\r\n}\r\n\r\n//a Shape is a graphic designed to behave like a visio shape\r\n//and have all the same properties\r\nexport class foPage extends foShape2D implements IfoPageProperties {\r\n  gridSizeX: number = 50;\r\n  gridSizeY: number = 50;\r\n  showBoundry: boolean = true;\r\n\r\n\r\n  constructor(\r\n    properties?: IfoPageProperties,\r\n    parent?: foObject\r\n  ) {\r\n    super(properties, parent);\r\n    this.override(properties);\r\n  }\r\n  \r\n\r\n  protected _marginX: number;\r\n  get marginX(): number {\r\n    return this._marginX || 0.0;\r\n  }\r\n  set marginX(value: number) {\r\n    this.smash();\r\n    this._marginX = value;\r\n  }\r\n\r\n  protected _marginY: number;\r\n  get marginY(): number {\r\n    return this._marginY || 0.0;\r\n  }\r\n  set marginY(value: number) {\r\n    this.smash();\r\n    this._marginY = value;\r\n  }\r\n\r\n  protected _scaleX: number;\r\n  get scaleX(): number {\r\n    return this._scaleX || 1.0;\r\n  }\r\n  set scaleX(value: number) {\r\n    this.smash();\r\n    this._scaleX = value;\r\n  }\r\n\r\n  protected _scaleY: number;\r\n  get scaleY(): number {\r\n    return this._scaleY || 1.0;\r\n  }\r\n  set scaleY(value: number) {\r\n    this.smash();\r\n    this._scaleY = value;\r\n  }\r\n\r\n\r\n  mouseLoc: any = {};\r\n\r\n \r\n\r\n\r\n  // getMatrix() {\r\n  //   if (this._matrix === undefined) {\r\n  //     this._matrix = new Matrix2D();\r\n  //     this._matrix.appendTransform(\r\n  //       this.marginX + this.x,\r\n  //       this.marginY + this.y,\r\n  //       this.scaleX,\r\n  //       this.scaleY,\r\n  //       this.rotationZ(),\r\n  //       0,\r\n  //       0,\r\n  //       this.pinX(),\r\n  //       this.pinY()\r\n  //     );\r\n  //   }\r\n  //   return this._matrix;\r\n  // }\r\n\r\n \r\n\r\n\r\n  zoomBy(zoom: number) {\r\n    this.scaleX *= zoom;\r\n    this.scaleY *= zoom;\r\n  }\r\n\r\n \r\n\r\n\r\n\r\n  drawGrid(ctx: CanvasRenderingContext2D) {\r\n    ctx.save();\r\n    ctx.beginPath();\r\n\r\n    ctx.setLineDash([5, 1]);\r\n    ctx.strokeStyle = 'gray';\r\n\r\n    const left = this.marginX - this.x;\r\n    const top = this.marginY - this.y;\r\n    const width = this.width / this.scaleX;\r\n    const height = this.height / this.scaleY;\r\n    const right = left + width;\r\n    const bottom = top + height;\r\n\r\n    //ctx.fillStyle = 'yellow';\r\n    //ctx.fillRect(left,top, width, height);\r\n\r\n    //draw vertical...\r\n    let x = this.gridSizeX; //left;\r\n    while (x < right) {\r\n      ctx.moveTo(x, top);\r\n      ctx.lineTo(x, bottom);\r\n      x += this.gridSizeX;\r\n    }\r\n    x = -this.gridSizeX; //left;\r\n    while (x > left) {\r\n      ctx.moveTo(x, top);\r\n      ctx.lineTo(x, bottom);\r\n      x -= this.gridSizeX;\r\n    }\r\n\r\n    //draw horizontal...\r\n    let y = this.gridSizeY; //top;\r\n    while (y < bottom) {\r\n      ctx.moveTo(left, y);\r\n      ctx.lineTo(right, y);\r\n      y += this.gridSizeY;\r\n    }\r\n\r\n    y = -this.gridSizeY; //top;\r\n    while (y > top) {\r\n      ctx.moveTo(left, y);\r\n      ctx.lineTo(right, y);\r\n      y -= this.gridSizeY;\r\n    }\r\n\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n\r\n  drawAxis(ctx: CanvasRenderingContext2D) {\r\n    ctx.save();\r\n    ctx.beginPath();\r\n\r\n    ctx.strokeStyle = 'black';\r\n    ctx.lineWidth = 3;\r\n\r\n    const left = this.marginX - this.x;\r\n    const top = this.marginY - this.y;\r\n    const width = this.width / this.scaleX;\r\n    const height = this.height / this.scaleY;\r\n    const right = left + width;\r\n    const bottom = top + height;\r\n\r\n    //draw vertical...\r\n    ctx.moveTo(0, top);\r\n    ctx.lineTo(0, bottom);\r\n\r\n    //draw horizontal...\r\n\r\n    ctx.moveTo(left, 0);\r\n    ctx.lineTo(right, 0);\r\n\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n\r\n  drawPage(ctx: CanvasRenderingContext2D) {\r\n    ctx.save();\r\n    ctx.beginPath();\r\n\r\n    ctx.strokeStyle = 'black';\r\n    ctx.lineWidth = 5;\r\n\r\n    //let left = this.marginX - this.x;\r\n    //let top = this.marginY - this.y;\r\n    //let width = this.width / this.scaleX;\r\n    //let height = this.height / this.scaleY;\r\n    //let right = left + width;\r\n    //let bottom = top + height;\r\n\r\n    //draw vertical...\r\n    ctx.rect(0, 0, this.width, this.height);\r\n\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n\r\n  drawName(ctx: CanvasRenderingContext2D) {\r\n    ctx.save();\r\n    ctx.font = '50pt Calibri';\r\n    ctx.lineWidth = 3;\r\n    ctx.strokeStyle = 'blue';\r\n    ctx.strokeText(this.myName, 10, 50);\r\n    ctx.restore();\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  public render(ctx: CanvasRenderingContext2D, deep: boolean = true) {\r\n    ctx.clearRect(0, 0, this.width, this.height);\r\n\r\n    ctx.save();\r\n   \r\n    this.drawName(ctx);\r\n\r\n    this.preDraw && this.preDraw(ctx);\r\n    this.draw(ctx);\r\n    //this.drawHover && this.drawHover(ctx);\r\n    this.postDraw && this.postDraw(ctx);\r\n\r\n    // deep &&\r\n    //   this._subcomponents.forEach(item => {\r\n    //     item.render(ctx, deep);\r\n    //   });\r\n    ctx.restore();\r\n\r\n    this.showBoundry && this.afterRender(ctx);\r\n  }\r\n\r\n  public preDraw = (ctx: CanvasRenderingContext2D): void => {\r\n    ctx.fillStyle = this.color;\r\n    ctx.fillRect(0, 0, this.width, this.height);\r\n  }\r\n\r\n  public draw = (ctx: CanvasRenderingContext2D): void => {\r\n    this.drawGrid(ctx);\r\n    this.drawAxis(ctx);\r\n    this.drawPage(ctx);\r\n    this.drawPin(ctx);\r\n  }\r\n}\r\n\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foGlyph2D.model.ts",["113","114","115"],"import { Tools } from './foTools';\r\nimport { cPoint2D, cFrame } from './foGeometry2D';\r\nimport { Matrix2D } from './foMatrix2D';\r\n\r\nimport { iShape, iPoint2D, iRect, iFrame } from './foInterface';\r\n\r\n\r\nimport { Lifecycle } from './foLifecycle';\r\n\r\n\r\nimport { foObject } from './foObject.model';\r\nimport Color from 'color';\r\n\r\nexport interface IfoGlyph2DProperties {\r\n  opacity?: number;\r\n  isSelected?: boolean;\r\n  color?: string;\r\n\r\n  x?: number;\r\n  y?: number;\r\n  width?: number;\r\n  height?: number; \r\n  [propName: string]: any;\r\n}\r\n\r\n// a Glyph is a graphic designed to draw on a canvas in absolute coordinates\r\nexport class foGlyph2D extends foObject implements IfoGlyph2DProperties {\r\n\r\n  public opacity: number = 1.0;\r\n  public isSelected: boolean = false;\r\n  public color: any;\r\n\r\n  protected _x: number;\r\n  protected _y: number;\r\n  protected _width: number;\r\n  protected _height: number;\r\n\r\n  constructor(properties?: IfoGlyph2DProperties, parent?: foObject) {\r\n    super(properties, parent);\r\n\r\n    this.override(properties);\r\n  }\r\n\r\n  get x(): number {\r\n    return this._x || 0.0;\r\n  }\r\n  set x(value: number) {\r\n    this.smash();\r\n    this._x = value;\r\n  }\r\n  get y(): number {\r\n    return this._y || 0.0;\r\n  }\r\n  set y(value: number) {\r\n    this.smash();\r\n    this._y = value;\r\n  }\r\n\r\n  get width(): number {\r\n    return this._width || 0.0;\r\n  }\r\n  set width(value: number) {\r\n    this._width = value;\r\n  }\r\n\r\n  get height(): number {\r\n    return this._height || 0.0;\r\n  }\r\n  set height(value: number) {\r\n    this._height = value;\r\n  }\r\n\r\n  public rotationZ = (): number => {\r\n    return 0;\r\n  };\r\n\r\n  public doubleClick: (keys: any) => void;\r\n\r\n  public openEditor: () => void;\r\n  public closeEditor: () => void;\r\n  public drawHover: (ctx: CanvasRenderingContext2D) => void;\r\n  public setupHoverEnterDraw: () => void;\r\n  public setupHoverExitDraw: () => void;\r\n  public setupOverlapEnterDraw: () => void;\r\n  public setupOverlapExitDraw: () => void;\r\n\r\n  public sendKeys: (e: KeyboardEvent, keys: any) => void;\r\n  public preDraw: (ctx: CanvasRenderingContext2D) => void;\r\n  public postDraw: (ctx: CanvasRenderingContext2D) => void;\r\n\r\n  protected _matrix: Matrix2D;\r\n  protected _invMatrix: Matrix2D;\r\n  smash() {\r\n    //console.log('smash matrix')\r\n    this._matrix = undefined;\r\n    this._invMatrix = undefined;\r\n  }\r\n\r\n  computeBoundry(frame: cFrame): cFrame {\r\n    const mtx = this.getGlobalMatrix();\r\n    //this is a buffer so we create less garbage\r\n    const pt = frame.point;\r\n    frame.init(mtx.transformPoint(0, 0, pt));\r\n    frame.minmax(mtx.transformPoint(0, this.height, pt));\r\n    frame.minmax(mtx.transformPoint(this.width, 0, pt));\r\n    frame.minmax(mtx.transformPoint(this.width, this.height, pt));\r\n    return frame;\r\n  }\r\n\r\n  protected _boundry: cFrame = new cFrame(this);\r\n  get boundryFrame(): cFrame {\r\n    this.computeBoundry(this._boundry);\r\n\r\n\r\n    return this._boundry;\r\n  }\r\n\r\n  public drawBoundry(ctx: CanvasRenderingContext2D) {\r\n    ctx.beginPath();\r\n    ctx.setLineDash([5, 5]);\r\n    this.boundryFrame.draw(ctx, false);\r\n    ctx.stroke();\r\n  }\r\n\r\n\r\n\r\n  is2D() {\r\n    return true;\r\n  }\r\n\r\n  set(x: number, y: number, width: number, height: number): iRect {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = width;\r\n    this.height = height;\r\n    return this;\r\n  }\r\n\r\n  contains(x: number, y: number): boolean {\r\n    return (\r\n      this.x <= x &&\r\n      x <= this.x + this.width &&\r\n      this.y <= y &&\r\n      y <= this.y + this.height\r\n    );\r\n  }\r\n\r\n  localContains(x: number, y: number): boolean {\r\n    return 0 <= x && x <= this.width && 0 <= y && y <= this.height;\r\n  }\r\n\r\n  protected toJson(): any {\r\n    return Tools.mixin(super.toJson(), {\r\n      x: this.x,\r\n      y: this.y,\r\n      width: this.width,\r\n      height: this.height\r\n    });\r\n  }\r\n\r\n  public initialize(\r\n    x: number = Number.NaN,\r\n    y: number = Number.NaN,\r\n    ang: number = Number.NaN\r\n  ) {\r\n    return this;\r\n  }\r\n\r\n  public didLocationChange(\r\n    x: number = Number.NaN,\r\n    y: number = Number.NaN,\r\n    angle: number = Number.NaN\r\n  ): boolean {\r\n    let changed = false;\r\n    if (!Number.isNaN(x) && this.x !== x) {\r\n      changed = true;\r\n      this.x = x;\r\n    }\r\n\r\n    if (!Number.isNaN(y) && this.y !== y) {\r\n      changed = true;\r\n      this.y = y;\r\n    }\r\n\r\n    return changed;\r\n  }\r\n\r\n  public easeToNoLifecycle(x: number, y: number) {\r\n    this.initialize(x, y);\r\n    return this;\r\n  }\r\n\r\n  // public easeToNoLifecycle(\r\n  //   x: number,\r\n  //   y: number,\r\n  //   time: number = 0.5,\r\n  //   ease: any = Back.easeInOut\r\n  // ) {\r\n  //   TweenLite.to(this, time, {\r\n  //     x: x,\r\n  //     y: y,\r\n  //     ease: ease\r\n  //     // }).eventCallback(\"onUpdate\", () => {\r\n  //     //     this.drop();\r\n  //   }).eventCallback('onComplete', () => {\r\n  //     this.initialize(x, y);\r\n  //   });\r\n\r\n  //   return this;\r\n  // }\r\n\r\n  // public easeTo(x: number, y: number) {\r\n  //   this.initialize(x, y);\r\n  //   return this;\r\n  // }\r\n\r\n  // public easeTo(\r\n  //   x: number,\r\n  //   y: number,\r\n  //   time: number = 0.5,\r\n  //   ease: any = Back.easeInOut\r\n  // ) {\r\n  //   TweenLite.to(this, time, {\r\n  //     x: x,\r\n  //     y: y,\r\n  //     ease: ease\r\n  //   })\r\n  //     .eventCallback('onUpdate', () => {\r\n  //       this.move();\r\n  //     })\r\n  //     .eventCallback('onComplete', () => {\r\n  //       this.dropAt(x, y);\r\n  //       Lifecycle.easeTo(this, this.getLocation());\r\n  //     });\r\n\r\n  //   return this;\r\n  // }\r\n\r\n  public easeTween(to: any, time: number = 0.5) {\r\n    Lifecycle.easeTween(this, { time, undefined, to });\r\n    return this;\r\n  }\r\n\r\n  // public easeTween(to: any, time: number = 0.5, ease: any = 'ease') {\r\n  //   const from = Tools.union(to, { ease: Back[ease] });\r\n\r\n  //   TweenLite.to(this, time, from).eventCallback('onComplete', () =>\r\n  //     this.override(to)\r\n  //   );\r\n  //   Lifecycle.easeTween(this, { time, ease, to });\r\n  //   return this;\r\n  // }\r\n\r\n  public dropAt(\r\n    x: number = Number.NaN,\r\n    y: number = Number.NaN,\r\n    angle: number = Number.NaN\r\n  ) {\r\n    if (this.didLocationChange(x, y, angle)) {\r\n      Lifecycle.dropped(this, this.getLocation());\r\n    }\r\n    return this;\r\n  }\r\n\r\n  public move(\r\n    x: number = Number.NaN,\r\n    y: number = Number.NaN,\r\n    angle: number = Number.NaN\r\n  ) {\r\n    if (this.didLocationChange(x, y, angle)) {\r\n      Lifecycle.moved(this, this.getLocation());\r\n    }\r\n    return this;\r\n  }\r\n\r\n  public moveTo(loc: iPoint2D, offset?: iPoint2D) {\r\n    const x = loc.x + (offset ? offset.x : 0);\r\n    const y = loc.y + (offset ? offset.y : 0);\r\n    return this.move(x, y);\r\n  }\r\n\r\n  public moveBy(loc: iPoint2D, offset?: iPoint2D) {\r\n    const x = this.x + loc.x + (offset ? offset.x : 0);\r\n    const y = this.y + loc.y + (offset ? offset.y : 0);\r\n    return this.move(x, y);\r\n  }\r\n\r\n  updateContext(ctx: CanvasRenderingContext2D) {\r\n    const mtx = this.getMatrix();\r\n    ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\r\n    ctx.globalAlpha *= this.opacity;\r\n  }\r\n\r\n  getGlobalMatrix() {\r\n    const mtx = new Matrix2D(this.getMatrix());\r\n    const parent = this.myParent && <foGlyph2D>this.myParent();\r\n    if (parent) {\r\n      mtx.prependMatrix(parent.getGlobalMatrix());\r\n    }\r\n    return mtx;\r\n  }\r\n\r\n  getMatrix() {\r\n    if (this._matrix === undefined) {\r\n      this._matrix = new Matrix2D();\r\n      this._matrix.appendTransform(this.x, this.y, 1, 1, 0, 0, 0, 0, 0);\r\n    }\r\n    return this._matrix;\r\n  }\r\n\r\n  getInvMatrix() {\r\n    if (this._invMatrix === undefined) {\r\n      this._invMatrix = this.getMatrix().invertCopy();\r\n    }\r\n    return this._invMatrix;\r\n  }\r\n\r\n  localToGlobal(x: number, y: number, pt?: cPoint2D) {\r\n    const mtx = this.getGlobalMatrix();\r\n    return mtx.transformPoint(x, y, pt);\r\n  }\r\n\r\n  localToGlobalPoint(pt: cPoint2D): cPoint2D {\r\n    const mtx = this.getGlobalMatrix();\r\n    return mtx.transformPoint(pt.x, pt.y, pt);\r\n  }\r\n\r\n  globalToLocal(x: number, y: number, pt?: cPoint2D): cPoint2D {\r\n    const inv = this.getGlobalMatrix().invertCopy();\r\n    return inv.transformPoint(x, y, pt);\r\n  }\r\n\r\n  globalToLocalPoint(pt: cPoint2D): cPoint2D {\r\n    const inv = this.getGlobalMatrix().invertCopy();\r\n    return inv.transformPoint(pt.x, pt.y, pt);\r\n  }\r\n\r\n  globalToLocalFrame(\r\n    x1: number,\r\n    y1: number,\r\n    x2: number,\r\n    y2: number,\r\n    frame?: cFrame\r\n  ): cFrame {\r\n    frame = frame || new cFrame();\r\n    const inv = this.getGlobalMatrix().invertCopy();\r\n\r\n    frame.init(inv.transformPoint(x1, y1, frame.point));\r\n    frame.minmax(inv.transformPoint(x1, y2, frame.point));\r\n    frame.minmax(inv.transformPoint(x2, y1, frame.point));\r\n    frame.minmax(inv.transformPoint(x2, y2, frame.point));\r\n    return frame;\r\n  }\r\n\r\n  localToLocal(\r\n    x: number,\r\n    y: number,\r\n    target: foGlyph2D,\r\n    pt?: cPoint2D\r\n  ): cPoint2D {\r\n    pt = this.localToGlobal(x, y, pt);\r\n    return target.globalToLocal(pt.x, pt.y, pt);\r\n  }\r\n\r\n  globalCenter(): cPoint2D {\r\n    const { x, y } = this.pinLocation();\r\n    const mtx = this.getGlobalMatrix();\r\n    return mtx.transformPoint(x, y);\r\n  }\r\n\r\n  public isDragable = (): boolean => {\r\n    return true;\r\n  };\r\n\r\n  public getOffset = (loc: iPoint2D): iPoint2D => {\r\n    const x = this.x;\r\n    const y = this.y;\r\n    return new cPoint2D(x - loc.x, y - loc.y);\r\n  };\r\n\r\n  public getLocation = (): any => {\r\n    return {\r\n      x: this.x,\r\n      y: this.y,\r\n      z: 0\r\n    };\r\n  };\r\n\r\n  public pinLocation(): any {\r\n    return {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0\r\n    };\r\n  }\r\n\r\n  public setLocation = (loc?: iPoint2D) => {\r\n    this.x = loc ? loc.x : 0;\r\n    this.y = loc ? loc.y : 0;\r\n  };\r\n\r\n  protected localHitTest = (hit: iPoint2D): boolean => {\r\n    const { x, y } = hit;\r\n    const loc = this.globalToLocal(x, y);\r\n\r\n    if (loc.x < 0) return false;\r\n    if (loc.x > this.width) return false;\r\n\r\n    if (loc.y < 0) return false;\r\n    if (loc.y > this.height) return false;\r\n    return true;\r\n  };\r\n\r\n  public hitTest = (hit: iPoint2D): boolean => {\r\n    return this.isHitable && this.isVisible && this.localHitTest(hit);\r\n  };\r\n\r\n  public overlapTest = (hit: iFrame): boolean => {\r\n    const frame = this.globalToLocalFrame(hit.x1, hit.y1, hit.x2, hit.y2);\r\n\r\n    if (this.localContains(frame.x1, frame.y1)) return true;\r\n    if (this.localContains(frame.x1, frame.y2)) return true;\r\n    if (this.localContains(frame.x2, frame.y1)) return true;\r\n    if (this.localContains(frame.x2, frame.y2)) return true;\r\n    return false;\r\n  };\r\n\r\n  // findObjectUnderPoint(hit: iPoint2D, deep: boolean): foGlyph2D {\r\n  //   let found: foGlyph2D = this.hitTest(hit) ? this : undefined;\r\n\r\n  //   if (deep) {\r\n  //     const child = this.findChildObjectUnderPoint(hit);\r\n  //     found = child ? child : found;\r\n  //   }\r\n  //   return found;\r\n  // }\r\n\r\n\r\n\r\n\r\n\r\n\r\n  public afterRender = (\r\n    ctx: CanvasRenderingContext2D,\r\n    deep: boolean = true\r\n  ) => {\r\n    ctx.save();\r\n    ctx.lineWidth = 4;\r\n    ctx.strokeStyle = 'pink';\r\n    this.drawBoundry(ctx);\r\n    ctx.restore();\r\n\r\n    // deep &&\r\n    //   this.nodes.forEach(item => {\r\n    //     item.afterRender(ctx, deep);\r\n    //   });\r\n  };\r\n\r\n  public render(ctx: CanvasRenderingContext2D, deep: boolean = true) {\r\n    if (this.isInvisible) return;\r\n    ctx.save();\r\n\r\n    //this.drawOrigin(ctx);\r\n    this.updateContext(ctx);\r\n    //this.drawOriginX(ctx);\r\n\r\n    this.preDraw && this.preDraw(ctx);\r\n    this.draw(ctx);\r\n    this.drawHover && this.drawHover(ctx);\r\n    this.postDraw && this.postDraw(ctx);\r\n\r\n    //this.isSelected && this.drawSelected(ctx);\r\n\r\n    // deep &&\r\n    //   this.nodes.forEach(item => {\r\n    //     item.render(ctx, deep);\r\n    //   });\r\n\r\n    ctx.restore();\r\n  }\r\n\r\n  public drawFont(\r\n    ctx: CanvasRenderingContext2D,\r\n    size: number = 20,\r\n    fontFamily: string = 'Arial',\r\n    align: any = 'center',\r\n    base: any = 'middle'\r\n  ) {\r\n    ctx.textAlign = align;\r\n    ctx.textBaseline = base;\r\n    ctx.font = `${size}px ${fontFamily}`;\r\n  }\r\n\r\n  //https://stackoverflow.com/questions/6061880/html5-canvas-circle-text\r\n\r\n  public drawTextCircle = (\r\n    ctx: CanvasRenderingContext2D,\r\n    text: string,\r\n    radius: number = 100,\r\n    start: number = Math.PI / 2,\r\n    x: number = 0,\r\n    y: number = 0\r\n  ): void => {\r\n    if (text) {\r\n\r\n      ctx.save();\r\n      ctx.textAlign = 'center';\r\n      ctx.textBaseline = 'middle';\r\n      ctx.translate(x, y);\r\n      ctx.rotate(start - Math.PI / 2);\r\n\r\n      let len = text.length;\r\n      for (let i = 0; i < len; i++) {\r\n        let s = text[i];\r\n        let letterAngle = 0.5 * (ctx.measureText(s).width / radius);\r\n\r\n        ctx.rotate(letterAngle);\r\n        ctx.save();\r\n\r\n        ctx.translate(0, -radius);\r\n        ctx.fillText(s, 0, 0);\r\n        ctx.restore();\r\n\r\n        ctx.rotate(letterAngle);\r\n      }\r\n      ctx.restore();\r\n    }\r\n  };\r\n\r\n  public drawText = (\r\n    ctx: CanvasRenderingContext2D,\r\n    text: string,\r\n    x: number = 0,\r\n    y: number = 0\r\n  ): void => {\r\n    if (text) {\r\n      ctx.fillText(text, x, y);\r\n    }\r\n  };\r\n\r\n  public drawPin(ctx: CanvasRenderingContext2D) {\r\n    const { x, y } = this.pinLocation();\r\n\r\n    ctx.save();\r\n    ctx.beginPath();\r\n\r\n    ctx.arc(x, y, 6, 0, 2 * Math.PI, false);\r\n    ctx.fillStyle = 'pink';\r\n    ctx.fill();\r\n    ctx.lineWidth = 1;\r\n    ctx.strokeStyle = '#003300';\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n\r\n  public drawOrigin(ctx: CanvasRenderingContext2D) {\r\n    const { x, y } = this.pinLocation();\r\n\r\n    ctx.save();\r\n    ctx.beginPath();\r\n    ctx.setLineDash([5, 5]);\r\n    ctx.moveTo(x - 50, y);\r\n    ctx.lineTo(x + 50, y);\r\n    ctx.moveTo(x, y - 50);\r\n    ctx.lineTo(x, y + 50);\r\n    ctx.lineWidth = 1;\r\n    ctx.strokeStyle = '#003300';\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n\r\n  public drawOriginX(ctx: CanvasRenderingContext2D) {\r\n    const { x, y } = this.pinLocation();\r\n\r\n    ctx.save();\r\n    ctx.beginPath();\r\n    ctx.setLineDash([5, 5]);\r\n    ctx.moveTo(x - 50, y - 50);\r\n    ctx.lineTo(x + 50, y + 50);\r\n    ctx.moveTo(x + 50, y - 50);\r\n    ctx.lineTo(x - 50, y + 50);\r\n    ctx.lineWidth = 1;\r\n    ctx.strokeStyle = '#003300';\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n\r\n  public drawHighlight(ctx: CanvasRenderingContext2D) {\r\n    ctx.save();\r\n    ctx.strokeStyle = 'yellow';\r\n    ctx.lineWidth = 4;\r\n    this.drawOutline(ctx);\r\n    ctx.restore();\r\n  }\r\n\r\n  public drawHighlightOverlap(ctx: CanvasRenderingContext2D) {\r\n    ctx.strokeStyle = 'green';\r\n    ctx.lineWidth = 8;\r\n    this.drawOutline(ctx);\r\n    ctx.strokeStyle = 'yellow';\r\n    ctx.lineWidth = 4;\r\n    this.drawOutline(ctx);\r\n  }\r\n\r\n  public drawOutline(ctx: CanvasRenderingContext2D) {\r\n    ctx.beginPath();\r\n    ctx.setLineDash([15, 5]);\r\n    ctx.rect(0, 0, this.width, this.height);\r\n    ctx.stroke();\r\n  }\r\n\r\n\r\n\r\n\r\n  public drawSelected = (ctx: CanvasRenderingContext2D): void => {\r\n    ctx.strokeStyle = 'red';\r\n    ctx.lineWidth = 4;\r\n    this.drawOutline(ctx);\r\n    //this.drawHandles(ctx);\r\n    this.drawPin(ctx);\r\n  };\r\n\r\n  public draw = (ctx: CanvasRenderingContext2D): void => {\r\n    ctx.fillStyle = this.color;\r\n    ctx.lineWidth = 1;\r\n    ctx.fillRect(0, 0, this.width, this.height);\r\n  };\r\n\r\n  toggleSelected() {\r\n    this.isSelected = !this.isSelected;\r\n  }\r\n\r\n  // layoutSubcomponentsVertical(resize: boolean = true, space: number = 0) {\r\n  //   let loc = this.getLocation() as cPoint2D;\r\n  //   const self = this;\r\n\r\n  //   if (resize) {\r\n  //     self.height = self.width = 0;\r\n  //     loc.x = loc.y = 0;\r\n  //   } else {\r\n  //     loc = this.nodes.first().getLocation() as cPoint2D;\r\n  //   }\r\n\r\n  //   this.nodes.forEach(item => {\r\n  //     item.setLocation(loc);\r\n  //   });\r\n\r\n  //   this.nodes.forEach(item => {\r\n  //     const { x: pinX, y: pinY } = item.pinLocation();\r\n  //     loc.x = resize ? pinX : loc.x;\r\n  //     loc.y += pinY;\r\n  //     item.easeToNoLifecycle(loc.x, loc.y);\r\n  //     loc.y += space + item.height - pinY;\r\n\r\n  //     if (resize) {\r\n  //       self.width = Math.max(self.width, item.width);\r\n  //       self.height = loc.y;\r\n  //     }\r\n  //   });\r\n\r\n  //   Lifecycle.layout(this, {\r\n  //     method: 'layoutSubcomponentsVertical',\r\n  //     resize,\r\n  //     space\r\n  //   });\r\n  //   return this;\r\n  // }\r\n\r\n  // layoutSubcomponentsHorizontal(resize: boolean = true, space: number = 0) {\r\n  //   let loc = this.getLocation() as cPoint2D;\r\n  //   const self = this;\r\n\r\n  //   if (resize) {\r\n  //     self.height = self.width = 0;\r\n  //     loc.x = loc.y = 0;\r\n  //   } else {\r\n  //     loc = this.nodes.first().getLocation() as cPoint2D;\r\n  //   }\r\n\r\n  //   this.nodes.forEach(item => {\r\n  //     item.setLocation(loc);\r\n  //   });\r\n\r\n  //   this.nodes.forEach(item => {\r\n  //     const { x: pinX, y: pinY } = item.pinLocation();\r\n  //     loc.x += pinX;\r\n  //     loc.y = resize ? pinY : loc.y;\r\n  //     item.easeToNoLifecycle(loc.x, loc.y);\r\n  //     loc.x += space + item.width - pinX;\r\n\r\n  //     if (resize) {\r\n  //       self.width = loc.x;\r\n  //       self.height = Math.max(self.height, item.height);\r\n  //     }\r\n  //   });\r\n\r\n  //   Lifecycle.layout(this, {\r\n  //     method: 'layoutSubcomponentsHorizontal',\r\n  //     resize,\r\n  //     space\r\n  //   });\r\n  //   return this;\r\n  // }\r\n\r\n  // \r\n\r\n\r\n  // layoutMarginTop(resize: boolean = false, space: number = 0) {\r\n  //   const loc = this.getLocation() as cPoint2D;\r\n  //   const self = this;\r\n\r\n  //   loc.x = 10;\r\n  //   loc.y = space + this.height;\r\n\r\n  //   this.nodes.forEach(item => {\r\n  //     const { x: pinX, y: pinY } = item.pinLocation();\r\n  //     loc.y += pinY;\r\n  //     item.easeToNoLifecycle(loc.x + pinX, loc.y);\r\n  //     loc.y += space + item.height - pinY;\r\n\r\n  //     if (resize) {\r\n  //       self.width = Math.max(self.width, item.width);\r\n  //       self.height = loc.y;\r\n  //     }\r\n  //   });\r\n  //   Lifecycle.layout(this, { method: 'layoutMarginTop', resize, space });\r\n  //   return this;\r\n  // }\r\n}\r\n\r\n\r\n\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foTools.ts",["116"],"export enum foNames {\r\n  UNKNOWN = 'unknown',\r\n  AT = '@',\r\n  THIS = 'this',\r\n  SELF = 'self',\r\n  ROOT = 'root'\r\n}\r\n\r\n// Converts numeric degrees to radians\r\n// if (typeof (Number.prototype.toRad) === \"undefined\") {\r\n//     Number.prototype.toRad = function () {\r\n//         return this * Math.PI / 180;\r\n//     }\r\n// }\r\n// if (typeof (Number.prototype.toDeg) === \"undefined\") {\r\n//     Number.prototype.toDeg = function () {\r\n//         return this * 180 / Math.PI;\r\n//     }\r\n// }\r\n\r\nexport class foTools {\r\n  // Speed up calls to hasOwnProperty\r\n  private hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\n  constructor() {}\r\n\r\n  /**\r\n   * http://stackoverflow.com/questions/6588977/how-to-to-extract-a-javascript-function-from-a-javascript-file\r\n   * @param funct\r\n   */\r\n  getFunctionName(funct) {\r\n    let ret = funct.toString(); //do with regx\r\n    ret = ret.substr('function '.length);\r\n    ret = ret.substr(0, ret.indexOf('('));\r\n    return ret.trim();\r\n  }\r\n\r\n  //http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\r\n  generateUUID() {\r\n    let d = new Date().getTime();\r\n    const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(\r\n      /[xy]/g,\r\n      function(c) {\r\n        // tslint:disable-next-line:no-bitwise\r\n        const r = ((d + Math.random() * 16) % 16) | 0;\r\n        d = Math.floor(d / 16);\r\n        // tslint:disable-next-line:no-bitwise\r\n        return (c === 'x' ? r : (r & 0x7) | 0x8).toString(16);\r\n      }\r\n    );\r\n    return uuid;\r\n  }\r\n\r\n  asJson(target: any) {\r\n    const result = this.stringify(target);\r\n    return JSON.parse(result);\r\n  }\r\n\r\n  stringify(target: any, func = undefined, deep = 3) {\r\n    function resolveReference(value) {\r\n      if (value && value.asReference) {\r\n        return (\r\n          'resolveRef(' +\r\n          value.asReference() +\r\n          ',' +\r\n          value.constructor.name +\r\n          ')'\r\n        );\r\n      }\r\n      return value;\r\n    }\r\n    function resolveCircular(key:string, value:any) {\r\n      switch (key) {\r\n        case 'myParent':\r\n          return resolveReference(value);\r\n        case 'myMembers':\r\n          return value\r\n            ? value.map(function(item) {\r\n                return resolveReference(item);\r\n              })\r\n            : value;\r\n        case '_subcomponents':\r\n          return value;\r\n        case '_lookup':\r\n          return value;\r\n        case '_members':\r\n          return value;\r\n      }\r\n      if (key.startsWith('_')) {\r\n        return;\r\n      }\r\n      //if (this.isCustomLinkName(key)) {\r\n      //    return resolveReference(value);\r\n      //}\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(target, resolveCircular, deep);\r\n  }\r\n\r\n  splitNamespaceType(id: string, primitive?: string) {\r\n    const typeId = id.split('::');\r\n    let result = { namespace: '', name: id };\r\n    if (typeId.length === 2) {\r\n      result = {\r\n        namespace: typeId[0],\r\n        name: typeId[1]\r\n      };\r\n    } else if (primitive) {\r\n      result = {\r\n        namespace: typeId[0],\r\n        name: primitive\r\n      };\r\n    }\r\n    return result;\r\n  }\r\n\r\n  getNamespace(obj) {\r\n    let myNamespace = obj.myType ? obj.myType.split('::') : [''];\r\n    myNamespace = myNamespace[0];\r\n    return myNamespace;\r\n  }\r\n\r\n  getType(obj): string {\r\n    let myType = obj.myType ? obj.myType.split('::') : [''];\r\n    myType = myType.length === 2 ? myType[1] : myType[0];\r\n    return myType;\r\n  }\r\n\r\n  namespace(namespace: string, name: string) {\r\n    return `${namespace}::${name}`;\r\n  }\r\n\r\n  randomInt(low: number, high: number) {\r\n    return low + Math.floor(Math.random() * (high - low + 1));\r\n  }\r\n\r\n  random(low: number, high: number) {\r\n    return low + Math.random() * (high - low);\r\n  }\r\n\r\n  randomRGBColor() {\r\n    // tslint:disable-next-line:no-bitwise\r\n    const r = (255 * Math.random()) | 0;\r\n      // tslint:disable-next-line:no-bitwise\r\n    const g = (255 * Math.random()) | 0;\r\n      // tslint:disable-next-line:no-bitwise\r\n    const b = (255 * Math.random()) | 0;\r\n    return `rgb(${r},${g},${b})`;\r\n  }\r\n\r\n  matches(str1: string, str2: string) {\r\n    if (str1 === str2) {\r\n      return true;\r\n    }\r\n    return (\r\n      str1 && str2 && str1.toLocaleLowerCase() === str2.toLocaleLowerCase()\r\n    );\r\n  }\r\n\r\n  startsWith(str1: string, str2: string) {\r\n    if (str1 === str2) {\r\n      return true;\r\n    }\r\n    return (\r\n      str1 && str2 && str1.toLocaleLowerCase().startsWith(str2.toLocaleLowerCase())\r\n    );\r\n  }\r\n\r\n  capitalizeFirstLetter(str1: string) {\r\n    return str1.charAt(0).toUpperCase() + str1.slice(1);\r\n  }\r\n\r\n  isSelf(ref) {\r\n    return (\r\n      this.matches(ref, foNames.AT) ||\r\n      this.matches(ref, foNames.THIS) ||\r\n      this.matches(ref, foNames.SELF)\r\n    );\r\n  }\r\n\r\n  isArray(obj) {\r\n    if (Array.isArray) {\r\n      return Array.isArray(obj);\r\n    }\r\n    return Object.prototype.toString.call(obj) === '[object Array]'\r\n      ? true\r\n      : false;\r\n  }\r\n\r\n  isFunction(obj) {\r\n    return typeof obj === 'function';\r\n  }\r\n\r\n  isString(obj) {\r\n    return typeof obj === 'string';\r\n  }\r\n\r\n  isNumber(obj) {\r\n    return typeof obj === 'number';\r\n  }\r\n\r\n  isDate(obj) {\r\n    return obj instanceof Date;\r\n  }\r\n\r\n  isObject(obj) {\r\n    return obj && typeof obj === 'object'; //prevents typeOf null === 'object'\r\n  }\r\n\r\n  isCustomLinkName(key) {\r\n    return false;\r\n  }\r\n\r\n  isTyped(obj) {\r\n    return obj && obj.isInstanceOf;\r\n  }\r\n\r\n  isEmpty(obj) {\r\n    // null and undefined are \"empty\"\r\n    if (obj == null) {\r\n      return true;\r\n    }\r\n\r\n    // Assume if it has a length property with a non-zero value\r\n    // that that property is correct.\r\n    if (obj.length > 0) {\r\n      return false;\r\n    }\r\n    if (obj.length === 0) {\r\n      return true;\r\n    }\r\n\r\n    // If it isn't an object at this point\r\n    // it is empty, but it can't be anything *but* empty\r\n    // Is it empty?  Depends on your application.\r\n    if (typeof obj !== 'object') {\r\n      return true;\r\n    }\r\n\r\n    // Otherwise, does it have any properties of its own?\r\n    // Note that this doesn't handle\r\n    // toString and valueOf enumeration bugs in IE < 9\r\n    // tslint:disable-next-line:prefer-const\r\n    for (let key in obj) {\r\n      if (this.hasOwnProperty.call(obj, key)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  removeDQ(str: string): string {\r\n    return str.replace(/^\"(.*)\"$/, '$1');\r\n  }\r\n\r\n  unwrap(str: string): string {\r\n    return str.substring(1, str.length - 1);\r\n  }\r\n\r\n  wrapDQ(str: string): string {\r\n    return `\"${str}\"`;\r\n  }\r\n\r\n  wrapSQ(str: string): string {\r\n    return `'${str}'`;\r\n  }\r\n\r\n  decomposeHostPath(filename) {\r\n    let string = filename.toLowerCase();\r\n    string = string.replace('http://', '');\r\n    string = string.replace('https://', '');\r\n\r\n    const host = string.split('/')[0];\r\n    const path = string.replace(host, '');\r\n    return {\r\n      fullpath: filename,\r\n      host: host,\r\n      path: path\r\n    };\r\n  }\r\n\r\n  extend(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n    // tslint:disable-next-line:prefer-const\r\n    for (let key in source) {\r\n      if (this.hasOwnProperty.call(source, key)) {\r\n        target[key] = source[key];\r\n      }\r\n    }\r\n    return target;\r\n  }\r\n\r\n  mixin(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n    if (!target) {\r\n      return source;\r\n    }\r\n\r\n    for (const key of source) {\r\n      target[key] = source[key];\r\n    }\r\n    return target;\r\n  }\r\n\r\n  mixExact(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n    if (!target) {\r\n      return source;\r\n    }\r\n    for (const key in source) {\r\n      if (foTools.hasOwnProperty.call(target, key)) {\r\n        target[key] = source[key];\r\n      }\r\n    }\r\n    return target;\r\n  }\r\n\r\n  mixout(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n    if (!target) {\r\n      return source;\r\n    }\r\n    for (const key in source) {\r\n      if (this.hasOwnProperty.call(target, key)) {\r\n        delete target[key];\r\n      }\r\n    }\r\n    return target;\r\n  }\r\n\r\n  extract(target, keys?: string[]) {\r\n    const spec = {};\r\n    keys &&\r\n      keys.forEach(key => {\r\n        spec[key] = target[key];\r\n      });\r\n    return spec;\r\n  }\r\n\r\n  mixMap(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n\r\n    let result = {};\r\n    for (let key in target) {\r\n      const keyMap = source[key] || key;\r\n      result[keyMap] = target[key];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  intersect(target, source) {\r\n    if (!source) {\r\n      return target;\r\n    }\r\n    if (!target) {\r\n      return source;\r\n    }\r\n    const intersect = {};\r\n    for (const key in target) {\r\n      if (this.hasOwnProperty.call(source, key)) {\r\n        intersect[key] = source[key];\r\n      } else {\r\n        intersect[key] = target[key];\r\n      }\r\n    }\r\n    return intersect;\r\n  }\r\n\r\n  union(target, source) {\r\n    const result = {};\r\n    if (target) {\r\n      for (let key in target) {\r\n        result[key] = target[key];\r\n      }\r\n    }\r\n    if (source) {\r\n      for (let key in source) {\r\n        result[key] = source[key];\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  defineComputeOnlyProperty(target, name, func) {\r\n    //var self = target;\r\n    Object.defineProperty(target, name, {\r\n      enumerable: true,\r\n      configurable: true,\r\n      get: func\r\n    });\r\n    return target;\r\n  }\r\n\r\n  defineCalculatedProperty(target, name, func) {\r\n    //var self = target;\r\n    Object.defineProperty(target, name, {\r\n      enumerable: true,\r\n      configurable: true,\r\n      get: func, //.call(self, self),\r\n      set: function(value) {\r\n        this[`_${name}`] = value;\r\n      }\r\n    });\r\n    return target;\r\n  }\r\n\r\n  getMethods(obj) {\r\n    const list = [];\r\n    for (const m in obj.prototype) {\r\n      if (typeof obj[m] === 'function') {\r\n        list.push(m);\r\n      }\r\n    }\r\n    return list;\r\n  }\r\n\r\n  asArray(obj, funct?) {\r\n    if (this.isArray(obj)) {\r\n      return obj;\r\n    }\r\n    return this.mapOverKeyValue(obj, function(key, value) {\r\n      return funct ? funct(key, value) : value;\r\n    });\r\n  }\r\n\r\n  applyOverKeyValue(obj, mapFunc) {\r\n    //funct has 2 args.. key,value\r\n    const body = {};\r\n    const keys = obj ? Object.keys(obj) : [];\r\n    keys.forEach(key => {\r\n      if (this.hasOwnProperty.call(obj, key)) {\r\n        const value = obj[key];\r\n        const result = mapFunc(key, value);\r\n        if (result) {\r\n          body[key] = result;\r\n        }\r\n      }\r\n    });\r\n    return body;\r\n  }\r\n\r\n  mapOverKeyValue(obj, mapFunc) {\r\n    //funct has 2 args.. key,value\r\n    const list = [];\r\n    const keys = obj ? Object.keys(obj) : [];\r\n    keys.forEach(key => {\r\n      if (this.hasOwnProperty.call(obj, key)) {\r\n        const value = obj[key];\r\n        const result = mapFunc(key, value);\r\n        if (result) {\r\n          list.push(result);\r\n        }\r\n      }\r\n    });\r\n    return list;\r\n  }\r\n\r\n  forEachKeyValue(obj, mapFunc) {\r\n    //funct has 2 args.. key,value\r\n    const keys = obj ? Object.keys(obj) : [];\r\n    keys.forEach(key => {\r\n      if (this.hasOwnProperty.call(obj, key)) {\r\n        const value = obj[key];\r\n        mapFunc(key, value);\r\n      }\r\n    });\r\n  }\r\n\r\n  findKeyForValue(obj, key) {\r\n    for (const name in obj) {\r\n      if (this.hasOwnProperty.call(obj, key)) {\r\n        if (obj[name].matches(key)) {\r\n          return name;\r\n        }\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n\r\n  extractReadWriteKeys(spec) {\r\n    const keys: string[] = [];\r\n    Tools.forEachKeyValue(spec, (k, v) => {\r\n      if (!Tools.isFunction(v)) {\r\n        keys.push(k);\r\n      }\r\n    });\r\n    return keys;\r\n  }\r\n\r\n  extractComputedKeys(spec) {\r\n    const keys: string[] = [];\r\n    Tools.forEachKeyValue(spec, (k, v) => {\r\n      if (Tools.isFunction(v)) {\r\n        keys.push(k);\r\n      }\r\n    });\r\n    return keys;\r\n  }\r\n\r\n  overrideComputed(obj: any, properties: any) {\r\n    Tools.forEachKeyValue(properties, (key, value) => {\r\n      try {\r\n        if (Tools.isFunction(value)) {\r\n          Tools.defineCalculatedProperty(obj, key, value);\r\n        } else {\r\n          obj[key] = value;\r\n        }\r\n      } catch (ex) {\r\n        console.log(ex);\r\n      }\r\n    });\r\n  }\r\n\r\n  extendComputed(obj: any, properties: any) {\r\n    Tools.forEachKeyValue(properties, (key, value) => {\r\n      try {\r\n        if (!obj[key]) {\r\n          if (Tools.isFunction(value)) {\r\n            Tools.defineCalculatedProperty(obj, key, value);\r\n          } else {\r\n            obj[key] = value;\r\n          }\r\n        }\r\n      } catch (ex) {\r\n        console.log(ex);\r\n      }\r\n    });\r\n  }\r\n\r\n  pluck(name) {\r\n    return function(x) {\r\n      return x[name];\r\n    };\r\n  }\r\n\r\n  distinctItems(list) {\r\n    const distinct = {};\r\n    list.forEach(item => {\r\n      distinct[item] = item;\r\n    });\r\n    return Object.keys(distinct);\r\n  }\r\n\r\n  groupBy(pluckBy, list) {\r\n    const dictionary = {};\r\n    list.forEach(item => {\r\n      const key = pluckBy(item);\r\n      if (!dictionary[key]) {\r\n        dictionary[key] = [];\r\n      }\r\n      dictionary[key].push(item);\r\n    });\r\n    return dictionary;\r\n  }\r\n\r\n  //add this to new service to dynamicaly load javascript,  maybe over signalR\r\n\r\n  // xmlHttpGet(url:string, onComplete, onFailure) {\r\n  //     let xmlHttp = new window.XMLHttpRequest();\r\n  //     xmlHttp.onload = function () {\r\n  //        let result = xmlHttp.responseText;\r\n  //         onComplete && onComplete(result, xmlHttp);\r\n  //     };\r\n  //     try {\r\n  //         xmlHttp.open(\"GET\", url, false);  //this may give chrome some problems\r\n  //         xmlHttp.send(null);\r\n  //     }\r\n  //     catch (ex) {\r\n  //         onFailure && onFailure(ex, xmlHttp);\r\n  //     }\r\n  // }\r\n  // loadAsScript(url:string, onComplete) {\r\n  //     this.xmlHttpGet(url, function (text, xhr) {\r\n  //         if (xhr.status == 200 || xhr.status == 304) {\r\n  //            let head = document.getElementsByTagName(\"head\")[0];\r\n  //            let script = document.createElement('script');\r\n  //             script.innerHTML = text;\r\n  //             head.appendChild(script);\r\n  //             onComplete && onComplete(script);\r\n  //         }\r\n  //     });\r\n  //}\r\n}\r\n\r\nexport let Tools: foTools = new foTools();\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foLifecycle.ts",["117"],"import { Action } from './foInterface';\r\nimport { foObject } from './foObject.model';\r\nimport { Tools } from './foTools';\r\n\r\n// https://github.com/ReactiveX/rxjs/blob/master/docs_app/content/guide/v6/migration.md\r\nimport { Observable, Subject } from 'rxjs';\r\nimport { debounceTime, filter } from 'rxjs/operators';\r\n\r\nlet counter = 0;\r\nexport enum LifecycleEventTypes {\r\n  primitive,\r\n  defined,\r\n  created,\r\n  destroyed,\r\n}\r\n\r\nexport class foLifecycleEvent {\r\n  id: number = 0;\r\n  cmd: string = '';\r\n  object: foObject;\r\n  value: any;\r\n\r\n  get guid() {\r\n    return this.object.myGuid;\r\n  }\r\n  get simpleGuid() {\r\n    return this.object.myGuid.slice(-8);\r\n  }\r\n  get myGuid() {\r\n    return this.object.myGuid;\r\n  }\r\n  get myType() {\r\n    return this.object.myType;\r\n  }\r\n\r\n  get myClass() {\r\n    return this.object['myClass'];\r\n  }\r\n\r\n  get myName() {\r\n    return this.object.myName;\r\n  }\r\n\r\n  isNamed(name: string) {\r\n    return Tools.matches(name, this.myName);\r\n  }\r\n\r\n  isCmd(cmd: string) {\r\n    return Tools.matches(cmd, this.cmd);\r\n  }\r\n\r\n  constructor(cmd: string, obj: foObject, count: number = 0, value?: any) {\r\n    this.id = count;\r\n    this.cmd = cmd;\r\n    this.object = obj;\r\n    this.value = value;\r\n  }\r\n}\r\n\r\n//this is needed to prevent circular communiation\r\n// create => create => create across browsers\r\nexport class foLifecycleEventLock {\r\n  private _processLock = {};\r\n\r\n  isLocked(guid: string) {\r\n    return this._processLock[guid] ? true : false;\r\n  }\r\n\r\n  addLock(guid: string) {\r\n    if (!this.isLocked(guid)) {\r\n      this._processLock[guid] = 0;\r\n    }\r\n    this._processLock[guid] += 1;\r\n  }\r\n\r\n  unLock(guid: string) {\r\n    if (this.isLocked(guid)) {\r\n      this._processLock[guid] -= 1;\r\n      if (this._processLock[guid] <= 0) {\r\n        delete this._processLock[guid];\r\n      }\r\n    }\r\n  }\r\n\r\n  protected(guid: string, context: any, func: Action<any>) {\r\n    this.addLock(guid);\r\n    try {\r\n      func(context);\r\n    } catch (ex) {\r\n      console.error('protected', ex);\r\n    }\r\n    this.unLock(guid);\r\n  }\r\n\r\n  whenUnprotected(guid: string, context: any, func: Action<any>) {\r\n    if (!this.isLocked(guid)) {\r\n      try {\r\n        func(context);\r\n      } catch (ex) {\r\n        console.error('whenUnprotected ', ex);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport let LifecycleLock: foLifecycleEventLock = new foLifecycleEventLock();\r\nexport let KnowcycleLock: foLifecycleEventLock = new foLifecycleEventLock();\r\n\r\n\r\n\r\nexport class foLifecycle {\r\n  mute: boolean = false;\r\n\r\n  public observable: Observable<foLifecycleEvent>;\r\n  public emit: Subject<foLifecycleEvent>;\r\n\r\n  private debounced: Subject<foLifecycleEvent>;\r\n\r\n  constructor(debouce: number = 500) {\r\n    this.emit = new Subject<foLifecycleEvent>();\r\n    this.observable = this.emit.asObservable();\r\n\r\n    this.debounced = new Subject<foLifecycleEvent>();\r\n\r\n    this.debounced\r\n      .asObservable()\r\n      .pipe(debounceTime(debouce))\r\n      .subscribe(event => {\r\n        event.id = counter++;\r\n        this.broadcast(event);\r\n      });\r\n  }\r\n\r\n  broadcast(obj: foLifecycleEvent) {\r\n    !this.mute && this.emit.next(obj);\r\n    return this;\r\n  }\r\n\r\n  primitive(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('primitive', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  defined(obj?: foObject) {\r\n    this.broadcast(new foLifecycleEvent('defined', obj, counter++));\r\n    return this;\r\n  }\r\n\r\n  event(eventName: string, obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent(eventName, obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  created(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('created', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  destroyed(obj: foObject) {\r\n    this.broadcast(new foLifecycleEvent('destroyed', obj, counter++));\r\n    return this;\r\n  }\r\n\r\n  unparent(obj: foObject) {\r\n    this.broadcast(new foLifecycleEvent('unparent', obj, counter++));\r\n    return this;\r\n  }\r\n\r\n  reparent(obj: foObject) {\r\n    this.broadcast(new foLifecycleEvent('reparent', obj, counter++));\r\n    return this;\r\n  }\r\n\r\n  action(obj: foObject, action: string, params?: any) {\r\n    this.broadcast(\r\n      new foLifecycleEvent('run', obj, counter++, {\r\n        action: action,\r\n        params: params\r\n      })\r\n    );\r\n    return this;\r\n  }\r\n\r\n  command(obj: foObject, method: string) {\r\n    this.broadcast(new foLifecycleEvent('command', obj, counter++, method));\r\n    return this;\r\n  }\r\n\r\n  selected(obj: foObject, value: any) {\r\n    this.broadcast(new foLifecycleEvent('selected', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  pageSelections(obj: foObject, value: any) {\r\n    this.broadcast(new foLifecycleEvent('pageselections', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  layout(obj: foObject, value: any) {\r\n    this.broadcast(new foLifecycleEvent('layout', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  changed(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('changed', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  glued(obj: foObject, value: any) {\r\n    this.broadcast(new foLifecycleEvent('glued', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  unglued(obj: foObject, value: any) {\r\n    this.broadcast(new foLifecycleEvent('unglued', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  dropped(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('dropped', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  handle(obj: foObject, value?: any) {\r\n    this.debounced.next(new foLifecycleEvent('handle', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  moved(obj: foObject, value?: any) {\r\n    this.debounced.next(new foLifecycleEvent('moved', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  easeTo(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('easeTo', obj, counter++, value));\r\n    return this;\r\n  }\r\n\r\n  easeTween(obj: foObject, value?: any) {\r\n    this.broadcast(new foLifecycleEvent('easeTween', obj, counter++, value));\r\n    return this;\r\n  }\r\n}\r\n\r\nexport let Lifecycle: foLifecycle = new foLifecycle(300);\r\nexport let Knowcycle: foLifecycle = new foLifecycle();\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foObject.model.ts",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foMatrix2D.ts",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foGeometry2D.ts",["118","119"],"\r\nimport { iPoint2D, iRect, iBox, iMargin, iFrame } from './foInterface';\r\nimport { Vector2, Matrix3 } from 'three';\r\nexport { Vector2, Matrix3 } from 'three';\r\n\r\nexport class cPoint2D extends Vector2 implements iPoint2D {\r\n\r\n    public myName: string;\r\n    public x: number;\r\n    public y: number;\r\n\r\n    constructor(x: number = 0, y: number = 0, name?: string) {\r\n        super(x, y);\r\n        this.myName = name;\r\n    }\r\n\r\n    asVector(): Vector2 {\r\n        return new Vector2(this.x, this.y);\r\n    }\r\n\r\n    setValues(x: number = 0, y: number = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    clonePoint(): cPoint2D {\r\n        return new cPoint2D(this.x, this.y, this.myName);\r\n    }\r\n\r\n    isEqualTo(p: cPoint2D): boolean {\r\n        return this.x === p.x && this.y === p.y;\r\n    }\r\n\r\n    isNear(p: cPoint2D, radius: number): boolean {\r\n        const dx = Math.abs(p.x - this.x);\r\n        if (dx > radius) { return false; }\r\n\r\n        const dy = Math.abs(p.y - this.y);\r\n        if (dy > radius) { return false; }\r\n        return true;\r\n\r\n    }\r\n\r\n    addPoint(x: number = 0, y: number = 0): cPoint2D {\r\n        this.x += x;\r\n        this.y += y;\r\n        return this;\r\n    }\r\n\r\n\r\n\r\n    subtractPoint(x: number = 0, y: number = 0): cPoint2D {\r\n        this.x -= x;\r\n        this.y -= y;\r\n        return this;\r\n    }\r\n\r\n    midPoint(pt: cPoint2D): cPoint2D {\r\n        const x = (this.x + pt.x) / 2;\r\n        const y = (this.y + pt.y) / 2;\r\n        return new cPoint2D(x, y, 'midpoint');\r\n    }\r\n\r\n    mag(): number {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y);\r\n    }\r\n\r\n    atan(): number {\r\n        return Math.atan2(this.y,  this.x);\r\n    }\r\n\r\n    normal(): cPoint2D {\r\n        let mag = this.mag();\r\n        mag = mag ? mag : 1.0; //if zero set to 1 you get the same result\r\n        return new cPoint2D(this.x / mag, this.y / mag, 'normal');\r\n    }\r\n\r\n    sum(p: cPoint2D): cPoint2D {\r\n        this.x += p.x;\r\n        this.y += p.y;\r\n        return this;\r\n    }\r\n\r\n    sumTo(p: cPoint2D): cPoint2D {\r\n        p.x += this.x;\r\n        p.y += this.y;\r\n        return p;\r\n    }\r\n\r\n    setTo(p: cPoint2D): cPoint2D {\r\n        p.x = this.x;\r\n        p.y = this.y;\r\n        return p;\r\n    }\r\n\r\n    subtract(p: cPoint2D): cPoint2D {\r\n        this.x -= p.x;\r\n        this.y -= p.y;\r\n        return this;\r\n    }\r\n\r\n    deltaBetween(pt: cPoint2D): cPoint2D {\r\n        const x = this.x - pt.x;\r\n        const y = this.y - pt.y;\r\n        return new cPoint2D(x, y, 'delta');\r\n    }\r\n\r\n    scale(s: number): cPoint2D {\r\n        this.x *= s;\r\n        this.y *= s;\r\n        return this;\r\n    }\r\n}\r\n\r\nexport class cRect implements iRect {\r\n    public x: number;\r\n    public y: number;\r\n    public width: number;\r\n    public height: number;\r\n    public myName: string;\r\n\r\n    constructor(x: number, y: number, width: number, height: number, name?: string) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.myName = name;\r\n    }\r\n\r\n    moveBy(x: number = 0, y: number = 0): iRect {\r\n        this.x += x;\r\n        this.y += y;\r\n        return this;\r\n    }\r\n\r\n    moveTo(x: number = 0, y: number = 0): iRect {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    sizeBy(width: number, height: number): iRect {\r\n        this.width += width;\r\n        this.height += height;\r\n        return this;\r\n    }\r\n\r\n    sizeTo(width: number, height: number): iRect {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    set(x: number, y: number, width: number, height: number): iRect {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    contains(x: number, y: number) {\r\n        return this.x <= x && x <= this.x + this.width && this.y <= y && y <= this.y + this.height;\r\n    }\r\n\r\n    localContains(x: number, y: number): boolean {\r\n        return 0 <= x && x <= this.width && 0 <= y && y <= this.height;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, fill?: boolean) {\r\n        if (fill) {\r\n            ctx.fillRect(this.x, this.y, this.width, this.height);\r\n        } else {\r\n            ctx.rect(this.x, this.y, this.width, this.height);\r\n        }\r\n        return this;\r\n    }\r\n}\r\n\r\n\r\nexport class cFrame implements iFrame {\r\n    public x1: number;\r\n    public y1: number;\r\n    public x2: number;\r\n    public y2: number;\r\n\r\n    public point: cPoint2D = new cPoint2D();\r\n    public source: any;\r\n\r\n    constructor(source?: any) {\r\n        this.source = source;\r\n    }\r\n\r\n    set(x1: number, y1: number, x2: number, y2: number): iFrame {\r\n        this.x1 = x1;\r\n        this.y1 = y1;\r\n        this.x2 = x2;\r\n        this.y2 = y2;\r\n        return this;\r\n    }\r\n\r\n    width(): number {\r\n        return this.x2 - this.x1;\r\n    }\r\n\r\n    heigth(): number {\r\n        return this.y2 - this.y1;\r\n    }\r\n\r\n    centerX(): number {\r\n        return (this.x2 + this.x1) / 2.0;\r\n    }\r\n\r\n    centerY(): number {\r\n        return (this.y2 + this.y1) / 2.0;\r\n    }\r\n\r\n    init(obj: iPoint2D): iFrame {\r\n        this.x1 = obj.x;\r\n        this.y1 = obj.y;\r\n        this.x2 = obj.x;\r\n        this.y2 = obj.y;\r\n        return this;\r\n    }\r\n\r\n    merge(obj: iFrame): iFrame {\r\n        this.x1 = Math.min(this.x1, obj.x1, obj.x2);\r\n        this.y1 = Math.min(this.y1, obj.y1, obj.y2);\r\n        this.x2 = Math.max(this.x2, obj.x2, obj.x1);\r\n        this.y2 = Math.max(this.y2, obj.y2, obj.y1);\r\n        return this;\r\n    }\r\n\r\n    minmax(obj: iPoint2D): iFrame {\r\n        this.x1 = Math.min(this.x1, obj.x);\r\n        this.y1 = Math.min(this.y1, obj.y);\r\n        this.x2 = Math.max(this.x2, obj.x);\r\n        this.y2 = Math.max(this.y2, obj.y);\r\n        return this;\r\n    }\r\n\r\n    contains(x: number, y: number) {\r\n        return this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, fill?: boolean) {\r\n        const width = this.x2 - this.x1;\r\n        const height = this.y2 - this.y1;\r\n        if (fill) {\r\n            ctx.fillRect(this.x1, this.y1, width, height);\r\n        } else {\r\n            ctx.rect(this.x1, this.y1, width, height);\r\n        }\r\n        return this;\r\n    }\r\n}\r\n\r\nexport class cMargin implements iMargin {\r\n    public left: number = 0;\r\n    public top: number = 0;\r\n    public right: number = 0;\r\n    public bottom: number = 0;\r\n\r\n\r\n    constructor(left: number = 0, top: number = 0, right: number = 0, bottom: number = 0) {\r\n        this.left = left;\r\n        this.top = top;\r\n        this.right = right;\r\n        this.bottom = bottom;\r\n    }\r\n\r\n    setAll(size: number = 0) {\r\n        this.left = size;\r\n        this.top = size;\r\n        this.right = size;\r\n        this.bottom = size;\r\n        return this;\r\n    }\r\n\r\n    get width() {\r\n        return this.left + this.right;\r\n    }\r\n    get height() {\r\n        return this.top + this.bottom;\r\n    }\r\n}\r\n\r\nexport class cBox extends cRect implements iBox {\r\n\r\n    constructor(x: number, y: number, width: number, height: number, name?: string) {\r\n        super(x, y, width, height, name);\r\n    }\r\n\r\n    pinX(): number {\r\n        return 0 * this.width;\r\n    }\r\n\r\n    pinY(): number {\r\n        return 0 * this.height;\r\n    }\r\n\r\n\r\n    draw(ctx: CanvasRenderingContext2D, fill?: boolean) {\r\n        if (fill) {\r\n            ctx.fillRect(this.x, this.y, this.width, this.height);\r\n        } else {\r\n            ctx.rect(this.x, this.y, this.width, this.height);\r\n        }\r\n        return this;\r\n    }\r\n}\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foShape2D.model.ts",["120","121"],"import { Tools } from './foTools';\r\nimport { cPoint2D } from './foGeometry2D';\r\nimport { Vector2, Vector3 } from 'three';\r\nimport { iPoint2D, iFrame } from './foInterface';\r\n\r\nimport { foObject } from './foObject.model';\r\nimport { Matrix2D } from './foMatrix2D';\r\n\r\nimport { foGlyph2D, IfoGlyph2DProperties } from './foGlyph2D.model';\r\n\r\nimport { Lifecycle } from './foLifecycle';\r\nimport { foCollection } from './foCollection.model';\r\n\r\nexport enum shape2DNames {\r\n  left = 'left',\r\n  right = 'right',\r\n  top = 'top',\r\n  bottom = 'bottom',\r\n  center = 'center'\r\n}\r\n\r\nexport interface IfoShape2DProperties extends  IfoGlyph2DProperties {\r\n  angle?: number;\r\n}\r\n\r\n//a Shape is a graphic designed to behave like a visio shape\r\n//and have all the same properties\r\nexport class foShape2D extends foGlyph2D implements IfoShape2DProperties {\r\n  protected _angle: number;\r\n  get angle(): number {\r\n    return this._angle || 0.0;\r\n  }\r\n  set angle(value: number) {\r\n    this.smash();\r\n    this._angle = value;\r\n  }\r\n\r\n  protected _subcomponents: foCollection<foShape2D>;\r\n  get subcomponents(): foCollection<foShape2D> {\r\n    if (!this._subcomponents) {\r\n      this._subcomponents = new foCollection<foShape2D>()\r\n    }\r\n    return this._subcomponents;\r\n  }\r\n\r\n  public pinX = (): number => 0.5 * this.width;\r\n  public pinY = (): number => 0.5 * this.height;\r\n  public rotationZ = (): number => this.angle;\r\n\r\n  public setPinLeft() {\r\n    this.pinX = (): number => 0.0 * this.width;\r\n    return this;\r\n  }\r\n  public setPinRight() {\r\n    this.pinX = (): number => 1.0 * this.width;\r\n    return this;\r\n  }\r\n  public setPinCenter() {\r\n    this.pinX = (): number => 0.5 * this.width;\r\n    return this;\r\n  }\r\n\r\n  public setPinTop() {\r\n    this.pinY = (): number => 0.0 * this.height;\r\n    return this;\r\n  }\r\n  public setPinMiddle() {\r\n    this.pinY = (): number => 0.5 * this.height;\r\n    return this;\r\n  }\r\n  public setPinBottom() {\r\n    this.pinY = (): number => 1.0 * this.height;\r\n    return this;\r\n  }\r\n\r\n  pinVector(): Vector3 {\r\n    return new Vector3(this.pinX(), this.pinY(), 0);\r\n  }\r\n\r\n  protected originPosition(): Vector3 {\r\n    const pin = this.pinVector();\r\n    return new Vector3(this.x - pin.x, this.y - pin.y, 0);\r\n  }\r\n\r\n  public pinLocation() {\r\n    return {\r\n      x: this.pinX(),\r\n      y: this.pinY(),\r\n      z: 0\r\n    };\r\n  }\r\n\r\n  constructor(\r\n    properties?: IfoShape2DProperties,\r\n    parent?: foObject\r\n  ) {\r\n    super(properties, parent);\r\n    this.override(properties);\r\n  }\r\n\r\n  protected toJson(): any {\r\n    return Tools.mixin(super.toJson(), {\r\n      angle: this.angle\r\n      // glue: this._glue && Tools.asArray(this.glue.asJson)\r\n    });\r\n  }\r\n\r\n  public didLocationChange(\r\n    x: number = Number.NaN,\r\n    y: number = Number.NaN,\r\n    angle: number = Number.NaN\r\n  ): boolean {\r\n    let changed = super.didLocationChange(x, y, angle);\r\n    if (!Number.isNaN(angle) && this.angle !== angle) {\r\n      changed = true;\r\n      this.angle = angle;\r\n    }\r\n    return changed;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  public move(\r\n    x: number = Number.NaN,\r\n    y: number = Number.NaN,\r\n    angle: number = Number.NaN\r\n  ) {\r\n    if (this.didLocationChange(x, y, angle)) {\r\n      const point = this.getLocation();\r\n\r\n      Lifecycle.moved(this, point);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  updateContext(ctx: CanvasRenderingContext2D) {\r\n    const mtx = this.getMatrix();\r\n    ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\r\n    ctx.globalAlpha *= this.opacity;\r\n  }\r\n\r\n  getMatrix() {\r\n    if (this._matrix === undefined) {\r\n      this._matrix = new Matrix2D();\r\n      this._matrix.appendTransform(\r\n        this.x,\r\n        this.y,\r\n        1,\r\n        1,\r\n        this.rotationZ(),\r\n        0,\r\n        0,\r\n        this.pinX(),\r\n        this.pinY()\r\n      );\r\n    }\r\n    return this._matrix;\r\n  }\r\n\r\n  protected localHitTest = (hit: any): boolean => {\r\n    const { x, y } = hit as iPoint2D;\r\n    const loc = this.globalToLocal(x, y);\r\n\r\n    if (loc.x < 0) return false;\r\n    if (loc.x > this.width) return false;\r\n\r\n    if (loc.y < 0) return false;\r\n    if (loc.y > this.height) return false;\r\n\r\n    return true;\r\n  }\r\n\r\n  public hitTest = (hit: any): boolean => {\r\n    return this.isHitable && this.isVisible && this.localHitTest(hit);\r\n  }\r\n\r\n  public overlapTest = (hit: iFrame): boolean => {\r\n    const frame = this.globalToLocalFrame(hit.x1, hit.y1, hit.x2, hit.y2);\r\n\r\n    if (this.localContains(frame.x1, frame.y1)) return true;\r\n    if (this.localContains(frame.x1, frame.y2)) return true;\r\n    if (this.localContains(frame.x2, frame.y1)) return true;\r\n    if (this.localContains(frame.x2, frame.y2)) return true;\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n  public render(ctx: CanvasRenderingContext2D, deep: boolean = true) {\r\n    if (this.isInvisible) return;\r\n    ctx.save();\r\n\r\n    //this.drawOrigin(ctx);\r\n    this.updateContext(ctx);\r\n    //this.drawOriginX(ctx);\r\n\r\n    this.preDraw && this.preDraw(ctx);\r\n    this.draw(ctx);\r\n    this.drawHover && this.drawHover(ctx);\r\n    this.postDraw && this.postDraw(ctx);\r\n\r\n    this.isSelected && this.drawSelected(ctx);\r\n\r\n    deep &&\r\n      this._subcomponents?.forEach(item => {\r\n        item.render(ctx, deep);\r\n      });\r\n    ctx.restore();\r\n  }\r\n\r\n  public drawOutline(ctx: CanvasRenderingContext2D) {\r\n    ctx.beginPath();\r\n    ctx.setLineDash([15, 5]);\r\n    ctx.rect(0, 0, this.width, this.height);\r\n    ctx.stroke();\r\n  }\r\n\r\n  public drawSelected = (ctx: CanvasRenderingContext2D): void => {\r\n    ctx.strokeStyle = 'red';\r\n    ctx.lineWidth = 4;\r\n    this.drawOutline(ctx);\r\n\r\n    this.drawPin(ctx);\r\n  }\r\n\r\n  public drawBackground = (ctx: CanvasRenderingContext2D): void => {\r\n    ctx.fillStyle = this.color;\r\n    ctx.lineWidth = 1;\r\n    ctx.globalAlpha = this.opacity;\r\n    ctx.fillRect(0, 0, this.width, this.height);\r\n  }\r\n\r\n  public draw = (ctx: CanvasRenderingContext2D): void => {\r\n    this.drawBackground(ctx);\r\n  }\r\n}\r\n\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foPubSub.ts",[],["122","123"],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foCollection.model.ts",["124"],"import { Tools } from './foTools';\r\nimport { foObject } from './foObject.model';\r\nimport { iObject, Action, Func } from './foInterface';\r\n\r\n//we want foCollection to be observable\r\n\r\nexport class foCollection<T extends iObject> extends foObject {\r\n  protected _members: Array<T>;\r\n\r\n  isHidden: boolean = false;\r\n  isSelectable: boolean = true;\r\n  constructor(list?: Array<T>) {\r\n    super();\r\n\r\n    this._members = new Array<T>();\r\n    list && list.forEach(item => this.addMember(item));\r\n  }\r\n\r\n  getChildAt(i: number): T {\r\n    return this._members[i];\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this._members.length === 0;\r\n  }\r\n\r\n  clearAll() {\r\n    this._members = [];\r\n  }\r\n\r\n  get length() {\r\n    return this._members.length;\r\n  }\r\n\r\n  get count() {\r\n    return this._members.length;\r\n  }\r\n\r\n  get hasMembers(): boolean {\r\n    return this.length > 0;\r\n  }\r\n\r\n  map(funct) {\r\n    return this._members.map(funct);\r\n  }\r\n\r\n  forEach(funct: Action<T>) {\r\n    this._members.forEach(funct);\r\n  }\r\n\r\n  first() {\r\n    return this._members[0];\r\n  }\r\n\r\n  last() {\r\n    return this._members[this._members.length - 1];\r\n  }\r\n\r\n  filter(funct: Func<T, boolean>) {\r\n    return this._members.filter(funct);\r\n  }\r\n\r\n  find(funct: Func<T, boolean>) {\r\n    return this._members.find(funct);\r\n  }\r\n\r\n  findMember(name: string): T {\r\n    const found = this._members.find(item => {\r\n      return item.myName === name || item.myGuid === name;\r\n    });\r\n    return found;\r\n  }\r\n\r\n  getMember(id): T {\r\n    return this._members[id];\r\n  }\r\n\r\n  copyMembers(list: foCollection<T>): foCollection<T> {\r\n    list.members.forEach(item => {\r\n      this.addMember(item);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  isMember(item: T) {\r\n    const loc = this._members.indexOf(item);\r\n    return loc !== -1;\r\n  }\r\n\r\n  push(obj: any) {\r\n    this._members.push(obj);\r\n  }\r\n  shift(): any {\r\n    return this._members.shift();\r\n  }\r\n\r\n  addMember(obj: T): T {\r\n    this._members.push(obj);\r\n    return obj;\r\n  }\r\n\r\n  removeMembers(list: foCollection<T>): foCollection<T> {\r\n    list.members.forEach(item => {\r\n      this.removeMember(item);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  removeMember(obj: T): T {\r\n    const index = this._members.indexOf(obj);\r\n    if (index > -1) {\r\n      this._members.splice(index, 1);\r\n    }\r\n    return obj;\r\n  }\r\n\r\n  get members() {\r\n    return this._members;\r\n  }\r\n\r\n  get publicMembers() {\r\n    return this.members.filter(item => item.isPublic);\r\n  }\r\n\r\n  moveToTop(item: T) {\r\n    const loc = this._members.indexOf(item);\r\n    if (loc !== -1) {\r\n      this._members.splice(loc, 1);\r\n      this._members.push(item);\r\n    }\r\n    return this._members;\r\n  }\r\n\r\n  moveToBottom(item: T) {\r\n    const loc = this._members.indexOf(item);\r\n    if (loc !== -1) {\r\n      this._members.splice(loc, 1);\r\n      this._members.unshift(item);\r\n    }\r\n    return this._members;\r\n  }\r\n\r\n  protected toJson(): any {\r\n    if ( this.hasMembers ) {\r\n      const local = super.toJson();\r\n      local.members = this._members.map(item => item.asJson);\r\n      return local;\r\n    }\r\n    return {};\r\n  }\r\n\r\n  public isEqualTo(obj: foCollection<T>, deep: boolean = true) {\r\n    const result = true;\r\n    return result;\r\n  }\r\n}\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foText2D.model.ts",["125","126"],"import { Tools } from './foTools';\r\nimport { cMargin } from './foGeometry2D';\r\n\r\nimport { foObject } from './foObject.model';\r\nimport { foGlyph2D } from './foGlyph2D.model';\r\n\r\nimport { foShape2D, IfoShape2DProperties } from './foShape2D.model';\r\n\r\nimport { foUnDo } from './foUnDo';\r\n\r\nimport { RuntimeType } from './foRuntimeType';\r\n\r\n// ctx.textAlign = \"left\" || \"right\" || \"center\" || \"start\" || \"end\";\r\n\r\n// ctx.textBaseline = \"top\" || \"hanging\" || \"middle\" || \"alphabetic\" || \"ideographic\" || \"bottom\";\r\n\r\n// ctx.font = '48px serif';\r\n// ctx.font = \"20px Georgia\";\r\n// ctx.font = \"italic 10pt Courier\";\r\n// ctx.font = \"bold 10pt Courier\";\r\n// ctx.font = \"italic bold 10pt Courier\";\r\n\r\nexport interface IfoText2DProperties extends IfoShape2DProperties {\r\n  text?: string;\r\n  fontSize?: number;\r\n  font?: string;\r\n\r\n  background?: string;\r\n}\r\n\r\n//a Shape is a graphic designed to behave like a visio shape\r\n//and have all the same properties\r\nexport class foText2D extends foShape2D implements IfoText2DProperties {\r\n  public text: string;\r\n  public textAlign: string;\r\n  public textBaseline: string;\r\n\r\n  public margin: cMargin;\r\n  public fontSize: number;\r\n  public font: string;\r\n  public resize: boolean = false;\r\n\r\n  protected _background: string;\r\n  get background(): string {\r\n    return this._background || this.color;\r\n  }\r\n  set background(value: string) {\r\n    this._background = value;\r\n  }\r\n\r\n  public pinX = (): number => {\r\n    return 0.5 * this.width;\r\n  }\r\n  public pinY = (): number => {\r\n    return 0.5 * this.height;\r\n  }\r\n\r\n  constructor(\r\n    properties?: IfoText2DProperties,\r\n    parent?: foObject\r\n  ) {\r\n    super(properties, parent);\r\n\r\n    this.override(properties);\r\n    this.setupPreDraw();\r\n  }\r\n\r\n  protected toJson(): any {\r\n    return Tools.mixin(super.toJson(), {\r\n      text: this.text,\r\n      background: this.background,\r\n      fontSize: this.fontSize,\r\n      margin: this.margin\r\n    });\r\n  }\r\n\r\n  get size(): number {\r\n    return this.fontSize || 12;\r\n  }\r\n\r\n  updateContext(ctx: CanvasRenderingContext2D) {\r\n    super.updateContext(ctx);\r\n\r\n    this.drawFont(ctx, this.size, this.font, this.textAlign, this.textBaseline);\r\n  }\r\n\r\n  setupPreDraw() {\r\n    const preDraw = (ctx: CanvasRenderingContext2D): void => {\r\n      if (this.resize) {\r\n        const textMetrics = ctx.measureText(this.text);\r\n        this.width = textMetrics.width + ((this.margin && this.margin.width) || 0);\r\n        this.height = this.size + ((this.margin && this.margin.height) || 0);\r\n      }\r\n      //this.createConnectionPoints();\r\n      //this.createHandles();\r\n      this.preDraw = undefined;\r\n    };\r\n\r\n    this.preDraw = preDraw;\r\n  }\r\n\r\n  public splitText(ctx: CanvasRenderingContext2D, text: string, maxWidth: number): Array<string> {\r\n    const result: Array<string> = new Array<string>();\r\n    const words = text.replace(':', ': ').split(' ');\r\n\r\n    let firstWord = words[0];\r\n    let size = ctx.measureText(firstWord);\r\n    const perChar = size.width / firstWord.length;\r\n    const maxChar = Math.ceil(maxWidth / perChar) - 3;\r\n\r\n    //fill result based on running size\r\n    let phrase = '';\r\n    words.forEach(word => {\r\n      if (phrase.length + word.length + 1 <= maxChar) {\r\n        phrase += ` ${word}`;\r\n      } else {\r\n        result.push(phrase);\r\n        phrase = `${word}`;\r\n      }\r\n    });\r\n    result.push(phrase);\r\n\r\n    return result;\r\n  }\r\n\r\n  public drawOutline(ctx: CanvasRenderingContext2D) {\r\n    ctx.beginPath();\r\n    ctx.setLineDash([15, 5]);\r\n    ctx.rect(0, 0, this.width, this.height);\r\n    ctx.stroke();\r\n  }\r\n\r\n  public drawDefaultSelected(ctx: CanvasRenderingContext2D) {\r\n    ctx.strokeStyle = 'red';\r\n    ctx.lineWidth = 1;\r\n    this.drawOutline(ctx);\r\n    //this.drawHandles(ctx);\r\n    //this.drawConnectionPoints(ctx);\r\n    this.drawPin(ctx);\r\n  }\r\n\r\n  public drawSelected = this.drawDefaultSelected;\r\n\r\n  public drawBackground = (ctx: CanvasRenderingContext2D): void => {\r\n    ctx.fillStyle = this.background;\r\n    ctx.fillRect(0, 0, this.width, this.height);\r\n  }\r\n\r\n  public maxTextWidth() {\r\n    return this.width;\r\n  }\r\n\r\n  public drawTextBox(ctx: CanvasRenderingContext2D, text: string) {\r\n    const left = (this.margin && this.margin.left) || 0;\r\n    const top = (this.margin && this.margin.top) || 0;\r\n    \r\n    // let x = this.pinX() + left;\r\n    let x = this.width/2 +  left;\r\n\r\n    //let y = this.pinY() + top;\r\n    let y = this.height/2 + top;\r\n\r\n    let dy = this.size + 4;\r\n\r\n    let list = this.splitText(ctx, text, this.maxTextWidth());\r\n    y -= (list.length / 2) * dy;\r\n    list.forEach(txt => {\r\n      this.drawText(ctx, txt, x, y);\r\n      y += dy; //rule of thumb to prevent true measure\r\n    });\r\n  }\r\n\r\n  public draw = (ctx: CanvasRenderingContext2D): void => {\r\n\r\n    ctx.save();\r\n\r\n    if (this.background) {\r\n      this.drawBackground(ctx);\r\n    }\r\n\r\n    ctx.fillStyle = this.color;\r\n\r\n    this.drawTextBox(ctx, this.text);\r\n    //this.drawTextCircle(ctx, this.text.toUpperCase(), 0.46 * this.width, 0, this.pinX(), this.pinY());\r\n\r\n    ctx.restore();\r\n  }\r\n}\r\n\r\nexport class foInputText2D extends foText2D {\r\n  private UnDo: foUnDo = new foUnDo();\r\n  private isEditing: boolean = false;\r\n  private showCursor: boolean = false;\r\n  private cursorStart: number;\r\n  private cursorEnd: number;\r\n\r\n  private timer: any;\r\n  private undoRoot: any;\r\n  private initState: any;\r\n\r\n  private setState(state: any) {\r\n    this.text = state.text;\r\n    this.cursorStart = state.start;\r\n    this.cursorEnd = state.end;\r\n  }\r\n\r\n  private getState() {\r\n    return { text: this.text, start: this.cursorStart, end: this.cursorEnd };\r\n  }\r\n\r\n  public doubleClick = (keys: any) => {\r\n  }\r\n\r\n  public openEditor = () => {\r\n    this.isEditing = true;\r\n    this.drawSelected = this.drawIsEditing;\r\n    this.timer = setInterval(() => {\r\n      this.showCursor = !this.showCursor;\r\n    }, 600);\r\n    this.cursorStart = this.cursorEnd = this.text.length;\r\n    this.initState = this.getState();\r\n\r\n    this.UnDo.registerActions(\r\n      'shapeTextChanged',\r\n      p => {\r\n        return p;\r\n      },\r\n      p => {\r\n        return p;\r\n      },\r\n      (o, n) => {\r\n        return o !== n;\r\n      }\r\n    );\r\n  }\r\n\r\n  public closeEditor = () => {\r\n    this.isEditing = false;\r\n    this.drawSelected = this.drawDefaultSelected;\r\n    clearInterval(this.timer);\r\n    this.UnDo.clear();\r\n  }\r\n\r\n  public addCharacter(char) {\r\n    const state = this.getState();\r\n    if (this.UnDo.verifyKeep(this.undoRoot, state)) {\r\n      this.undoRoot = this.UnDo.do('shapeTextChanged', state);\r\n    }\r\n\r\n    const text =\r\n      this.text.slice(0, this.cursorStart) +\r\n      char +\r\n      this.text.slice(this.cursorEnd);\r\n    this.text = text;\r\n    this.cursorStart += 1;\r\n    this.cursorEnd = this.cursorStart;\r\n  }\r\n\r\n  public delCharacter() {\r\n    if (this.cursorStart === 0) return;\r\n\r\n    const state = this.getState();\r\n    if (this.UnDo.verifyKeep(this.undoRoot, state)) {\r\n      this.undoRoot = this.UnDo.do('shapeTextChanged', state);\r\n    }\r\n\r\n    const text =\r\n      this.text.slice(0, this.cursorStart - 1) +\r\n      this.text.slice(this.cursorEnd);\r\n    this.text = text;\r\n    this.cursorStart -= 1;\r\n    this.cursorEnd = this.cursorStart;\r\n  }\r\n\r\n  public sendKeys = (e: KeyboardEvent, keys: any) => {\r\n    if (keys.ctrl && e.key === 'e') {\r\n      this.isEditing ? this.closeEditor() : this.openEditor();\r\n    } else if (keys.ctrl && e.key === 'z') {\r\n      this.UnDo.canUndo() && this.setState(this.UnDo.unDo());\r\n    } else if (this.isEditing) {\r\n      this.editText(e, keys);\r\n    }\r\n    this.setupPreDraw();\r\n  }\r\n\r\n  editText(e: KeyboardEvent, keys: any) {\r\n    if (keys.ctrl && e.key === 'a') {\r\n      this.cursorStart = 0;\r\n      this.cursorEnd = this.text.length;\r\n    } else if (keys.ctrl) {\r\n      return;\r\n    } else if (e.keyCode >= 48 && e.keyCode <= 90) {\r\n      this.addCharacter(e.key);\r\n    } else if (e.keyCode === 32) {\r\n      //space\r\n      this.addCharacter(e.key);\r\n    } else if (e.keyCode === 46) {\r\n      //del\r\n      this.delCharacter();\r\n    } else if (e.keyCode === 8) {\r\n      //backspace\r\n      this.delCharacter();\r\n    } else {\r\n      this.processKeys(e, keys);\r\n    }\r\n  }\r\n\r\n  // 27: \"esc\",\r\n  // 32: \"space\",\r\n  // 33: \"pageup\",\r\n  // 34: \"pagedown\",\r\n  // 35: \"end\",\r\n  // 36: \"home\",\r\n  // 37: \"left\",\r\n  // 38: \"up\",\r\n  // 39: \"right\",\r\n  // 45: \"insert\",\r\n  // 46: \"delete\",\r\n\r\n  processKeys(e: KeyboardEvent, keys: any) {\r\n    const select = keys.shift;\r\n    switch (e.keyCode) {\r\n      case 36: // home\r\n        this.cursorStart = 0;\r\n        if (!select) this.cursorEnd = this.cursorStart;\r\n        break;\r\n      case 35: // end\r\n        this.cursorEnd = this.text.length;\r\n        if (!select) this.cursorStart = this.cursorEnd;\r\n        break;\r\n      case 37: // left\r\n        if (this.cursorStart > 0) {\r\n          this.cursorStart -= 1;\r\n          if (!select) this.cursorEnd = this.cursorStart;\r\n        }\r\n        break;\r\n      case 39: // right\r\n        if (this.cursorEnd < this.text.length) {\r\n          this.cursorEnd += 1;\r\n          if (!select) this.cursorStart = this.cursorEnd;\r\n        }\r\n        break;\r\n      case 13: // return\r\n        this.closeEditor();\r\n        break;\r\n      case 27: // esc\r\n        this.setState(this.initState);\r\n        this.closeEditor();\r\n        break;\r\n      default:\r\n        if (e.key.length === 1) {\r\n          this.addCharacter(e.key);\r\n        }\r\n        break;\r\n    }\r\n  }\r\n\r\n  public drawIsEditing(ctx: CanvasRenderingContext2D) {\r\n    ctx.strokeStyle = 'green';\r\n    ctx.lineWidth = 1;\r\n    ctx.beginPath();\r\n    ctx.rect(0, 0, this.width, this.height);\r\n    ctx.stroke();\r\n\r\n    this.drawSelect(ctx);\r\n    this.showCursor && this.drawCursor(ctx);\r\n    this.draw(ctx);\r\n  }\r\n\r\n  public drawSelect(ctx: CanvasRenderingContext2D) {\r\n    if (this.cursorStart === this.cursorEnd) return;\r\n\r\n    const textStart = this.text.substr(0, this.cursorStart);\r\n    const start = ctx.measureText(textStart);\r\n    const startPos = start.width + ((this.margin && this.margin.width) || 0);\r\n\r\n    const textEnd = this.text.substr(0, this.cursorEnd);\r\n    const end = ctx.measureText(textEnd);\r\n    const endPos = end.width + ((this.margin && this.margin.width) || 0);\r\n\r\n    ctx.fillStyle = 'yellow';\r\n    ctx.fillRect(startPos, 0, endPos - startPos, this.height);\r\n  }\r\n\r\n  public drawCursor(ctx: CanvasRenderingContext2D) {\r\n    const textStart = this.text.substr(0, this.cursorStart);\r\n    const start = ctx.measureText(textStart);\r\n    const startPos = start.width + ((this.margin && this.margin.width) || 0);\r\n\r\n    ctx.fillStyle = 'red';\r\n    ctx.fillRect(startPos, 0, 2, this.height);\r\n  }\r\n\r\n  // drawMultiLineText(ctx: CanvasRenderingContext2D, text: string) {\r\n\r\n  //     //let textMetrics = ctx.measureText(text);\r\n\r\n  //     ctx.textAlign = \"left\" || \"right\" || \"center\" || \"start\" || \"end\";\r\n\r\n  //     ctx.textBaseline = \"top\" || \"hanging\" || \"middle\" || \"alphabetic\" || \"ideographic\" || \"bottom\";\r\n\r\n  //     ctx.font = '48px serif';\r\n  //     ctx.font = \"20px Georgia\";\r\n  //     ctx.font = \"italic 10pt Courier\";\r\n  //     ctx.font = \"bold 10pt Courier\";\r\n  //     ctx.font = \"italic bold 10pt Courier\";\r\n\r\n  //     //http://junerockwell.com/end-of-line-or-line-break-in-html5-canvas/\r\n  //     let fontsize = 60;\r\n  //     let array = text.split('|');\r\n  //     let dx = 10;\r\n  //     let dy = 20;\r\n  //     for (var i = 0; i < array.length; i++) {\r\n  //         ctx.fillText(array[i], dx, dy);\r\n  //         dy += (fontsize + 4);\r\n  //     }\r\n\r\n  // }\r\n}\r\n\r\n\r\n//RuntimeType.define(foText2D);\r\n//RuntimeType.define(foInputText2D);\r\n","C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\foundry\\models\\foUnDo.ts",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\PaintTest2.tsx",["127"],"// https://medium.com/@pdx.lucasm/canvas-with-react-js-32e133c05258\r\n// https://github.com/elchininet/ColorTranslator\r\n\r\n// https://elchininet.github.io/ColorTranslator/\r\n\r\nimport { Canvas } from 'Canvas';\r\nimport { foObject } from 'foundry/models/foObject.model';\r\nimport { foPage } from 'foundry/models/foPage.model';\r\nimport { hub } from './models/hub';\r\n\r\nimport React, { FunctionComponent, ReactElement } from 'react';\r\nimport { ColorArray, LEDLight, LightArray } from 'models/lights';\r\nimport { ToJSON } from 'core/foRenderer';\r\nimport { Tools } from 'foundry/models/foTools';\r\nimport { ColorTranslator } from 'colortranslator';\r\n\r\n\r\n\r\nexport const PaintTest2: FunctionComponent<any> = (props: any): ReactElement => {\r\n\r\n    const page2 = new foPage({\r\n        opacity: 0.02,\r\n        color: 'white',\r\n        width: 1500,\r\n        height: 500\r\n    });\r\n\r\n\r\n    const shape2 = new hub({\r\n        x: page2.width / 2,\r\n        y: page2.height / 2\r\n    });\r\n\r\n\r\n    const LEDArrayH = new LightArray({\r\n        opacity: 0.1,\r\n        x: page2.width / 2,\r\n        y: page2.height / 2\r\n    })\r\n        .horizontal(LEDLight, { color: 'orange', opacity: 0.4 })\r\n        .resetSize(20);\r\n    \r\n    const mult = 5;\r\n     const blends = ColorTranslator.getBlendHEX('#FF00FF', '#FFFF00', mult + 10 * mult);\r\n\r\n    const LEDArrayV = new LightArray({\r\n        angle: 90,\r\n        x: page2.width / 2,\r\n        y: page2.height * 2/3\r\n    })\r\n        .vertical(LEDLight, { color: 'red', opacity: 0.4 })\r\n        .resetSize(13);\r\n\r\n    const ColorArrayV = new ColorArray({\r\n        colors: blends,\r\n        x: page2.width / 2,\r\n        y: page2.height / 3\r\n    }).horizontal(LEDLight);\r\n    \r\n    const canvas2Params = {\r\n        width: 1500,\r\n        height: 800,\r\n        title: 'Draw a string of lights',\r\n        draw: (ctx: CanvasRenderingContext2D, count: number) => {\r\n            page2.render(ctx);\r\n            shape2.render(ctx);\r\n            LEDArrayH.render(ctx);\r\n            LEDArrayV.render(ctx);\r\n            ColorArrayV.render(ctx);\r\n            ColorArrayV.colorRoll();\r\n        }\r\n    };\r\n\r\n\r\n\r\n    // const container = document.createElement('div');\r\n    // const rows = 11;\r\n    // const mult = 3;\r\n\r\n    // for (let i = 0; i < rows; i++) {\r\n    //     const blends = ColorTranslator.getBlendHEX('#FF0000', '#FFFF00', mult + i * mult);\r\n\r\n    //     blends.forEach((blend, index) => {\r\n    //         const box = document.createElement('div');\r\n    //         box.classList.add('box', `file${i}`);\r\n    //         box.style.background = blend;\r\n    //         box.innerText = index + 1;\r\n    //         container.appendChild(box);\r\n    //     });\r\n    // }\r\n\r\n    // return container;\r\n\r\n\r\n    return (\r\n        <div>\r\n            <Canvas {...canvas2Params} />\r\n            <ToJSON {...Tools.asJson(ColorArrayV)} />\r\n        </div>\r\n    );\r\n};\r\n\r\n\r\n",["128","129"],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\models\\hub.ts",[],["130","131"],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\models\\lights.ts",[],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\PaintTest3.tsx",["132","133","134"],"C:\\Users\\Steve\\workspace\\FoundryDotNet5\\foundry-canvas-react\\src\\models\\timeline.ts",[],{"ruleId":"135","severity":1,"message":"136","line":3,"column":10,"nodeType":"137","messageId":"138","endLine":3,"endColumn":16},{"ruleId":"139","replacedBy":"140"},{"ruleId":"141","replacedBy":"142"},{"ruleId":"135","severity":1,"message":"143","line":4,"column":10,"nodeType":"137","messageId":"138","endLine":4,"endColumn":20},{"ruleId":"135","severity":1,"message":"144","line":2,"column":10,"nodeType":"137","messageId":"138","endLine":2,"endColumn":18},{"ruleId":"135","severity":1,"message":"145","line":2,"column":20,"nodeType":"137","messageId":"138","endLine":2,"endColumn":26},{"ruleId":"135","severity":1,"message":"146","line":3,"column":10,"nodeType":"137","messageId":"138","endLine":3,"endColumn":18},{"ruleId":"135","severity":1,"message":"147","line":3,"column":20,"nodeType":"137","messageId":"138","endLine":3,"endColumn":26},{"ruleId":"135","severity":1,"message":"148","line":5,"column":10,"nodeType":"137","messageId":"138","endLine":5,"endColumn":19},{"ruleId":"135","severity":1,"message":"149","line":5,"column":21,"nodeType":"137","messageId":"138","endLine":5,"endColumn":41},{"ruleId":"135","severity":1,"message":"150","line":7,"column":10,"nodeType":"137","messageId":"138","endLine":7,"endColumn":21},{"ruleId":"135","severity":1,"message":"151","line":9,"column":10,"nodeType":"137","messageId":"138","endLine":9,"endColumn":18},{"ruleId":"135","severity":1,"message":"152","line":5,"column":10,"nodeType":"137","messageId":"138","endLine":5,"endColumn":16},{"ruleId":"135","severity":1,"message":"153","line":12,"column":8,"nodeType":"137","messageId":"138","endLine":12,"endColumn":13},{"ruleId":"154","severity":1,"message":"155","line":296,"column":37,"nodeType":"156","messageId":"157","endLine":296,"endColumn":63},{"ruleId":"158","severity":1,"message":"159","line":25,"column":3,"nodeType":"160","messageId":"161","endLine":25,"endColumn":19},{"ruleId":"135","severity":1,"message":"162","line":7,"column":24,"nodeType":"137","messageId":"138","endLine":7,"endColumn":30},{"ruleId":"135","severity":1,"message":"163","line":3,"column":19,"nodeType":"137","messageId":"138","endLine":3,"endColumn":26},{"ruleId":"158","severity":1,"message":"159","line":291,"column":5,"nodeType":"160","messageId":"161","endLine":293,"endColumn":6},{"ruleId":"135","severity":1,"message":"144","line":2,"column":10,"nodeType":"137","messageId":"138","endLine":2,"endColumn":18},{"ruleId":"135","severity":1,"message":"164","line":3,"column":10,"nodeType":"137","messageId":"138","endLine":3,"endColumn":17},{"ruleId":"139","replacedBy":"165"},{"ruleId":"141","replacedBy":"166"},{"ruleId":"135","severity":1,"message":"167","line":1,"column":10,"nodeType":"137","messageId":"138","endLine":1,"endColumn":15},{"ruleId":"135","severity":1,"message":"148","line":5,"column":10,"nodeType":"137","messageId":"138","endLine":5,"endColumn":19},{"ruleId":"135","severity":1,"message":"168","line":11,"column":10,"nodeType":"137","messageId":"138","endLine":11,"endColumn":21},{"ruleId":"135","severity":1,"message":"169","line":7,"column":10,"nodeType":"137","messageId":"138","endLine":7,"endColumn":18},{"ruleId":"139","replacedBy":"170"},{"ruleId":"141","replacedBy":"171"},{"ruleId":"139","replacedBy":"172"},{"ruleId":"141","replacedBy":"173"},{"ruleId":"135","severity":1,"message":"169","line":7,"column":10,"nodeType":"137","messageId":"138","endLine":7,"endColumn":18},{"ruleId":"135","severity":1,"message":"174","line":9,"column":10,"nodeType":"137","messageId":"138","endLine":9,"endColumn":13},{"ruleId":"135","severity":1,"message":"175","line":12,"column":32,"nodeType":"137","messageId":"138","endLine":12,"endColumn":42},"@typescript-eslint/no-unused-vars","'ToJSON' is defined but never used.","Identifier","unusedVar","no-native-reassign",["176"],"no-negated-in-lhs",["177"],"'PaintTest2' is defined but never used.","'cPoint2D' is defined but never used.","'cFrame' is defined but never used.","'iPoint2D' is defined but never used.","'Action' is defined but never used.","'foGlyph2D' is defined but never used.","'IfoGlyph2DProperties' is defined but never used.","'WhereClause' is defined but never used.","'Matrix2D' is defined but never used.","'iShape' is defined but never used.","'Color' is defined but never used.","@typescript-eslint/consistent-type-assertions","Use 'as foGlyph2D' instead of '<foGlyph2D>'.","TSTypeAssertion","as","@typescript-eslint/no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","'filter' is defined but never used.","'Matrix3' is defined but never used.","'Vector2' is defined but never used.",["176"],["177"],"'Tools' is defined but never used.","'RuntimeType' is defined but never used.","'foObject' is defined but never used.",["176"],["177"],["176"],["177"],"'hub' is defined but never used.","'LightArray' is defined but never used.","no-global-assign","no-unsafe-negation"]